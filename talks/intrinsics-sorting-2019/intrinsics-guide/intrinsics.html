<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta http-equiv="X-UA-Compatible" content="IE=9; IE=8; IE=7; IE=EDGE">
		<title>Intel® Intrinsics Guide</title>
		<link rel="shortcut icon" href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/favicon.ico">
		<link type="text/css" rel="stylesheet" href="intrinsics_files/style.css">
		<script type="text/javascript" async="" src="intrinsics_files/dc.js"></script><script type="text/javascript" src="intrinsics_files/jquery-1.js"></script>
		<link href="intrinsics_files/css.css" rel="stylesheet" type="text/css">
		<meta name="fragment" content="!">
		<meta name="Description" content="The Intel Intrinsics Guide is an interactive reference tool for Intel intrinsic instructions, which are C style functions that provide access to many Intel instructions - including Intel® SSE, AVX, AVX-512, and more - without the need to write assembly code.">
		<script type="text/javascript">
		  var _gaq = _gaq || [];
		  _gaq.push(['_setAccount', 'UA-17890616-1']);
		  _gaq.push(['_setDomainName', 'intel.com']);
		  _gaq.push(['_trackPageview']);
		  (function() {
		    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
		    ga.src = ('https:' == document.location.protocol ? 'https://' : 'http://') + 'stats.g.doubleclick.net/dc.js';
		    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		  })();
		</script>
	</head>

	<body>
		
		<div id="container">
			
			<div id="left">
				
				<div>
					<img id="logo" src="intrinsics_files/intel.png" alt="Intel">
					<div id="title"><b>Intrinsics Guide</b></div>
					<div style="clear:both;"></div>
				</div><br>
				
				<div><b>Technologies</b></div>
				<div id="techs">
					<div class="MMX tech"><input type="checkbox"> MMX</div>
					<div class="SSE tech"><input type="checkbox"> SSE</div>
					<div class="SSE2 tech"><input type="checkbox"> SSE2</div>
					<div class="SSE3 tech"><input type="checkbox"> SSE3</div>
					<div class="SSSE3 tech"><input type="checkbox"> SSSE3</div>
					<div class="SSE4_1 tech"><input type="checkbox"> SSE4.1</div>
					<div class="SSE4_2 tech"><input type="checkbox"> SSE4.2</div>
					<div class="AVX tech"><input type="checkbox"> AVX</div>
					<div class="AVX2 tech"><input type="checkbox"> AVX2</div>
					<div class="FMA tech"><input type="checkbox"> FMA</div>
					<div class="AVX_512 tech"><input type="checkbox"> AVX-512</div>
					<div id="avx512_techs" style="display: none;">
						<div class="AVX512F avx512tech"><input type="checkbox"> AVX-512F</div>
						<div class="AVX512BW avx512tech"><input type="checkbox"> AVX-512BW</div>
						<div class="AVX512CD avx512tech"><input type="checkbox"> AVX-512CD</div>
						<div class="AVX512DQ avx512tech"><input type="checkbox"> AVX-512DQ</div>
						<div class="AVX512ER avx512tech"><input type="checkbox"> AVX-512ER</div>
						<div class="AVX512IFMA52 avx512tech"><input type="checkbox"> AVX-512IFMA52</div>
						<div class="AVX512PF avx512tech"><input type="checkbox"> AVX-512PF</div>
						<div class="AVX512VL avx512tech"><input type="checkbox"> AVX-512VL</div>
						<div class="AVX512VPOPCNTDQ avx512tech"><input type="checkbox"> AVX-512VPOPCNTDQ</div>
						<div class="AVX512_4FMAPS avx512tech"><input type="checkbox"> AVX-512_4FMAPS</div>
						<div class="AVX512_4VNNIW avx512tech"><input type="checkbox"> AVX-512_4VNNIW</div>
						<div class="AVX512_BF16 avx512tech"><input type="checkbox"> AVX-512_BF16</div>
						<div class="AVX512_BITALG avx512tech"><input type="checkbox"> AVX-512_BITALG</div>
						<div class="AVX512_VBMI avx512tech"><input type="checkbox"> AVX-512_VBMI</div>
						<div class="AVX512_VBMI2 avx512tech"><input type="checkbox"> AVX-512_VBMI2</div>
						<div class="AVX512_VNNI avx512tech"><input type="checkbox"> AVX-512_VNNI</div>
					</div>
					<div class="KNC tech"><input type="checkbox"> KNC</div>
					<div class="SVML tech"><input type="checkbox"> SVML</div>
					<div class="Other tech"><input type="checkbox"> Other</div>
					<div id="other_techs" style="display: none;"><div class="ADX othertech"><input type="checkbox"> ADX</div><div class="AES othertech"><input type="checkbox"> AES</div><div class="BMI1 othertech"><input type="checkbox"> BMI1</div><div class="BMI2 othertech"><input type="checkbox"> BMI2</div><div class="CLDEMOTE othertech"><input type="checkbox"> CLDEMOTE</div><div class="CLFLUSHOPT othertech"><input type="checkbox"> CLFLUSHOPT</div><div class="CLWB othertech"><input type="checkbox"> CLWB</div><div class="FP16C othertech"><input type="checkbox"> FP16C</div><div class="FSGSBASE othertech"><input type="checkbox"> FSGSBASE</div><div class="FXSR othertech"><input type="checkbox"> FXSR</div><div class="GFNI othertech"><input type="checkbox"> GFNI</div><div class="INVPCID othertech"><input type="checkbox"> INVPCID</div><div class="LZCNT othertech"><input type="checkbox"> LZCNT</div><div class="MONITOR othertech"><input type="checkbox"> MONITOR</div><div class="MOVBE othertech"><input type="checkbox"> MOVBE</div><div class="MOVDIR64B othertech"><input type="checkbox"> MOVDIR64B</div><div class="MOVDIRI othertech"><input type="checkbox"> MOVDIRI</div><div class="MPX othertech"><input type="checkbox"> MPX</div><div class="PCLMULQDQ othertech"><input type="checkbox"> PCLMULQDQ</div><div class="PCONFIG othertech"><input type="checkbox"> PCONFIG</div><div class="POPCNT othertech"><input type="checkbox"> POPCNT</div><div class="PREFETCHWT1 othertech"><input type="checkbox"> PREFETCHWT1</div><div class="RDPID othertech"><input type="checkbox"> RDPID</div><div class="RDRAND othertech"><input type="checkbox"> RDRAND</div><div class="RDSEED othertech"><input type="checkbox"> RDSEED</div><div class="RDTSCP othertech"><input type="checkbox"> RDTSCP</div><div class="RTM othertech"><input type="checkbox"> RTM</div><div class="SHA othertech"><input type="checkbox"> SHA</div><div class="TSC othertech"><input type="checkbox"> TSC</div><div class="VAES othertech"><input type="checkbox"> VAES</div><div class="VPCLMULQDQ othertech"><input type="checkbox"> VPCLMULQDQ</div><div class="WAITPKG othertech"><input type="checkbox"> WAITPKG</div><div class="WBNOINVD othertech"><input type="checkbox"> WBNOINVD</div><div class="XSAVE othertech"><input type="checkbox"> XSAVE</div><div class="XSAVEC othertech"><input type="checkbox"> XSAVEC</div><div class="XSAVEOPT othertech"><input type="checkbox"> XSAVEOPT</div><div class="XSS othertech"><input type="checkbox"> XSS</div></div>
				</div><br>

				<div><b>Categories</b></div>
				<div id="categories"><div class="category"><input type="checkbox"> <span>Application-Targeted</span></div><div class="category"><input type="checkbox"> <span>Arithmetic</span></div><div class="category"><input type="checkbox"> <span>Bit Manipulation</span></div><div class="category"><input type="checkbox"> <span>Cast</span></div><div class="category"><input type="checkbox"> <span>Compare</span></div><div class="category"><input type="checkbox"> <span>Convert</span></div><div class="category"><input type="checkbox"> <span>Cryptography</span></div><div class="category"><input type="checkbox"> <span>Elementary Math Functions</span></div><div class="category"><input type="checkbox"> <span>General Support</span></div><div class="category"><input type="checkbox"> <span>Load</span></div><div class="category"><input type="checkbox"> <span>Logical</span></div><div class="category"><input type="checkbox"> <span>Mask</span></div><div class="category"><input type="checkbox"> <span>Miscellaneous</span></div><div class="category"><input type="checkbox"> <span>Move</span></div><div class="category"><input type="checkbox"> <span>OS-Targeted</span></div><div class="category"><input type="checkbox"> <span>Probability/Statistics</span></div><div class="category"><input type="checkbox"> <span>Random</span></div><div class="category"><input type="checkbox"> <span>Set</span></div><div class="category"><input type="checkbox"> <span>Shift</span></div><div class="category"><input type="checkbox"> <span>Special Math Functions</span></div><div class="category"><input type="checkbox"> <span>Store</span></div><div class="category"><input type="checkbox"> <span>String Compare</span></div><div class="category"><input type="checkbox"> <span>Swizzle</span></div><div class="category"><input type="checkbox"> <span>Trigonometry</span></div></div>

				<br><a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/LegalStatement.html" style="font-size:80%;">Legal Statement</a>
			</div>
			
			<div id="main">
			
				<div id="about" style="">
					The Intel Intrinsics Guide is an interactive reference tool for 
Intel intrinsic instructions, which are C style functions that provide 
access to many Intel instructions - including Intel® SSE, AVX, AVX-512, 
and more - without the need to write assembly code.
					<img id="close" src="intrinsics_files/x.png" alt="Close">
				</div>
			
				<div id="info" style="color: rgb(8, 114, 197);">?</div>
				<div id="search_wrapper">
					<div id="search_tokens"></div>
					<input id="search" type="text" value="_mm_search" autocomplete="off">
					<img id="clear" src="intrinsics_files/x.png" style="display:none;" alt="Clear">
				</div><br>
				
				<div id="intrinsics_list" style="min-height: 160680px;"><div class="intrinsic AVX_512" id="0"><div class="instruction">vp4dpwssd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_4dpwssd_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_4dpwssd_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vp4dpwssd zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4VNNIW</span></div><h1>Description</h1><div class="description">Compute
 4 sequential operand source-block dot-products of two signed 16-bit 
element operands with 32-bit element accumulation, and store the results
 in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	FOR m := 0 to 3
		lim_base := m*32
		i := j*32
		tl := b[lim_base+15:lim_base]
		tu := b[lim_base+31:lim_base+16]
		lword := a{m}[i+15:i] * tl
		uword := a{m}[i+31:i+16] * tu
		dst[i+31:i] := src[i+31:i] + lword + uword
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="1"><div class="instruction">vp4dpwssd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_4dpwssd_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_4dpwssd_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vp4dpwssd zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4VNNIW</span></div><h1>Description</h1><div class="description">Compute
 4 sequential operand source-block dot-products of two signed 16-bit 
element operands with 32-bit element accumulation with mask, and store 
the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	IF mask[j]
		FOR m := 0 to 3
			lim_base := m*32
			i := j*32
			tl := b[lim_base+15:lim_base]
			tu := b[lim_base+31:lim_base+16]
			lword := a{m}[i+15:i] * tl
			uword := a{m}[i+31:i+16] * tu
			dst[i+31:i] := src[i+31:i] + lword + uword
		ENDFOR
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="2"><div class="instruction">vp4dpwssd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_4dpwssd_epi32</span> (<span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span></div><div class="details" style="display: none;"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_4dpwssd_epi32</span> (<span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vp4dpwssd zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4VNNIW</span></div><h1>Description</h1><div class="description">Compute
 4 sequential operand source-block dot-products of two signed 16-bit 
element operands with 32-bit element accumulation with mask, and store 
the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	IF mask[j]
		FOR m := 0 to 3
			lim_base := m*32
			i := j*32
			tl := b[lim_base+15:lim_base]
			tu := b[lim_base+31:lim_base+16]
			lword := a{m}[i+15:i] * tl
			uword := a{m}[i+31:i+16] * tu
			dst[i+31:i] := src[i+31:i] + lword + uword
		ENDFOR
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="3"><div class="instruction">vp4dpwssds</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_4dpwssds_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_4dpwssds_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vp4dpwssds zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4VNNIW</span></div><h1>Description</h1><div class="description">Compute
 4 sequential operand source-block dot-products of two signed 16-bit 
element operands with 32-bit element accumulation and signed saturation,
 and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	FOR m := 0 to 3
		lim_base := m*32
		i := j*32
		tl := b[lim_base+15:lim_base]
		tu := b[lim_base+31:lim_base+16]
		lword := a{m}[i+15:i] * tl
		uword := a{m}[i+31:i+16] * tu
		dst[i+31:i] := SIGNED_DWORD_SATURATE(src[i+31:i] + lword + uword)
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="4"><div class="instruction">vp4dpwssds</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_4dpwssds_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_4dpwssds_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vp4dpwssds zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4VNNIW</span></div><h1>Description</h1><div class="description">Compute
 4 sequential operand source-block dot-products of two signed 16-bit 
element operands with 32-bit element accumulation with mask and signed 
saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set)..</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	IF mask[i]
		FOR m := 0 to 3
			lim_base := m*32
			i := j*32
			tl := b[lim_base+15:lim_base]
			tu := b[lim_base+31:lim_base+16]
			lword := a{m}[i+15:i] * tl
			uword := a{m}[i+31:i+16] * tu
			dst[i+31:i] := SIGNED_DWORD_SATURATE(src[i+31:i] + lword + uword)
		ENDFOR
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="5"><div class="instruction">vp4dpwssds</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_4dpwssds_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_4dpwssds_epi32</span> (<span class="param_type">_m512i</span> <span class="param_name">src</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">a0</span>, <span class="param_type">_m512i</span> <span class="param_name">a1</span>, <span class="param_type">_m512i</span> <span class="param_name">a2</span>, <span class="param_type">_m512i</span> <span class="param_name">a3</span>, <span class="param_type">_m128i *</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vp4dpwssds zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4VNNIW</span></div><h1>Description</h1><div class="description">Compute
 4 sequential operand source-block dot-products of two signed 16-bit 
element operands with 32-bit element accumulation with mask and signed 
saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set)..</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	IF mask[i]
		FOR m := 0 to 3
			lim_base := m*32
			i := j*32
			tl := b[lim_base+15:lim_base]
			tu := b[lim_base+31:lim_base+16]
			lword := a{m}[i+15:i] * tl
			uword := a{m}[i+31:i+16] * tu
			dst[i+31:i] := SIGNED_DWORD_SATURATE(src[i+31:i] + lword + uword)
		ENDFOR
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="6"><div class="instruction">v4fmaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_4fmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_4fmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fmaddps zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by the 4 corresponding packed elements in <span class="desc_var c">c</span>, accumulating with the corresponding elements in <span class="desc_var a">a</span>. Store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst := a
FOR m := 0 to 3
	FOR j := 0 to 15
		i := j*32
		n := m*32
		dst[i+31:i] := RoundFPControl_MXCSR(dst[i+31:i] + b{m}[i+31:i] * c[n+31:n])
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="7"><div class="instruction">v4fmaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_4fmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_4fmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fmaddps zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by the 4 corresponding packed elements in <span class="desc_var c">c</span>, accumulating with the corresponding elements in <span class="desc_var a">a</span>. Store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var a">a</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">dst := a
FOR m := 0 to 3
	FOR j := 0 to 15
		i := j*32
		n := m*32
		IF mask[j]
			dst[i+31:i] := RoundFPControl_MXCSR(dst[i+31:i] + b{m}[i+31:i] * c[n+31:n])
		FI
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="8"><div class="instruction">v4fmaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_4fmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_4fmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fmaddps zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by the 4 corresponding packed elements in <span class="desc_var c">c</span>, accumulating with the corresponding elements in <span class="desc_var a">a</span>. Store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">dst := a
FOR m := 0 to 3
	FOR j := 0 to 15
		i := j*32
		n := m*32
		IF mask[j]
			dst[i+31:i] := RoundFPControl_MXCSR(dst[i+31:i] + b{m}[i+31:i] * c[n+31:n])
		ELSE
			dst[i+31:i] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="9"><div class="instruction">v4fmaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_4fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_4fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fmaddss xmm {k}, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by corresponding element in <span class="desc_var c">c</span>, accumulating  with the lower element in <span class="desc_var a">a</span>. Store the result in the lower element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst := a
FOR j := 0 to 3
	i := j*32
	dst[31:0] := RoundFPControl_MXCSR(dst[31:0] + b{j}[31:0] * c[i+31:i])
ENDFOR
dst[MAX:32] := 0</div></div></div><div class="intrinsic AVX_512" id="10"><div class="instruction">v4fmaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_4fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_4fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fmaddss xmm {k}, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by corresponding element in <span class="desc_var c">c</span>, accumulating  with the lower element in <span class="desc_var a">a</span>. Store the result in the lower element of <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (the element is copied from <span class="desc_var a">a</span> when mask bit 0 is not set).</div><h1>Operation</h1><div class="operation">dst := a
IF k[0]
	FOR j := 0 to 3
		i := j*32
		dst[31:0] := RoundFPControl_MXCSR(dst[31:0] + b{j}[31:0] * c[i+31:i])
	ENDFOR
FI
dst[MAX:32] := 0</div></div></div><div class="intrinsic AVX_512" id="11"><div class="instruction">v4fmaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_4fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_4fmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fmaddss xmm {k}, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by corresponding element in <span class="desc_var c">c</span>, accumulating  with the lower element in <span class="desc_var a">a</span>. Store the result in the lower element of <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (the element is zeroed out when mask bit 0 is not set).</div><h1>Operation</h1><div class="operation">dst := a
IF k[0]
	FOR j := 0 to 3
		i := j*32
		dst[31:0] := RoundFPControl_MXCSR(dst[31:0] + b{j}[31:0] * c[i+31:i])
	ENDFOR
ELSE
	dst[31:0] := 0
FI
dst[MAX:32] := 0</div></div></div><div class="intrinsic AVX_512" id="12"><div class="instruction">v4fnmaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_4fnmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_4fnmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fnmaddps zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by the 4 corresponding packed elements in <span class="desc_var c">c</span>, accumulating the negated intermediate result with the corresponding elements in <span class="desc_var a">a</span>. Store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst := a
FOR m := 0 to 3
	FOR j := 0 to 15
		i := j*32
		n := m*32
		dst[i+31:i] := RoundFPControl_MXCSR(dst[i+31:i] - b{m}[i+31:i] * c[n+31:n])
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="13"><div class="instruction">v4fnmaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_4fnmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_4fnmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fnmaddps zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by the 4 corresponding packed elements in <span class="desc_var c">c</span>, accumulating the negated intermediate result with the corresponding elements in <span class="desc_var a">a</span>. Store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var a">a</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">dst := a
FOR m := 0 to 3
	FOR j := 0 to 15
		i := j*32
		n := m*32
		IF mask[j]
			dst[i+31:i] := RoundFPControl_MXCSR(dst[i+31:i] - b{m}[i+31:i] * c[n+31:n])
		FI
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="14"><div class="instruction">v4fnmaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_4fnmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_4fnmadd_ps</span> (<span class="param_type">_m512</span> <span class="param_name">a</span>, <span class="param_type">_mmask16</span> <span class="param_name">k</span>, <span class="param_type">_m512i</span> <span class="param_name">b0</span>, <span class="param_type">_m512i</span> <span class="param_name">b1</span>, <span class="param_type">_m512i</span> <span class="param_name">b2</span>, <span class="param_type">_m512i</span> <span class="param_name">b3</span>, <span class="param_type">_m128i *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fnmaddps zmm {k}, zmm+3, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply packed single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by the 4 corresponding packed elements in <span class="desc_var c">c</span>, accumulating the negated intermediate result with the corresponding elements in <span class="desc_var a">a</span>. Store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">dst := a
FOR m := 0 to 3
	FOR j := 0 to 15
		i := j*32
		n := m*32
		IF mask[j]
			dst[i+31:i] := RoundFPControl_MXCSR(dst[i+31:i] - b{m}[i+31:i] * c[n+31:n])
		ELSE
			dst[i+31:i] := 0
		FI
	ENDFOR
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="15"><div class="instruction">v4fnmaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_4fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_4fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fnmaddss xmm {k}, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by corresponding element in <span class="desc_var c">c</span>, accumulating  the negated intermediate result with the lower element in <span class="desc_var a">a</span>. Store the result in the lower element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst := a
FOR j := 0 to 3
	i := j*32
	dst[31:0] := RoundFPControl_MXCSR(dst[31:0] - b{j}[31:0] * c[i+31:i])
ENDFOR
dst[MAX:32] := 0</div></div></div><div class="intrinsic AVX_512" id="16"><div class="instruction">v4fnmaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_4fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_4fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fnmaddss xmm {k}, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by corresponding element in <span class="desc_var c">c</span>, accumulating  the negated intermediate result with the lower element in <span class="desc_var a">a</span>. Store the result in the lower element of <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (the element is copied from <span class="desc_var a">a</span> when mask bit 0 is not set).</div><h1>Operation</h1><div class="operation">dst := a
IF k[0]
	FOR j := 0 to 3
		i := j*32
		dst[31:0] := RoundFPControl_MXCSR(dst[31:0] - b{j}[31:0] * c[i+31:i])
	ENDFOR
FI
dst[MAX:32] := 0</div></div></div><div class="intrinsic AVX_512" id="17"><div class="instruction">v4fnmaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_4fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_4fnmadd_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">b0</span>, <span class="param_type">__m128</span> <span class="param_name">b1</span>, <span class="param_type">__m128</span> <span class="param_name">b2</span>, <span class="param_type">__m128</span> <span class="param_name">b3</span>, <span class="param_type">__m128 *</span> <span class="param_name">c</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: v4fnmaddss xmm {k}, xmm, m128<br>CPUID Flags: <span class="cpuid">AVX512_4FMAPS</span></div><h1>Description</h1><div class="description">Multiply the lower single-precision (32-bit) floating-point elements specified in 4 consecutive operands <span class="desc_var b0">b0</span> through <span class="desc_var b3">b3</span> by corresponding element in <span class="desc_var c">c</span>, accumulating  the negated intermediate result with the lower element in <span class="desc_var a">a</span>. Store the result in the lower element of <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (the element is zeroed out when mask bit 0 is not set).</div><h1>Operation</h1><div class="operation">dst := a
IF k[0]
	FOR j := 0 to 3
		i := j*32
		dst[31:0] := RoundFPControl_MXCSR(dst[31:0] - b{j}[31:0] * c[i+31:i])
	ENDFOR
ELSE
	dst[31:0] := 0
FI
dst[MAX:32] := 0</div></div></div><div class="intrinsic SSSE3" id="18"><div class="instruction">pabsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="19"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="20"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi16</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi16</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="21"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="22"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="23"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi16</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi16</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="24"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="25"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="26"><div class="instruction">vpabsw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi16</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi16</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := ABS(a[i+15:i])
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSSE3" id="27"><div class="instruction">pabsd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="28"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="29"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="30"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="31"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="32"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="33"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd zmm {k}, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="34"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd zmm {k}, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="35"><div class="instruction">vpabsd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi32</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi32</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsd zmm {k}, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(a[i+31:i])
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="36"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="37"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="38"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="39"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="40"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="41"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="42"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq zmm {k}, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ABS(a[i+63:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="43"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq zmm {k}, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="44"><div class="instruction">vpabsq</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsq zmm {k}, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 64-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(a[i+63:i])
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSSE3" id="45"><div class="instruction">pabsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_abs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="46"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_abs_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="47"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi8</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_abs_epi8</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="48"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_abs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="49"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_abs_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="50"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi8</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_abs_epi8</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="51"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_abs_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="52"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_abs_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="53"><div class="instruction">vpabsb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi8</span> (<span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_abs_epi8</span> (<span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpabsb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := ABS(a[i+7:i])
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="54"><div class="alsoKNC"></div><div class="instruction">vpandq</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_abs_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">v2</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_abs_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">v2</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpandq zmm {k}, zmm, m512<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Finds the absolute value of each packed double-precision (64-bit) floating-point element in <span class="desc_var v2">v2</span>, storing the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ABS(v2[i+63:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="55"><div class="alsoKNC"></div><div class="instruction">vpandq</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_abs_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">v2</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_abs_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">v2</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpandq zmm {k}, zmm, m512<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Finds the absolute value of each packed double-precision (64-bit) floating-point element in <span class="desc_var v2">v2</span>, storing the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ABS(v2[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSSE3" id="56"><div class="instruction">pabsw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsw mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 16-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := ABS(a[i+15:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="57"><div class="instruction">pabsd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsd mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 32-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := ABS(a[i+31:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSSE3" id="58"><div class="instruction">pabsb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_abs_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>)</span><br>#include &lt;tmmintrin.h&gt;<br>Instruction: pabsb mm, mm<br>CPUID Flags: <span class="cpuid">SSSE3</span></div><h1>Description</h1><div class="description">Compute the absolute value of packed 8-bit integers in <span class="desc_var a">a</span>, and store the unsigned results in <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := ABS(a[i+7:i])
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="59"><div class="alsoKNC"></div><div class="instruction">vpandd</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_abs_ps</span> (<span class="param_type">__m512</span> <span class="param_name">v2</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_abs_ps</span> (<span class="param_type">__m512</span> <span class="param_name">v2</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpandd zmm {k}, zmm, m512<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Finds the absolute value of each packed single-precision (32-bit) floating-point element in <span class="desc_var v2">v2</span>, storing the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ABS(v2[i+31:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="60"><div class="alsoKNC"></div><div class="instruction">vpandd</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_abs_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">v2</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_abs_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">v2</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpandd zmm {k}, zmm, m512<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Finds the absolute value of each packed single-precision (32-bit) floating-point element in <span class="desc_var v2">v2</span>, storing the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ABS(v2[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="61"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_acos_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_acos_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ACOS(a[i+63:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic SVML" id="62"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_acos_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_acos_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ACOS(a[i+63:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SVML" id="63"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_acos_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_acos_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ACOS(a[i+63:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="64"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_acos_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_acos_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ACOS(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="65"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_acos_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_acos_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ACOS(a[i+31:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic SVML" id="66"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_acos_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_acos_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ACOS(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SVML" id="67"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_acos_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_acos_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ACOS(a[i+31:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="68"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_acos_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_acos_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ACOS(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="69"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_acosh_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_acosh_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := ACOSH(a[i+63:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic SVML" id="70"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_acosh_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_acosh_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := ACOSH(a[i+63:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SVML" id="71"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_acosh_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_acosh_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := ACOSH(a[i+63:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="72"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_acosh_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_acosh_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := ACOSH(a[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="73"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_acosh_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_acosh_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := ACOSH(a[i+31:i])
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic SVML" id="74"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_acosh_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_acosh_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := ACOSH(a[i+31:i])
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic SVML" id="75"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_acosh_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_acosh_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := ACOSH(a[i+31:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SVML" id="76"><div class="instruction">...</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_acosh_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_acosh_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>)</span><br>#include &lt;immintrin.h&gt;<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Compute the inverse hyperbolic cosine of packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> expressed in radians, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := ACOSH(a[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="77"><div class="instruction">vpadcd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_adc_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">v2</span>, <span class="param_type">__mmask16</span> <span class="param_name">k2</span>, <span class="param_type">__m512i</span> <span class="param_name">v3</span>, <span class="param_type">__mmask16 *</span> <span class="param_name">k2_res</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_adc_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">v2</span>, <span class="param_type">__mmask16</span> <span class="param_name">k2</span>, <span class="param_type">__m512i</span> <span class="param_name">v3</span>, <span class="param_type">__mmask16 *</span> <span class="param_name">k2_res</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpadcd zmm {k}, k, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element-by-element addition of packed 32-bit integers in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and the corresponding bit in <span class="desc_var k2">k2</span>, storing the result of the addition in <span class="desc_var dst">dst</span> and the result of the carry in <span class="desc_var k2_res">k2_res</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	k2_res[j]   := Carry(v2[i+31:i] + v3[i+31:i] + k2[j])
	dst[i+31:i] := v2[i+31:i] + v3[i+31:i] + k2[j]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="78"><div class="instruction">vpadcd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_adc_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">v2</span>, <span class="param_type">__mmask16</span> <span class="param_name">k1</span>, <span class="param_type">__mmask16</span> <span class="param_name">k2</span>, <span class="param_type">__m512i</span> <span class="param_name">v3</span>, <span class="param_type">__mmask16 *</span> <span class="param_name">k2_res</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_adc_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">v2</span>, <span class="param_type">__mmask16</span> <span class="param_name">k1</span>, <span class="param_type">__mmask16</span> <span class="param_name">k2</span>, <span class="param_type">__m512i</span> <span class="param_name">v3</span>, <span class="param_type">__mmask16 *</span> <span class="param_name">k2_res</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpadcd zmm {k}, k, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element-by-element addition of packed 32-bit integers in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and the corresponding bit in <span class="desc_var k2">k2</span>, storing the result of the addition in <span class="desc_var dst">dst</span> and the result of the carry in <span class="desc_var k2_res">k2_res</span> using writemask <span class="desc_var k1">k1</span> (elements are copied from <span class="desc_var v2">v2</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k1[j]
		k2_res[j]   := Carry(v2[i+31:i] + v3[i+31:i] + k2[j])
		dst[i+31:i] := v2[i+31:i] + v3[i+31:i] + k2[j]
	ELSE
		dst[i+31:i] := v2[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="79"><div class="instruction">paddw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="80"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="81"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi16</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi16</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="82"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="83"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="84"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi16</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi16</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="85"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="86"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="87"><div class="instruction">vpaddw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi16</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi16</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := a[i+15:i] + b[i+15:i]
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="88"><div class="instruction">paddd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="89"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi32</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="90"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="91"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="92"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi32</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="93"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi32</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="94"><div class="alsoKNC"></div><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="95"><div class="alsoKNC"></div><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi32</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="96"><div class="instruction">vpaddd</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi32</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi32</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="97"><div class="instruction">paddq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddq xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="98"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi64</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="99"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="100"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="101"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi64</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="102"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] :=0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="103"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="104"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi64</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="105"><div class="instruction">vpaddq</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi64</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddq zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed 64-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="106"><div class="instruction">paddb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_add_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="107"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_add_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="108"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi8</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_add_epi8</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="109"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_add_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="110"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_add_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="111"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi8</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_add_epi8</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="112"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_add_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="113"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_add_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="114"><div class="instruction">vpaddb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi8</span> (<span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_add_epi8</span> (<span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := a[i+7:i] + b[i+7:i]
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="115"><div class="instruction">addpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: addpd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="116"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_add_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_add_pd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="117"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskz_add_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskz_add_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX" id="118"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_add_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_add_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="119"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mask_add_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_mask_add_pd</span> (<span class="param_type">__m256d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="120"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_maskz_add_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256d</span> <span class="name">_mm256_maskz_add_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256d</span> <span class="param_name">a</span>, <span class="param_type">__m256d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="121"><div class="alsoKNC"></div><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_add_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_add_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="122"><div class="alsoKNC"></div><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_add_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_add_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="123"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_maskz_add_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_maskz_add_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic MMX" id="124"><div class="instruction">paddw</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi16</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddw mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*16
	dst[i+15:i] := a[i+15:i] + b[i+15:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="125"><div class="instruction">paddd</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi32</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddd mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 32-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 1
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div></div></div><div class="intrinsic MMX" id="126"><div class="instruction">paddb</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_pi8</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;mmintrin.h&gt;<br>Instruction: paddb mm, mm<br>CPUID Flags: <span class="cpuid">MMX</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*8
	dst[i+7:i] := a[i+7:i] + b[i+7:i]
ENDFOR</div></div></div><div class="intrinsic SSE" id="127"><div class="instruction">addps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ps</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: addps xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="128"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_add_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_add_ps</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="129"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_add_ps</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_add_ps</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 3
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX" id="130"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_add_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_add_ps</span> (<span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="131"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_mask_add_ps</span> (<span class="param_type">__m256</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_mask_add_ps</span> (<span class="param_type">__m256</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="132"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_maskz_add_ps</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256</span> <span class="name">_mm256_maskz_add_ps</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m256</span> <span class="param_name">a</span>, <span class="param_type">__m256</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps<br>CPUID Flags: <span class="cpuid">AVX512F</span> + <span class="cpuid">AVX512VL</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="133"><div class="alsoKNC"></div><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_add_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_add_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="134"><div class="alsoKNC"></div><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_add_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_add_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="135"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_add_ps</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_add_ps</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="136"><div class="alsoKNC"></div><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_add_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_add_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd zmm {k}, zmm, zmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := a[i+63:i] + b[i+63:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="137"><div class="alsoKNC"></div><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_add_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_add_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd zmm {k}, zmm, zmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). 
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="138"><div class="instruction">vaddpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_maskz_add_round_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_maskz_add_round_pd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">a</span>, <span class="param_type">__m512d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddpd zmm {k}, zmm, zmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed double-precision (64-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := a[i+63:i] + b[i+63:i]
	ELSE
		dst[i+63:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="139"><div class="alsoKNC"></div><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_add_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_add_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps zmm {k}, zmm, zmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := a[i+31:i] + b[i+31:i]
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="140"><div class="alsoKNC"></div><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_add_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_add_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps zmm {k}, zmm, zmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span> for AVX-512, <span class="cpuid">KNCNI</span> for KNC</div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). 
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="141"><div class="instruction">vaddps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_add_round_ps</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_maskz_add_round_ps</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">a</span>, <span class="param_type">__m512</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddps zmm {k}, zmm, zmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add packed single-precision (32-bit) floating-point elements in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := a[i+31:i] + b[i+31:i]
	ELSE
		dst[i+31:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="142"><div class="instruction">vaddsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_round_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_round_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsd xmm {k}, xmm, xmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] + b[63:0]
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="143"><div class="instruction">vaddsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_add_round_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_add_round_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsd xmm {k}, xmm, xmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (the element is copied from <span class="desc_var src">src</span> when mask bit 0 is not set), and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
		<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
		</div><h1>Operation</h1><div class="operation">IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="144"><div class="instruction">vaddsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskz_add_round_sd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskz_add_round_sd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsd xmm {k}, xmm, xmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (the element is zeroed out when mask bit 0 is not set), and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.
		<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
		</div><h1>Operation</h1><div class="operation">IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="145"><div class="instruction">vaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_round_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_round_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddss xmm {k}, xmm, xmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.
		<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
		</div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] + b[31:0]
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="146"><div class="instruction">vaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_add_round_ss</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_add_round_ss</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddss xmm {k}, xmm, xmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (the element is copied from <span class="desc_var src">src</span> when mask bit 0 is not set), and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. 
		<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
		</div><h1>Operation</h1><div class="operation">IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="147"><div class="instruction">vaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_add_round_ss</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_add_round_ss</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddss xmm {k}, xmm, xmm {er}<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div></div></div><div class="intrinsic SSE2" id="148"><div class="instruction">addsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_add_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: addsd xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] + b[63:0]
dst[127:64] := a[127:64]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="149"><div class="instruction">vaddsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_add_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_mask_add_sd</span> (<span class="param_type">__m128d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsd xmm {k}, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (the element is copied from <span class="desc_var src">src</span> when mask bit 0 is not set), and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := src[63:0]
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="150"><div class="instruction">vaddsd</div><div class="signature"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskz_add_sd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128d</span> <span class="name">_mm_maskz_add_sd</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128d</span> <span class="param_name">a</span>, <span class="param_type">__m128d</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddsd xmm {k}, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower double-precision (64-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (the element is zeroed out when mask bit 0 is not set), and copy the upper element from <span class="desc_var a">a</span> to the upper element of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">IF k[0]
	dst[63:0] := a[63:0] + b[63:0]
ELSE
	dst[63:0] := 0
FI
dst[127:64] := a[127:64]
dst[MAX:128] := 0</div></div></div><div class="intrinsic SSE2" id="151"><div class="instruction">paddq</div><div class="signature"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m64</span> <span class="name">_mm_add_si64</span> (<span class="param_type">__m64</span> <span class="param_name">a</span>, <span class="param_type">__m64</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddq mm, mm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add 64-bit integers <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, and store the result in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">dst[63:0] := a[63:0] + b[63:0]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.33</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic SSE" id="152"><div class="instruction">addss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_add_ss</span> (<span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;xmmintrin.h&gt;<br>Instruction: addss xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span>, and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">dst[31:0] := a[31:0] + b[31:0]
dst[127:32] := a[127:32]</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>4</td><td>0.5</td></tr><tr><td>Broadwell</td><td>3</td><td>1</td></tr><tr><td>Haswell</td><td>3</td><td>1</td></tr><tr><td>Ivy Bridge</td><td>3</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="153"><div class="instruction">vaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_add_ss</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_mask_add_ss</span> (<span class="param_type">__m128</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddss xmm {k}, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (the element is copied from <span class="desc_var src">src</span> when mask bit 0 is not set), and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>. </div><h1>Operation</h1><div class="operation">IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := src[31:0]
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="154"><div class="instruction">vaddss</div><div class="signature"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_add_ss</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128</span> <span class="name">_mm_maskz_add_ss</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128</span> <span class="param_name">a</span>, <span class="param_type">__m128</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddss xmm {k}, xmm, xmm<br>CPUID Flags: <span class="cpuid">AVX512F</span></div><h1>Description</h1><div class="description">Add the lower single-precision (32-bit) floating-point element in <span class="desc_var a">a</span> and <span class="desc_var b">b</span>, store the result in the lower element of <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (the element is zeroed out when mask bit 0 is not set), and copy the upper 3 packed elements from <span class="desc_var a">a</span> to the upper elements of <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">IF k[0]
	dst[31:0] := a[31:0] + b[31:0]
ELSE
	dst[31:0] := 0
FI
dst[127:32] := a[127:32]
dst[MAX:128] := 0</div></div></div><div class="intrinsic Other" id="155"><div class="instruction">adc</div><div class="signature"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarry_u32</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned int</span> <span class="param_name">a</span>, <span class="param_type">unsigned int</span> <span class="param_name">b</span>, <span class="param_type">unsigned int *</span> <span class="param_name">out</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarry_u32</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned int</span> <span class="param_name">a</span>, <span class="param_type">unsigned int</span> <span class="param_name">b</span>, <span class="param_type">unsigned int *</span> <span class="param_name">out</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: adc r32, r32<br></div><h1>Description</h1><div class="description">Add unsigned 32-bit integers <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with unsigned 8-bit carry-in <span class="desc_var c_in">c_in</span> (carry flag), and store the unsigned 32-bit result in <span class="desc_var out">out</span>, and the carry-out in <span class="desc_var dst">dst</span> (carry or overflow flag).</div><h1>Operation</h1><div class="operation">out[31:0] := a[31:0] + b[31:0] + c_in
dst := carry_out</div></div></div><div class="intrinsic Other" id="156"><div class="instruction">adc</div><div class="signature"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarry_u64</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">a</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">b</span>, <span class="param_type">unsigned __int64 *</span> <span class="param_name">out</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarry_u64</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">a</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">b</span>, <span class="param_type">unsigned __int64 *</span> <span class="param_name">out</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: adc r64, r64<br></div><h1>Description</h1><div class="description">Add unsigned 64-bit integers <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with unsigned 8-bit carry-in <span class="desc_var c_in">c_in</span> (carry flag), and store the unsigned 64-bit result in <span class="desc_var out">out</span>, and the carry-out in <span class="desc_var dst">dst</span> (carry or overflow flag).</div><h1>Operation</h1><div class="operation">out[63:0] := a[63:0] + b[63:0] + c_in
dst := carry_out</div></div></div><div class="intrinsic Other" id="157"><div class="instruction">adcx, adox</div><div class="signature"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarryx_u32</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned int</span> <span class="param_name">a</span>, <span class="param_type">unsigned int</span> <span class="param_name">b</span>, <span class="param_type">unsigned int *</span> <span class="param_name">out</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarryx_u32</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned int</span> <span class="param_name">a</span>, <span class="param_type">unsigned int</span> <span class="param_name">b</span>, <span class="param_type">unsigned int *</span> <span class="param_name">out</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: adcx r32, r32<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adox r32, r32<br>CPUID Flags: <span class="cpuid">ADX</span></div><h1>Description</h1><div class="description">Add unsigned 32-bit integers <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with unsigned 8-bit carry-in <span class="desc_var c_in">c_in</span> (carry or overflow flag), and store the unsigned 32-bit result in <span class="desc_var out">out</span>, and the carry-out in <span class="desc_var dst">dst</span> (carry or overflow flag).</div><h1>Operation</h1><div class="operation">out[31:0] := a[31:0] + b[31:0] + c_in
dst := carry_out</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic Other" id="158"><div class="instruction">adcx, adox</div><div class="signature"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarryx_u64</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">a</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">b</span>, <span class="param_type">unsigned __int64 *</span> <span class="param_name">out</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">unsigned char</span> <span class="name">_addcarryx_u64</span> (<span class="param_type">unsigned char</span> <span class="param_name">c_in</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">a</span>, <span class="param_type">unsigned __int64</span> <span class="param_name">b</span>, <span class="param_type">unsigned __int64 *</span> <span class="param_name">out</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: adcx r64, r64<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adox r64, r64<br>CPUID Flags: <span class="cpuid">ADX</span></div><h1>Description</h1><div class="description">Add unsigned 64-bit integers <span class="desc_var a">a</span> and <span class="desc_var b">b</span> with unsigned 8-bit carry-in <span class="desc_var c_in">c_in</span> (carry or overflow flag), and store the unsigned 64-bit result in <span class="desc_var out">out</span>, and the carry-out in <span class="desc_var dst">dst</span> (carry or overflow flag).</div><h1>Operation</h1><div class="operation">out[63:0] := a[63:0] + b[63:0] + c_in
dst := carry_out</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>1</td></tr><tr><td>Broadwell</td><td>1</td><td>1</td></tr></tbody></table></div></div><div class="intrinsic KNC" id="159"><div class="instruction">vaddnpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_addn_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_addn_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element-by-element addition between packed double-precision (64-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates their sum, storing the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := -(v2[i+63:i] + v3[i+63:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="160"><div class="instruction">vaddnpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_addn_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_addn_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element-by-element addition between packed double-precision (64-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates their sum, storing the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(v2[i+63:i] + v3[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="161"><div class="instruction">vaddnps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_addn_ps</span> (<span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_addn_ps</span> (<span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element-by-element addition between packed single-precision (32-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates their sum, storing the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := -(v2[i+31:i] + v3[i+31:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="162"><div class="instruction">vaddnps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_addn_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_addn_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element-by-element addition between packed single-precision (32-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates their sum, storing the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(v2[i+31:i] + v3[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="163"><div class="instruction">vaddnpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_addn_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_addn_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element by element addition between packed double-precision (64-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates the sum, storing the result in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	dst[i+63:i] := -(v2[i+63:i] + v3[i+63:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="164"><div class="instruction">vaddnpd</div><div class="signature"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_addn_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512d</span> <span class="name">_mm512_mask_addn_round_pd</span> (<span class="param_type">__m512d</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m512d</span> <span class="param_name">v2</span>, <span class="param_type">__m512d</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnpd zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element by element addition between packed double-precision (64-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates the sum, storing the result in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*64
	IF k[j]
		dst[i+63:i] := -(v2[i+63:i] + v3[i+63:i])
	ELSE
		dst[i+63:i] := src[i+63:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="165"><div class="instruction">vaddnps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_addn_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_addn_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element by element addition between packed single-precision (32-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates the sum, storing the result in <span class="desc_var dst">dst</span>.
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	dst[i+31:i] := -(v2[i+31:i] + v3[i+31:i])
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic KNC" id="166"><div class="instruction">vaddnps</div><div class="signature"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_addn_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512</span> <span class="name">_mm512_mask_addn_round_ps</span> (<span class="param_type">__m512</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m512</span> <span class="param_name">v2</span>, <span class="param_type">__m512</span> <span class="param_name">v3</span>, <span class="param_type">int</span> <span class="param_name">rounding</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vaddnps zmm {k}, zmm, zmm<br>CPUID Flags: <span class="cpuid">KNCNI</span></div><h1>Description</h1><div class="description">Performs element by element addition between packed single-precision (32-bit) floating-point elements in <span class="desc_var v2">v2</span> and <span class="desc_var v3">v3</span> and negates the sum, storing the result in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set).
	<br>Rounding is done according to the <span class="desc_var rounding">rounding</span> parameter, which can be one of:<div class="desc_note">    (_MM_FROUND_TO_NEAREST_INT |_MM_FROUND_NO_EXC) // round to nearest, and suppress exceptions
    (_MM_FROUND_TO_NEG_INF |_MM_FROUND_NO_EXC)     // round down, and suppress exceptions
    (_MM_FROUND_TO_POS_INF |_MM_FROUND_NO_EXC)     // round up, and suppress exceptions
    (_MM_FROUND_TO_ZERO |_MM_FROUND_NO_EXC)        // truncate, and suppress exceptions
    _MM_FROUND_CUR_DIRECTION // use MXCSR.RC; see _MM_SET_ROUNDING_MODE</div>
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*32
	IF k[j]
		dst[i+31:i] := -(v2[i+31:i] + v3[i+31:i])
	ELSE
		dst[i+31:i] := src[i+31:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="167"><div class="instruction">paddsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddsw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="168"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_adds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_adds_epi16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="169"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_adds_epi16</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_adds_epi16</span> (<span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="170"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="171"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_adds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_adds_epi16</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="172"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_adds_epi16</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_adds_epi16</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="173"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_adds_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_adds_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="174"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_adds_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_adds_epi16</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="175"><div class="instruction">vpaddsw</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_adds_epi16</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_adds_epi16</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsw<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_Int16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="176"><div class="instruction">paddsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddsb xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="177"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_adds_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_adds_epi8</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX_512" id="178"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_adds_epi8</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_maskz_adds_epi8</span> (<span class="param_type">__mmask16</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 15
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div><div class="intrinsic AVX2" id="179"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_adds_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb ymm, ymm, ymm<br>CPUID Flags: <span class="cpuid">AVX2</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:256] := 0</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="180"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_adds_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_mask_adds_epi8</span> (<span class="param_type">__m256i</span> <span class="param_name">src</span>, <span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="181"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_adds_epi8</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m256i</span> <span class="name">_mm256_maskz_adds_epi8</span> (<span class="param_type">__mmask32</span> <span class="param_name">k</span>, <span class="param_type">__m256i</span> <span class="param_name">a</span>, <span class="param_type">__m256i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 31
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:256] := 0</div></div></div><div class="intrinsic AVX_512" id="182"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_adds_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_adds_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="183"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_adds_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_mask_adds_epi8</span> (<span class="param_type">__m512i</span> <span class="param_name">src</span>, <span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := src[i+7:i]
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic AVX_512" id="184"><div class="instruction">vpaddsb</div><div class="signature"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_adds_epi8</span> (<span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m512i</span> <span class="name">_mm512_maskz_adds_epi8</span> (<span class="param_type">__mmask64</span> <span class="param_name">k</span>, <span class="param_type">__m512i</span> <span class="param_name">a</span>, <span class="param_type">__m512i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddsb<br>CPUID Flags: <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed 8-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using zeromask <span class="desc_var k">k</span> (elements are zeroed out when the corresponding mask bit is not set).
	</div><h1>Operation</h1><div class="operation">FOR j := 0 to 63
	i := j*8
	IF k[j]
		dst[i+7:i] := Saturate_To_Int8( a[i+7:i] + b[i+7:i] )
	ELSE
		dst[i+7:i] := 0
	FI
ENDFOR
dst[MAX:512] := 0</div></div></div><div class="intrinsic SSE2" id="185"><div class="instruction">paddusw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_adds_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;emmintrin.h&gt;<br>Instruction: paddusw xmm, xmm<br>CPUID Flags: <span class="cpuid">SSE2</span></div><h1>Description</h1><div class="description">Add packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span>.</div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
ENDFOR</div><br><h1>Performance</h1><table class="performance"><tbody><tr><th>Architecture</th><th>Latency</th><th>Throughput (CPI)</th></tr><tr><td>Skylake</td><td>1</td><td>0.5</td></tr><tr><td>Broadwell</td><td>1</td><td>0.5</td></tr><tr><td>Haswell</td><td>1</td><td>0.5</td></tr><tr><td>Ivy Bridge</td><td>1</td><td>0.5</td></tr></tbody></table></div></div><div class="intrinsic AVX_512" id="186"><div class="instruction">vpaddusw</div><div class="signature"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_adds_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span></div><div class="details"><h1>Synopsis</h1><div class="synopsis"><span class="sig"><span class="rettype">__m128i</span> <span class="name">_mm_mask_adds_epu16</span> (<span class="param_type">__m128i</span> <span class="param_name">src</span>, <span class="param_type">__mmask8</span> <span class="param_name">k</span>, <span class="param_type">__m128i</span> <span class="param_name">a</span>, <span class="param_type">__m128i</span> <span class="param_name">b</span>)</span><br>#include &lt;immintrin.h&gt;<br>Instruction: vpaddusw<br>CPUID Flags: <span class="cpuid">AVX512VL</span> + <span class="cpuid">AVX512BW</span></div><h1>Description</h1><div class="description">Add packed unsigned 16-bit integers in <span class="desc_var a">a</span> and <span class="desc_var b">b</span> using saturation, and store the results in <span class="desc_var dst">dst</span> using writemask <span class="desc_var k">k</span> (elements are copied from <span class="desc_var src">src</span> when the corresponding mask bit is not set). </div><h1>Operation</h1><div class="operation">FOR j := 0 to 7
	i := j*16
	IF k[j]
		dst[i+15:i] := Saturate_To_UnsignedInt16( a[i+15:i] + b[i+15:i] )
	ELSE
		dst[i+15:i] := src[i+15:i]
	FI
ENDFOR
dst[MAX:128] := 0</div></div></div></div>
				
			</div>
			
			<div style="clear:both;"></div>
		</div>
		
		<!-- popbox's -->
		<div class="popbox info" style="width:250px;">Data Version: 3.4.4 - <a href="https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/ReleaseNotes.html" target="_blank">Release Notes</a><br>Data Updated: 04/17/2019<br><br>
			Questions? Issues? <a href="http://software.intel.com/en-us/forums/topic/363747" target="_blank" style="color:rgb(8,114,197);">Go Here.</a>
		</div>
		<div class="popbox sequence" style="width:250px;">
			This intrinsic generates a sequence of instructions, which may 
perform worse than a native instruction. Consider the performance impact
 of this intrinsic.
		</div>
	
	
	<script type="text/javascript" src="intrinsics_files/intrinsicsguide.js"></script>
	
    <script type="text/javascript" src="intrinsics_files/perf.json"></script>

</body></html>