<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="https://bits.houmus.org/feed.xml" rel="self" type="application/atom+xml" /><link href="https://bits.houmus.org/" rel="alternate" type="text/html" /><updated>2020-11-23T05:07:29+00:00</updated><id>https://bits.houmus.org/feed.xml</id><title type="html">damageboy</title><subtitle>damageboy's place to vent over those mean computers</subtitle><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><entry><title type="html">This Goes to Eleven (Pt. 5/∞)</title><link href="https://bits.houmus.org/2020-02-02/this-goes-to-eleven-pt5" rel="alternate" type="text/html" title="This Goes to Eleven (Pt. 5/∞)" /><published>2020-02-02T02:22:28+00:00</published><updated>2020-02-02T02:22:28+00:00</updated><id>https://bits.houmus.org/2020-02-02/this-goes-to-eleven-pt5</id><content type="html" xml:base="https://bits.houmus.org/2020-02-02/this-goes-to-eleven-pt5">&lt;p&gt;I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics, and there’s no reason I should go down alone.&lt;/p&gt;

&lt;p&gt;Since there’s a lot to go over here, I’ll split it up into a few parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-28/this-goes-to-eleven-pt1&quot;&gt;part 1&lt;/a&gt;, we start with a refresher on &lt;code class=&quot;highlighter-rouge&quot;&gt;QuickSort&lt;/code&gt; and how it compares to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-29/this-goes-to-eleven-pt2&quot;&gt;part 2&lt;/a&gt;, we go over the basics of vectorized hardware intrinsics, vector types, and go over a handful of vectorized instructions we’ll use in part 3. We still won’t be sorting anything.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-30/this-goes-to-eleven-pt3&quot;&gt;part 3&lt;/a&gt;, we go through the initial code for the vectorized sorting, and start seeing some payoff. We finish agonizing courtesy of the CPU’s branch predictor, throwing a wrench into our attempts.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-02-01/this-goes-to-eleven-pt4&quot;&gt;part 4&lt;/a&gt;, we go over a handful of optimization approaches that I attempted trying to get the vectorized partition to run faster, seeing what worked and what didn’t.&lt;/li&gt;
  &lt;li&gt;In this part, we’ll take a deep dive into how to deal with memory alignment issues.&lt;/li&gt;
  &lt;li&gt;In part 6, we’ll take a pause from the vectorized partitioning, to get rid of almost 100% of the remaining scalar code, by implementing small, constant size array sorting with yet more AVX2 vectorization.&lt;/li&gt;
  &lt;li&gt;In part 7, We’ll circle back and try to deal with a nasty slowdown left in our vectorized partitioning code&lt;/li&gt;
  &lt;li&gt;In part 8, I’ll tell you the sad story of a very twisted optimization I managed to pull off while failing miserably at the same time.&lt;/li&gt;
  &lt;li&gt;In part 9, I’ll try some algorithmic improvements to milk those last drops of perf, or at least those that I can think of, from this code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;trying-to-squeeze-some-more-vectorized-juice&quot;&gt;(Trying) to squeeze some more vectorized juice&lt;/h2&gt;

&lt;p&gt;I thought it would be nice to show a bunch of things I ended up trying to improve performance.
I tried to keep most of these experiments in separate implementations, both the ones that yielded positive results and the failures. These can be seen in the original repo under the &lt;a href=&quot;https://github.com/damageboy/VxSort/tree/research/VxSortResearch/Unstable/AVX2/Happy&quot;&gt;Happy&lt;/a&gt; and &lt;a href=&quot;https://github.com/damageboy/VxSort/tree/research/VxSortResearch/Unstable/AVX2/Sad&quot;&gt;Sad&lt;/a&gt; folders.&lt;/p&gt;

&lt;p&gt;While some worked, and some didn’t, I think a bunch of these were worth mentioning, so here goes:&lt;/p&gt;

&lt;h3 id=&quot;aligning-our-expectations&quot;&gt;Aligning our expectations&lt;/h3&gt;

&lt;center&gt;
&lt;object style=&quot;margin: auto; width: 90%&quot; type=&quot;image/svg+xml&quot; data=&quot;../assets/images/computer-architecture-caches-are-evil-quote.svg&quot;&gt;&lt;/object&gt;
&lt;/center&gt;

&lt;p&gt;This quote, taken from Hennessy and Patterson’s &lt;a href=&quot;https://www.elsevier.com/books/computer-architecture/hennessy/978-0-12-811905-1&quot;&gt;“Computer Architecture: A Quantitative Approach, 6th Edition”&lt;/a&gt;, which is traced to all the way back to the fathers of modern-day computing in 1946 can be taken as a foreboding warning for the pains that are related to anything that deals with the complexity of memory hierarchies.&lt;/p&gt;

&lt;p&gt;With modern computer hardware, CPUs &lt;em&gt;might&lt;/em&gt; access memory more efficiently when it is naturally aligned: in other words, when the &lt;em&gt;address&lt;/em&gt; we use is a multiple of some magical constant. The constant is classically the machine word size, 4/8 bytes on 32/64 bit machines. These constants are related to how the CPU is physically wired and constructed internally. Historically, older processors used to be very limited, either disallowing or severely limiting performance, with non-aligned memory access. To this day, very simple micro-controllers (like the ones you might find in IoT devices, for example) will exhibit such limitations around memory alignment, essentially forcing memory access to conform to multiples of 4/8 bytes. With more modern (read: more expensive) CPUs, these requirements have become increasingly relaxed. Most programmers can simply afford to &lt;em&gt;ignore&lt;/em&gt; this issue. The last decade or so worth of modern processors are oblivious to this problem per-se, as long as we access memory within a &lt;strong&gt;single cache-line&lt;/strong&gt;, or 64-bytes on almost any modern-day processors.&lt;/p&gt;

&lt;p&gt;What is this cache-line? I’m actively fighting my internal inclination, so I &lt;strong&gt;won’t  turn&lt;/strong&gt; this post into a detour about computer micro-architecture. Caches have been covered elsewhere ad-nauseam by far more talented writers, that I’ll never do it justice anyway. Instead, I’ll just do the obligatory one-paragraph reminder where we recall that CPUs don’t directly communicate with RAM, as it is dead slow; instead, they read and write from internal, on-die, special/fast memory called caches. Caches contain partial copies of RAM. Caches are faster, smaller, and organized in multiple levels (L1/L2/L3 caches, to name them), where each level is usually larger in size and slightly slower in terms of latency. When the CPU is instructed to access memory, it instead communicates with the cache units, but it never does so in small units. Even when our code is reading a &lt;em&gt;single byte&lt;/em&gt;, the CPU will communicate with it’s cache subsystem in a unit-of-work known as a cache-line. In theory, every CPU model may have its own definition of a cache-line, but in practice, the last 15 years of processors seem to have converged on 64-bytes as that golden number.&lt;/p&gt;

&lt;p&gt;Now, what happens when, lets say, our read operations end up &lt;strong&gt;crossing&lt;/strong&gt; cache-lines?&lt;/p&gt;

&lt;center&gt;
&lt;object style=&quot;margin: auto; width: 90%&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/cacheline-boundaries.svg&quot;&gt;&lt;/object&gt;
&lt;/center&gt;

&lt;p&gt;As mentioned, the unit-of-work, as far as the CPU is concerned, is a 64-byte cache-line. Therefore, such reads literally cause the CPU to issue &lt;em&gt;two&lt;/em&gt; read operations downstream, ultimately directed at the cache units&lt;sup id=&quot;fnref:0&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:0&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. These cache-line crossing reads &lt;em&gt;do&lt;/em&gt; have a sustained effect on perfromance&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;. But how often do they occur? Let’s consider this by way of example:&lt;br /&gt;
Imagine we are processing a single array sequentially, reading 32-bit integers at a time, or 4-bytes; if for some reason, our starting address is &lt;em&gt;not&lt;/em&gt; divisible by 4, cross cache-line reads would occur at a rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;4/64&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;6.25%&lt;/code&gt; of reads. Even this paltry rate of cross cache-line reads usually remains in the &lt;em&gt;realm of theory&lt;/em&gt; since we have the memory allocator and compiler working in tandem, behind the scenes, to make this go away:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The default allocator &lt;em&gt;always&lt;/em&gt; returns memory aligned at least to machine word size on the one hand.&lt;/li&gt;
  &lt;li&gt;The compiler/JIT use padding bytes within our classes/structs in-between members, as needed, to ensure that individual members are aligned to 4/8 bytes.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So far, I’ve told you why/when you &lt;em&gt;shouldn’t&lt;/em&gt; care about alignment. This was my way of both easing you into the topic and helping you feel OK if this is news to you. You really can afford &lt;em&gt;not to think&lt;/em&gt; about this without paying any penalty, for the most part. Unfortunately, this &lt;strong&gt;stops&lt;/strong&gt; being true for &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; sized reads, which are 32 bytes wide (256 bits / 8). And this is &lt;em&gt;doubly not true&lt;/em&gt; for our partitioning problem:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The memory handed to us for partitioning/sorting is rarely aligned to 32-bytes, except for dumb luck.&lt;br /&gt;
The allocator, allocating an array of 32-bit integers, simply doesn’t care about 32-&lt;strong&gt;byte&lt;/strong&gt; alignment.&lt;/li&gt;
  &lt;li&gt;Even if it were magically aligned to 32-bytes, it would do us little good; Once a &lt;em&gt;single&lt;/em&gt; partition operation is complete, further sub-divisions, inherent with QuickSort, are determined by the (random) new placement of the last pivot we used.&lt;br /&gt;
There is no way we will get lucky enough that &lt;em&gt;every partition&lt;/em&gt; will be 32-byte aligned.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that it is clear that we won’t be 32-byte aligned, we finally realize that as we go over the array sequentially (left to right and right to left as we do) issuing &lt;strong&gt;unaligned&lt;/strong&gt; 32-byte reads on top of a 64-byte cache-line, we end up reading across cache-lines every &lt;strong&gt;other&lt;/strong&gt; read! Or at a rate of 50%! This just escalated from being “…generally not a problem” into a “Houston, we have a problem” very quickly.&lt;/p&gt;

&lt;p&gt;You’ve endured through a lot of hand waving so far, let’s try to see if we can get some damning evidence for all of this, by launching &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt;, this time tracking the oddly specific &lt;code class=&quot;highlighter-rouge&quot;&gt;mem_inst_retired.split_loads&lt;/code&gt; HW counter:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ COMPlus_PerfMapEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 perf record &lt;span class=&quot;nt&quot;&gt;-Fmax&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; mem_inst_retired.split_loads &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    ./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpJedi &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 100000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;--max-loops&lt;/span&gt; 1000 &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-20&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# To display the perf.data header info, please use --header/--header-only options.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Event count (approx.): 87102613&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Overhead  Symbol&lt;/span&gt;
    86.68%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...DoublePumpJedi::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     5.74%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...DoublePumpJedi::Sort&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
     2.99%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] __memmove_avx_unaligned_erms
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We ran the same sort operation &lt;code class=&quot;highlighter-rouge&quot;&gt;1,000&lt;/code&gt; times and got &lt;code class=&quot;highlighter-rouge&quot;&gt;87,102,613&lt;/code&gt; split-loads, with &lt;code class=&quot;highlighter-rouge&quot;&gt;86.68%&lt;/code&gt; attributed to our partitioning function. This means &lt;code class=&quot;highlighter-rouge&quot;&gt;(87102613 * 0.8668) / 1000&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;75,500&lt;/code&gt; split-loads &lt;em&gt;per sort&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;100,000&lt;/code&gt; elements. To seal the deal, we need to figure out how many vector loads per sort we are performing in the first place; Luckily I can generate an answer quickly: I have statistics collection code embedded in my code, so I can issue this command:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpJedi &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 100000 &lt;span class=&quot;nt&quot;&gt;--max-loops&lt;/span&gt; 10000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
      &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--stats-file&lt;/span&gt; jedi-100k-stats.json
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And in return I get this beutiful thing back:&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;&lt;div&gt;
        &lt;p&gt;These numbers are vastly different than the ones we last saw in the end of the 3&lt;sup&gt;rd&lt;/sup&gt; post, for example. There is a good reason for this: We’ve spent the previous post tweaking the code in a few considerable ways:&lt;/p&gt;
        &lt;ul&gt;
          &lt;li&gt;Changing the cut-off point for vectorized sorting from 16 ⮞ 40, there-by reducing the amount of vectorized partitions we’re performing in the first place.&lt;/li&gt;
          &lt;li&gt;Changing the permutation entry loading code to read 8-byte values from memroy, rather than full 32-byte &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; entries,
cutting the number of &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; loads by half.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;div&gt;
&lt;!-- &lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt; --&gt;

&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/jedi-stats.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-intro=&quot;Each row in this table contains statistics collected &amp;amp; averaged out of thousands of runs with random data&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;MethodName&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;Method&lt;br /&gt;Name&lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;ProblemSize&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;div data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
            &lt;div class=&quot;rotated-header&quot;&gt;Size&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;MaxDepthScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;The maximal depth of recursion reached while sorting&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Max&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Depth&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumPartitionOperationsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of partitioning operations per sort&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Part&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;itions&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumVectorizedLoadsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of vectorized load operations&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Vector&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Loads&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumVectorizedStoresScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of vectorized store operations&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Vector&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Stores&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumPermutationsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of vectorized permutation operations&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Vector&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Permutes&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;AverageSmallSortSizeScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;For hybrid sorting, the average size that each small sort operation was called with (e.g. InsertionSort)&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Small&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Sort&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Size&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumScalarComparesScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;How many branches were executed in each sort operation that were based on the unsorted array elements&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Data&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Based&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Branches&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;PercentSmallSortCompares&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-percentage&quot;&gt;
            &lt;div data-intro=&quot;What percent of&amp;lt;/br&amp;gt;⬅&amp;lt;br/&amp;gt;branches happenned as part of small-sorts&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Small&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Sort&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Branches&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;p&gt;In total, we perform &lt;code class=&quot;highlighter-rouge&quot;&gt;173,597&lt;/code&gt; vector loads per sort operation of &lt;code class=&quot;highlighter-rouge&quot;&gt;100,000&lt;/code&gt; elements in &lt;code class=&quot;highlighter-rouge&quot;&gt;4,194&lt;/code&gt; partitioning calls. Assuming our array is aligned to 4-bytes to begin with (which C#’s allocator does very reliably), every partitioning call has a &lt;code class=&quot;highlighter-rouge&quot;&gt;4/32&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;12.5%&lt;/code&gt; of ending up being 32-byte aligned: In other words &lt;code class=&quot;highlighter-rouge&quot;&gt;21,700&lt;/code&gt; of the total vector reads should be aligned by sheer chance, which leaves &lt;code class=&quot;highlighter-rouge&quot;&gt;173597-21700&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;151,898&lt;/code&gt; that should be &lt;em&gt;unaligned&lt;/em&gt;, of which, I claim that that ½ would cause split-loads: &lt;code class=&quot;highlighter-rouge&quot;&gt;50%&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;151,898&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;75,949&lt;/code&gt; while we measured &lt;code class=&quot;highlighter-rouge&quot;&gt;75,500&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt;! I don’t know how your normal day goes about, but in mine, reality and my hallucinations rarely go hand-in-hand like this.&lt;/p&gt;

&lt;p&gt;Fine, we now &lt;strong&gt;know&lt;/strong&gt; we have a problem. The first step was acknowledging/accepting reality: Our code does indeed generate a lot of split memory operations. Let’s consider our memory access patterns when reading/writing with respect to alignment, and see if we can do something about it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For writing, we’re all over the place: we always advance the write pointers according to how the data was partitioned, e.g. it is completely data-dependent, and there is little we can say about our write addresses. In addition, as it happens, Intel CPUs, as almost all other modern CPUs, employ another common trick in the form of &lt;a href=&quot;https://en.wikipedia.org/wiki/Write_combining&quot;&gt;store buffers, or write-combining buffers (WCBs)&lt;/a&gt;. I’ll refrain from describing them here, but the bottom line is we both can’t/don’t need to care about the writing side of our algorithm.&lt;/li&gt;
  &lt;li&gt;For reading, the situation is entirely different: We &lt;em&gt;always&lt;/em&gt; advance the read pointers by 8 elements (32-bytes) on the one hand, and we even have a special intrinsic: &lt;code class=&quot;highlighter-rouge&quot;&gt;Avx.LoadAlignedVector256() / VMOVDQA&lt;/code&gt;&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; that helps us ensure that our reading is properly aligned to 32-bytes.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;aligning-to-cpu-cache-lines-1&quot;&gt;Aligning to CPU Cache-lines: :+1:&lt;/h4&gt;

&lt;p&gt;With this lengthy introduction out of the way, it’s time we do something about these cross-cache line reads. Initially, I got “something” working quickly: remember that we needed to deal with the &lt;em&gt;remainder&lt;/em&gt; of the array, when we had less than 8-elements, anyway. In the original code at the end of the 3&lt;sup&gt;rd&lt;/sup&gt; post, we did so right after our vectorized loop. If we move that scalar code from the end of the function to its beginning while also modifying it to perform scalar partitioning until both &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt; pointers are aligned to 32 bytes, our work is complete. There is a slight wrinkle in this otherwise simple approach:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Previously, we had anywhere between &lt;code class=&quot;highlighter-rouge&quot;&gt;0-7&lt;/code&gt; elements left as a remainder for scalar partitioning per partition call.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;3.5&lt;/code&gt; elements on average.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Aligning from the edges of our partition with scalar code means we will now have &lt;code class=&quot;highlighter-rouge&quot;&gt;0-7&lt;/code&gt; elements per-side…
    &lt;ul&gt;
      &lt;li&gt;So &lt;code class=&quot;highlighter-rouge&quot;&gt;3.5 x 2 == 7&lt;/code&gt; elements on average.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In other words, doing this sort of inwards pre-alignment optimization is not a clean win: We end up with more scalar work than before on the one hand (which is unfortunate), but on the other hand, we can change the vector loading code to use &lt;code class=&quot;highlighter-rouge&quot;&gt;Avx.LoadAlignedVector256()&lt;/code&gt; and &lt;em&gt;know for sure&lt;/em&gt; that we will no longer be causing the CPU to issue a single cross cache-line read (The latter being the performance boost).&lt;br /&gt;
It’s understandable if while reading this, your gut reaction is thinking that adding 3.5 scalar operations doesn’t sound like much of a trade-off, but we have to consider that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each scalar comparison comes with a likely branch misprediction, as discussed before, so it has a higher cost than what you might be initially pricing in.&lt;/li&gt;
  &lt;li&gt;More importantly: we can’t forget that this is a recursive function, with ever &lt;em&gt;decreasing&lt;/em&gt; partition sizes. If you go back to the initial stats we collected in previous posts, you’ll be quickly reminded that we partition upwards of 340k times for 1 million element arrays, so this scalar work both piles up, and represents a larger portion of our workload as the partition sizes decrease…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I won’t bother showing the entire code listing for &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/AVX2/Happy/B5_1_DoublePumpAligned.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B5_1_DoublePumpAligned.cs&lt;/code&gt;&lt;/a&gt;, but I will show the rewritten scalar partition block, which is now tasked with aligning our pointers before we go full vectorized partitioning. Originally it was right after the double-pumped loop and looked like this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;*--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The aligned variant, with the alignment code now at the top of the function, looks like this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextAlign&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextAlign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;*--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextAlign&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextAlign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;*--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ALIGN_MASK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What it does now is check when alignment is necessary, then proceeds to align while also partitioning each side into the temporary memory.&lt;/p&gt;

&lt;p&gt;Where do we end up performance-wise with this optimization?&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#50d405d8-6a9a-4b68-9b7f-20445b335308'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;50d405d8-6a9a-4b68-9b7f-20445b335308&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Jedi,         1   , 1   , 1  , 1   , 1    , 1
Aligned, 1.082653616,    1.091733385,    0.958578753,    0.959159569,    0.964604818,    0.980102965
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3}
  }  
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Aligned Sorting - Scaled to Jedi&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.90, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Jedi, 18.3938  ,20.7342  ,24.6347  ,26.9067  ,23.9922  ,25.5122
Aligned, 19.9128, 22.6363, 23.6143, 25.8078, 23.143, 25.0046
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Jedi Sorting + Aligned - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 28,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt5_1_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;The whole attempt ends up as a mediocre improvement, so it would seem:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;We’re are seeing a speedup/improvement, in the high counts.&lt;/li&gt;
    &lt;li&gt;We seem to be slowing down due to the higher scalar operation count, in the low problem sizes.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;It’s kind of a mixed bag, and perhaps slightly unimpressive at first glance. However, when we stop to remember that we somehow managed both to speed up the function while doubling the amount of scalar work done, the interpretation of the results becomes more nuanced: The pure benefit from alignment itself is larger than what the results are showing right now since it’s being masked, to some extent, by the extra scalar work we tacked on. If only there was a way we could skip that scalar work all together… If only there was a way… If only…&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;re-partitioning-overlapping-regions-1-1&quot;&gt;(Re-)Partitioning overlapping regions: :+1: :+1:&lt;/h3&gt;

&lt;p&gt;Next up is a different optimization approach to the same problem, and a natural progression from the last one. At the risk of sounding pompous, I think I &lt;em&gt;might&lt;/em&gt; have found something here that no-one has done before in the context of partitioning&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;: The basic idea here is we get rid of all (ok, ok, &lt;em&gt;almost all&lt;/em&gt;) scalar partitioning in our vectorized code path. If we can partition and align the edges of the segment we are about to process with vectorized code, we would be reducing the total number instructions executed. At the same time, we would be retaining more of the speed-up that was lost with the alignment optimization above. This would have a double-whammy compounded effect. But how?&lt;/p&gt;

&lt;object style=&quot;margin: auto&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/overlap-partition-with-hint.svg&quot;&gt;&lt;/object&gt;

&lt;p&gt;We could go about it the other way around! Instead of aligning &lt;em&gt;inwards&lt;/em&gt; in each respective direction, we could align &lt;strong&gt;&lt;em&gt;outwards&lt;/em&gt;&lt;/strong&gt; and enlarge the partitioned segment to include a few more (up to 7) elements on the outer rims of each partition and &lt;u&gt;re-partition&lt;/u&gt; them using the new pivot we’ve just selected. If this works, we end up doing both 100% aligned reads and eliminating all scalar work in one optimization! This might &lt;em&gt;sound simple&lt;/em&gt; and &lt;strong&gt;safe&lt;/strong&gt;, but this is the sort of humbling experience that QuickSort is quick at dispensing (sorry, I had to…) at people trying to nudge it in the wrong way. At some point, I was finally able to screw my own head on properly with respect to this re-partitioning attempt and figure out what precisely are the critical constraints we must respect for this to work.&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;&lt;div&gt;
        &lt;p&gt;This is a slightly awkward optimization when you consider that I’m suggesting we should &lt;strong&gt;partition more data&lt;/strong&gt; in order to &lt;em&gt;speed up&lt;/em&gt; our code. This sounds bonkers, unless we dig deep within for some mechanical empathy: not all work is equal in the eyes of the CPU. When we are executing scalar partitioning on &lt;em&gt;n&lt;/em&gt; elements, we are really telling the CPU to execute &lt;em&gt;n&lt;/em&gt; branches, comparisons, and memory accesses, which are completely data-dependent. The CPU “hates” this sort of work. It has to guess what happens next, and will do so no better than flipping a coin, or 50%, for truly random data. What’s worse, as mentioned before, whenever the CPU mispredicts, there’s a price to pay in the form of a full pipeline flush which roughly costs us 14-15 cycles on a modern CPU. Paying this &lt;strong&gt;once&lt;/strong&gt;, is roughly equivalent to partitioning 2 x 8 element vectors with our vectorized partition block! This is the reason that doing “more” might be faster.&lt;/p&gt;
      &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Back to the constraints. There’s one thing we can &lt;strong&gt;never&lt;/strong&gt; do: move a pivot that was previously partitioned. I (now) call them “buried pivots” (since they’re in their final resting place, get it?); Everyone knows, you don’t move around dead bodies, that’s always the first bad thing that happens in a horror movie. There’s our motivation: not being the stupid person who dies first. That’s about it. It sounds simple, but it requires some more serious explanation: When a previous partition operation is complete, the pivot used during that operation is moved to its final resting place. It’s new position is used to subdivide the array, and effectively stored throughout numerous call stacks of our recursive function. There’s a baked-in assumption here that all data left/right of that buried pivot is smaller/larger than it. And that assumption must &lt;strong&gt;never&lt;/strong&gt; be broken. If we intend to &lt;strong&gt;re-partition&lt;/strong&gt; data to the left and right of a given partition, as part of this overlapping alignment effort, we need to consider that this extra data might already contain buried pivots, and we can not, under any circumstances ever move them again.&lt;br /&gt;
In short: Buried pivots stay buried where we left them, or bad things happen.&lt;/p&gt;

&lt;p&gt;When we call our partitioning operation, we have to consider what initially looks like an asymmetry of the left and right edges of our to-be-partitioned segment:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For the left side:
    &lt;ul&gt;
      &lt;li&gt;There might not be additional room on the left with extra data to read from.
        &lt;ul&gt;
          &lt;li&gt;We are too close to the edge of the array on the left side!&lt;br /&gt;
This happens for all partitions starting at the left-edge of the entire array.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;We always partition first left, then right of any buried pivot, we know for a fact that all elements left of “our” partition at any given moment are sorted. e.g. they are all buried pivots, and we can’t re-order them.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Important:&lt;/em&gt; We also know that each of those values is smaller than or equal to whatever pivot value we &lt;em&gt;will select&lt;/em&gt; for the current partitioning operation.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;For the right side, it is almost the same set of constraints:
    &lt;ul&gt;
      &lt;li&gt;There might not be additional room on the right with extra data to read from.
        &lt;ul&gt;
          &lt;li&gt;We are too close to the edge of the array on the right side!&lt;br /&gt;
This happens for all partitions ending on the right-edge of the entire array.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;The immediate value to our right side is a buried pivot, and all other values to its right are larger-than-or-equal to it.&lt;/li&gt;
      &lt;li&gt;There might be additional pivots immediately to our right as well.&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Important:&lt;/em&gt; We also know that each of those values is larger-then-or-equal to whatever pivot value we &lt;em&gt;will select&lt;/em&gt; for the current partitioning operation.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All this information is hard to integrate at first, but what it boils down to is that whenever we load up the left overlapping vector, there are anywhere between 1-7 elements we are &lt;strong&gt;not&lt;/strong&gt; allowed to reorder on the &lt;em&gt;left side&lt;/em&gt;, and when we load the right overlapping vector, there are, again, anywhere between 1-7 elements we are &lt;strong&gt;not&lt;/strong&gt; allowed to re-order on &lt;em&gt;that right side&lt;/em&gt;. That’s the challenge; the good news is that all those overlapping elements are also guaranteed to also be smaller/larger than whatever pivot we end up selecting from out original (sans overlap) partition. This knowledge gives us the edge we need: We know in advance that the extra elements will generate predictable comparison results compared to &lt;em&gt;any&lt;/em&gt; pivot &lt;em&gt;within&lt;/em&gt; our partition.&lt;/p&gt;

&lt;p&gt;What we need are permutation entries that are &lt;strong&gt;&lt;em&gt;stable&lt;/em&gt;&lt;/strong&gt;. I’m coining this phrase freely as I’m going along:&lt;br /&gt;
Stable partitioning means that the partitioning operation &lt;strong&gt;must not&lt;/strong&gt; &lt;em&gt;reorder&lt;/em&gt; values that need to go on the left amongst themselves (we keep their internal ordering amongst themselves). Likewise, it &lt;strong&gt;must not&lt;/strong&gt; reorder the values that go on the right amongst themselves. If we manage to do this, we’re in the clear: The combination of stable permutation and predictable comparison results means that the overlapping elements will stay put while other elements will be partitioned properly on both edges of our overlapping partition. After this weird permutation, we just need to forget we ever read those extra elements, and the whole thing just… works? … yes!&lt;/p&gt;

&lt;p&gt;Let’s start with cementing this idea of what stable partitioning is: Up to this point, there was no such requirement, and the initial partition tables I generated failed to satisfy this requirement.
Here’s a simple example for stable/unstable permutation entries, let’s imagine we partition the following values around a pivot value of 500:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Bit&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;th&gt;3&lt;/th&gt;
      &lt;th&gt;4&lt;/th&gt;
      &lt;th&gt;5&lt;/th&gt;
      &lt;th&gt;6&lt;/th&gt;
      &lt;th&gt;7&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; Value&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;666&lt;/td&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;102&lt;/td&gt;
      &lt;td&gt;777&lt;/td&gt;
      &lt;td&gt;888&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Mask&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unstable Permutation&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Unstable Result&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;102&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;999&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;888&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;777&lt;/strong&gt;&lt;/td&gt;
      &lt;td&gt;&lt;strong&gt;666&lt;/strong&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stable Permutation&lt;/td&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;2&lt;/td&gt;
      &lt;td&gt;3&lt;/td&gt;
      &lt;td&gt;5&lt;/td&gt;
      &lt;td&gt;6&lt;/td&gt;
      &lt;td&gt;7&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Stable Result&lt;/td&gt;
      &lt;td&gt;99&lt;/td&gt;
      &lt;td&gt;100&lt;/td&gt;
      &lt;td&gt;101&lt;/td&gt;
      &lt;td&gt;102&lt;/td&gt;
      &lt;td&gt;666&lt;/td&gt;
      &lt;td&gt;777&lt;/td&gt;
      &lt;td&gt;888&lt;/td&gt;
      &lt;td&gt;999&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In the above example, the unstable permutation is a perfectly &lt;em&gt;&lt;u&gt;valid&lt;/u&gt;&lt;/em&gt; permutation for general case partitioning. It successfully partitions the sample vector around the pivot value of 500, but the 4 elements marked in bold are re-ordered with respect to each other when compared to the original array. In the stable permutation entry, the internal ordering amongst the partitioned groups is &lt;em&gt;preserved&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Armed with new, stable permutation entries, We can proceed with this overlapping re-partitioning hack: The idea is to find the optimal alignment point on the left and on the right (assuming one is available, e.g. there is enough room on that side), read that data with the &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadVectorAligned256&lt;/code&gt; intrinsic, and partition it into the temporary area. The final twist: We need to keep tabs on how many elements &lt;em&gt;do not belong&lt;/em&gt; to this partition (e.g. originate from our overlap gymnastics), and remember not to copy them back into our partition at the end of the function, relying on our stable partitioning to keep them grouped at the edges of the temporary buffer we’re copying from… To my amazement, that was kind of it. It just works! (I’ve conveniently ignored a small edge-case here in words, but not in the code :).&lt;/p&gt;

&lt;p&gt;The end result is super delicate. If you feel you’ve got it, skip this paragraph, but if you need an alternative view on how this works, here it is: I’ve just described how to partition the initial 2x8 elements (8 on each side); out of those initial 8, We &lt;em&gt;always&lt;/em&gt; have a subset that must &lt;strong&gt;never&lt;/strong&gt; be reordered (the overlap), and a subset we need to re-order, as is normal, with respect to some pivot. We know that whatever &lt;em&gt;possible&lt;/em&gt; pivot value &lt;em&gt;might&lt;/em&gt; be selected from our internal partition, it will always be larger/smaller than the elements in the overlapping areas. Knowing that, we can rely on having stable permutation entries that &lt;strong&gt;do not&lt;/strong&gt; reorder those extra elements. In the end, we read extra elements, feed them through our partitioning machine, but ignore the extra overlapping elements and avoid &lt;em&gt;all&lt;/em&gt; scalar partitioning thanks to this scheme.&lt;/p&gt;

&lt;p&gt;In the end, we literally get to eat our cake and keep it whole: For the 99% case we &lt;strong&gt;kill&lt;/strong&gt; scalar partitioning all-together, doing &lt;em&gt;zero&lt;/em&gt; scalar work, at the same time aligning everything to &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; size and being nice to our processor. Just to make this victory a tiny touch sweeter, even the &lt;em&gt;initial&lt;/em&gt; 2x8 partially overlapping vectors are read using aligned reads!
I named this approach “overligned” (overlap + align) in my code-base; it is available in full in &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/AVX2/Happy/B5_2_DoublePumpOverlined.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B5_2_DoublePumpOverlined.cs&lt;/code&gt;&lt;/a&gt;. It implements this overlapping alignment approach, with some extra small points for consideration:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When it is &lt;strong&gt;impossible&lt;/strong&gt; to align outwards, we fall back to the alignment mechanic introduced in the previous section.&lt;br /&gt;
This is uncommon: Going back to the statistical data we collected about random-data sorting in the 3&lt;sup&gt;rd&lt;/sup&gt; post, we anticipate a recursion depth of around 40 when sorting 1M elements and ~340K partitioning calls. We will have &lt;em&gt;at least&lt;/em&gt; 40x2 (for both sides) such cases where we align inwards for that 1M case, as an example. This is small change compared to the &lt;code class=&quot;highlighter-rouge&quot;&gt;340K - 80&lt;/code&gt; calls we can optimize with outward alignment, but it does mean we have to keep that old code lying around.&lt;/li&gt;
  &lt;li&gt;Once we calculate for a given partition how much alignment is required on each side, we can cache that calculation recursively for the entire depth of the recursive call stack: This again reduces the overhead we are paying for this alignment strategy.
In the code you’ll see I’m squishing two 32-bit integers into a 64-bit value I call &lt;code class=&quot;highlighter-rouge&quot;&gt;alignHint&lt;/code&gt; and I keep reusing one half of 64-bit value without recalculating the alignment &lt;em&gt;amount&lt;/em&gt;; If we’ve made it this far, let’s shave a few more cycles off while we’re here.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s another small optimization I tacked on to this version, which I’ll discuss immediately after providing the results:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#3d6bdb20-d0b7-4c05-ae7d-d6aa78662bad'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;3d6bdb20-d0b7-4c05-ae7d-d6aa78662bad&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,64K,100K,1M,1.5M,10M
Jedi,         1   , 1  , 1 , 1  , 1   , 1  , 1  , 1
Overlined, 1.012312,    0.995069647, 0.904921232, 0.905092554, 0.915092554, 0.9212314, 0.929801383, 0.960170878

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3}
  }  
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Overlined Sorting - Scaled to Jedi&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.88, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    },
    &quot;annotation&quot;: {
      &quot;annotations&quot;: [{
        &quot;drawTime&quot;: &quot;afterDatasetsDraw&quot;,
        &quot;type&quot;: &quot;line&quot;,
        &quot;mode&quot;: &quot;vertical&quot;,
        &quot;scaleID&quot;: &quot;x-axis-0&quot;,
        &quot;value&quot;: &quot;1.5M&quot;,

        &quot;borderColor&quot;: &quot;#666666&quot;,
        &quot;borderWidth&quot;: 2,
      &quot;borderDash&quot;: [5, 5],
       &quot;borderDashOffset&quot;: 5,
        &quot;label&quot;: {
          &quot;yAdjust&quot;: 5,
          &quot;backgroundColor&quot;: &quot;rgba(255, 0, 0, 0.75)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;fontSize&quot;: 14,
          &quot;content&quot;: &quot;L3 Cache Size&quot;,
          &quot;enabled&quot;: true
        }
      },
      {
        &quot;drawTime&quot;: &quot;afterDatasetsDraw&quot;,
        &quot;type&quot;: &quot;line&quot;,
        &quot;mode&quot;: &quot;vertical&quot;,
        &quot;scaleID&quot;: &quot;x-axis-0&quot;,
        &quot;value&quot;: &quot;64K&quot;,
        &quot;borderColor&quot;: &quot;#666666&quot;,
        &quot;borderWidth&quot;: 2,
      &quot;borderDash&quot;: [5, 5],
       &quot;borderDashOffset&quot;: 5,
        &quot;label&quot;: {
          &quot;yAdjust&quot;: 65,
          &quot;backgroundColor&quot;: &quot;rgba(255, 0, 0, 0.75)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;fontSize&quot;: 14,
          &quot;content&quot;: &quot;L2 Cache Size&quot;,
          &quot;enabled&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Jedi, 19.4547,  20.8907,  23.8802, 24.7229, 22.8053, 25.7011
Overlined, 20.092,  20.7878,  21.6097, 22.6238, 21.2044, 24.6774
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Jedi Sorting + Overlined - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 28,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt5_2_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;This is much better! The improvement is much more pronounced here, and we have a lot to consider:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The performance improvements are not spread evenly through-out the size of the sorting problem.&lt;/li&gt;
    &lt;li&gt;I’ve conveniently included two vertical markers, per my specific machine model, they show the size of the L2/L3 caches translated to &lt;code class=&quot;highlighter-rouge&quot;&gt;#&lt;/code&gt; of 32-bit elements in our array.&lt;/li&gt;
    &lt;li&gt;It can be clearly seen that as long as we’re sorting roughly within the size of our L2-L3 cache size range, this optimization pays in spades: we’re seeing ~10% speedup in runtime in many cases!&lt;/li&gt;
    &lt;li&gt;It is also clear that as we progress outside the size of the L2 into the L3 cache size, and ultimately exhaust the size of our caches entirely, the returns on this optimization diminish gradually.&lt;/li&gt;
    &lt;li&gt;While not shown here, since I’ve lost access to that machine, on older Intel/AMD machines, where only one load operation can be executed by the processor at any given time (Example: Intel Broadwell processors), this can lead to an improvement of 20% in total runtime; This should make sense: the less load ports the CPU has, the better this split-load reducing technique performs.&lt;/li&gt;
    &lt;li&gt;Another thing to consider is that in future variations of this code when I finally get access and ability to use AVX-512, with 64-byte wide registers, the effects of this optimization will be much more pronounced again for a different reason: With vector registers spanning 64-bytes each, split-loading becomes a bigger problem (every single un-aligned read becomes a split-load). Therefore, removing it is even more important.&lt;/li&gt;
  &lt;/ul&gt;

&lt;/div&gt;

&lt;p&gt;As the problem size goes beyond the size of the L2 cache, we are hit with the realities of CPU cache latency numbers. As service to the reader here is a visual representation for the &lt;a href=&quot;https://www.7-cpu.com/cpu/Skylake_X.html&quot;&gt;latency numbers for a Skylake-X CPU&lt;/a&gt; running at 4.3 Ghz:&lt;/p&gt;

&lt;center&gt;
&lt;object style=&quot;margin: auto; width: 90%&quot; type=&quot;image/svg+xml&quot; data=&quot;../assets/images/latency.svg&quot;&gt;&lt;/object&gt;
&lt;/center&gt;

&lt;p&gt;The small number of cycles we tack as the penalty of for split-loading (7 in this diagram) on to the memory operations is very real when we compare it to regular L1/L2 cache latency. But once we compare it to L3 or RAM latency, it becomes abundantly clear why we are seeing diminishing returns for this optimization; the penalty is simply too small to notice at those work points.&lt;/p&gt;

&lt;p&gt;Finally, for this optimization, we must never forget our moto of trust no one and nothing. Let’s double check what the current state of affairs is as far as &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; is concerned:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf record &lt;span class=&quot;nt&quot;&gt;-Fmax&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; mem_inst_retired.split_loads &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   ./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpOvelined &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 100000 &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;--max-loops&lt;/span&gt; 1000 &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-20&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# To display the perf.data header info, please use --header/--header-only options.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Samples: 129  of event 'mem_inst_retired.split_loads'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Event count (approx.): 12900387&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Overhead  Symbol&lt;/span&gt;
    30.23%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] DoublePumpOverlined...::Sort&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int64,int32&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    28.68%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] DoublePumpOverlined...::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    13.95%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] __memmove_avx_unaligned_erms
     0.78%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] JIT_MemSet_End
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Seems like this moved the needle, and then some. We started with &lt;code class=&quot;highlighter-rouge&quot;&gt;86.68%&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;87,102,613&lt;/code&gt; split-loads in our previous version of vectorized partitioning , and now we have &lt;code class=&quot;highlighter-rouge&quot;&gt;28.68%&lt;/code&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;12,900,387&lt;/code&gt;. In other words: &lt;code class=&quot;highlighter-rouge&quot;&gt;(0.2668 * 12900387) / (0.8668 * 87102613)&lt;/code&gt; gives us &lt;code class=&quot;highlighter-rouge&quot;&gt;4.55%&lt;/code&gt;, or a &lt;code class=&quot;highlighter-rouge&quot;&gt;95.44%&lt;/code&gt; reduction of split-load events for this version.
Not an entirely unpleasant experience.&lt;/p&gt;

&lt;h4 id=&quot;sub-optimization--converting-branches-to-arithmetic-1&quot;&gt;Sub-optimization- Converting branches to arithmetic: :+1:&lt;/h4&gt;

&lt;p&gt;By this time, my code contained quite a few branches to deal with various edge cases around alignment, and I pulled another rabbit out of the optimization hat that is worth mentioning: We can convert simple branches into arithmetic operations. Many times, we end up having branches with super simple code behind them; here’s a real example I used to have in my code, as part of some early version of overlinement, which we’ll try to optimize:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftAlign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Calculate left align here...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leftAlign&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;This looks awfully friendly, and it is unless &lt;code class=&quot;highlighter-rouge&quot;&gt;leftAlign&lt;/code&gt; and therefore the entire branch is determined by random data we read from the array, making the CPU mispredict this branch too often than we’d care for it to happen. In my case, I had two branches like this, and each of them was happening at a rate of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/8&lt;/code&gt;. So enough for me to care. The good news is that we can re-write this, entirely in C#, and replace the potential misprediction with a constant, predictable (and often shorter!) data dependency. Let’s start by inspecting the re-written “branch”:&lt;/p&gt;

&lt;/div&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftAlign&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Calculate left align here...&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Signed arithmetic FTW&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftAlignMask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftAlign&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;31&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// the mask is now either all 1s or all 0s depending on leftAlign's sign!&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftALignMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;By taking the same value we were comparing to 0 and right shifting it, we are performing an arithmetic right shift. This takes the top bit, which is either &lt;code class=&quot;highlighter-rouge&quot;&gt;0/1&lt;/code&gt; depending on &lt;code class=&quot;highlighter-rouge&quot;&gt;leftAlign&lt;/code&gt;’s sign bit, and essentially propagates it throughout the entire 32-bit value, which is then assigned to the &lt;code class=&quot;highlighter-rouge&quot;&gt;lestAlignMask&lt;/code&gt; variable. We’ve essentially taken what was previously the result of the comparison as part of the branch (the sign bit), transforming it into a mask. We then proceed to take the mask and use it to control the outcome of the &lt;code class=&quot;highlighter-rouge&quot;&gt;+= 8&lt;/code&gt; operation, effectively turning it into &lt;em&gt;either&lt;/em&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;+= 8&lt;/code&gt; -or- a &lt;code class=&quot;highlighter-rouge&quot;&gt;+= 0&lt;/code&gt; operation, depending on the value of the mask!&lt;br /&gt;
This turns out to be a quite effective way, again, for simple branches only, at converting a potential misprediction event costing us 15 cycles, with a 100% constant 3-4 cycles data-dependency for the CPU: It can be thought as a “signaling” mechanism where we tell the CPU not to speculate on the result of the branch but instead complete the &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft +=&lt;/code&gt; statement only after waiting for the right-shift (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;gt; 31&lt;/code&gt;) and the bitwise and (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&lt;/code&gt;) operation to propagate through its pipeline.&lt;/p&gt;

  &lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;&lt;div&gt;
          &lt;p&gt;I referred to this as an old geezer’s optimization since modern processors already support this internally in the form of a &lt;code class=&quot;highlighter-rouge&quot;&gt;CMOV&lt;/code&gt; instruction, which is more versatile, faster and takes up less bytes in the instruction stream while having the same “do no speculate on this” effect on the CPU. &lt;em&gt;The only issue&lt;/em&gt; is we don’t have &lt;code class=&quot;highlighter-rouge&quot;&gt;CMOV&lt;/code&gt; in the CoreCLR JIT (Mono’s JIT, peculiarly does support this both with the internal JIT and naturally with LLVM…).&lt;br /&gt;
As a side note to this side note, I’ll add that this is such an old-dog trick that LLVM even detects such code and de-optimizes it back into a “normal” branch and then proceeds to optimize it again into &lt;code class=&quot;highlighter-rouge&quot;&gt;CMOV&lt;/code&gt;, which I think is just a very cool thing, regardless :)&lt;/p&gt;
        &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;I ended up replacing about 5-6 super simple/small branches this way. I won’t show direct performance numbers for this, as this is already part of the overlined version; I can’t say it improved performance considerably for my test runs, but it did reduce the jitter of those runs, which can be seen in the reduced error bars and tighter confidence intervals shown in the benchmark results above.&lt;/p&gt;

&lt;h3 id=&quot;coming-to-terms-with-bad-speculation&quot;&gt;Coming to terms with bad speculation&lt;/h3&gt;

&lt;p&gt;At the end of part 3, we came to a hard realization that our code is badly speculating inside the CPU. Even after simplifying the branch code in our loop in part 4, the bad speculation remained there, staring at us persistently. If you recall, we experienced a lot of bad-speculation effects when sorting the data with our vectorized code, and profiling using hardware counters showed us that while &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; was the cause of most of the bad-speculation events (41%), our vectorized code was still responsible for 32% of them. Let’s try to think about that mean nasty branch, stuck there, in the middle of our beautiful loop:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;Long story short: We ended up sneaking up a data-based branch into our code in the form of this side-selection logic. Whenever we try to pick a side, we would read from next is where we put the CPU in a tough spot. We’re asking it to speculate on something it &lt;em&gt;can’t possibly speculate on successfully&lt;/em&gt;. Our question is: “Oh CPU, CPU in the socket, Which side is closer to being over-written of them all?”, to which the answer is completely data-driven. In other words, it depends on how the last round(s) of partitioning mutated the pointers involved in the comparison. It might sound like an easy thing for the CPU to check, but we have to remember it is attempting to execute ~100 or so instructions into the future, as it is required to speculate on the result: the previous rounds of partitioning have not yet been fully-executed, internally. The CPU guesses, at best, based on stale data, and we know, as the grand designers of this mess, that its best guess is no better here than flipping a coin. Quite sad. You have to admit it is ironic we managed to do this whole big circle around our own tails just to come-back to having a branch misprediction based on the random array data. Mis-predicting here seems unavoidable. Or is it?&lt;/p&gt;

  &lt;h4 id=&quot;replacing-the-branch-with-arithmetic--1&quot;&gt;Replacing the branch with arithmetic: :-1:&lt;/h4&gt;

  &lt;p&gt;Could we replace this branch with arithmetic, just like we’ve done a couple of paragraphs above? Yes we can.
Consider this alternative version:&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRightMask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;63&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeftMask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readRightMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// If readRightMask is 0, we pick the left side&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// If readLeftMask is 0, we pick the right side&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRightMaybe&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRightMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeftMaybe&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeftMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeftMaybe&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRightMaybe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postFixUp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRightMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postFixUp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postFixUp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What the code above does, except for causing a nauseating headache, is taking the same concept of turning branches into arithmetic from the previous section and using it to get rid of that nasty branch: We take the comparison and turn it into a negative/positive number, then proceed to use it to generate masks we use to execute the code that used to reside under the branch.&lt;/p&gt;

&lt;p&gt;I don’t want to dig deep into this. While its technically sound, and does what we need it to do, it’s more important to focus on how this performs:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#8fc63529-869b-4c7d-aab5-2c2d25a929f2'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;8fc63529-869b-4c7d-aab5-2c2d25a929f2&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Overlined,         1   , 1   , 1  , 1   , 1    , 1
Branchless, 0.87253937, 0.951842168, 1.104715689, 1.140662148, 1.253573179, 1.379499062

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3}
  }  
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Branchless Sorting - Scaled to Overlined&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.80, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Overlined, 20.3199,21.0354,21.6787,23.0622,23.246,24.7603
Branchless, 17.7252,20.0221,23.9488,26.3062,29.1405,34.1567

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Jedi Sorting + Aligned - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 35,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt5_3_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;Look, I’m not here to sugar-coat it: This looks like an unmitigated disaster. But I claim that it is one we can learn a lot from in the future.
With the exception of sorting &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;= 100&lt;/code&gt; elements, as the problem grows, the situation is getting much worse.&lt;/p&gt;

  &lt;p&gt;To double-check that everything is sound, I ran &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; recording the &lt;code class=&quot;highlighter-rouge&quot;&gt;instructions&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;branches&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;branch-misses&lt;/code&gt; events for both versions for sorting &lt;code class=&quot;highlighter-rouge&quot;&gt;100,000&lt;/code&gt; elements.&lt;/p&gt;

  &lt;p&gt;The command line used was this:&lt;/p&gt;

  &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; instructions,branches,branch-misses &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    ./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpOverlined &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
              &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 100000 &lt;span class=&quot;nt&quot;&gt;--max-loops&lt;/span&gt; 1000 &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; instructions,branches,branch-misses &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    ./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpBranchless &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
              &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 100000 &lt;span class=&quot;nt&quot;&gt;--max-loops&lt;/span&gt; 1000 &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;If you’re one of those sick people who likes to look into other people’s sorrows, here is a &lt;a href=&quot;https://gist.github.com/damageboy/79368e350364348c6ca476492a63f052&quot;&gt;gist with the full results&lt;/a&gt;, if you’re more normal, and to keep things simple, I’ve processed the results and presenting them here in table form:&lt;/p&gt;

  &lt;center&gt;
&lt;object style=&quot;margin: auto; width: 90%&quot; type=&quot;image/svg+xml&quot; data=&quot;../assets/images/overlined-branchless-counters.svg&quot;&gt;&lt;/object&gt;
&lt;/center&gt;

&lt;/div&gt;

&lt;p&gt;This is pretty amazing if you think about it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The number of branches was cut in half: This makes sense, the loop control itself is a branch instuction after all, so it remains even in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Branchless&lt;/code&gt; variant.&lt;/li&gt;
  &lt;li&gt;The branches that remain in the &lt;code class=&quot;highlighter-rouge&quot;&gt;branchless&lt;/code&gt; version are all easy to predict, and we see that the &lt;code class=&quot;highlighter-rouge&quot;&gt;branch-misses&lt;/code&gt; counter shows us those are down to nothing.&lt;br /&gt;
This means that there is no mistake: We succeeded in a targeted assassination of that branch; however, there was a lot of collateral damage…&lt;/li&gt;
  &lt;li&gt;The verbiage of the branchless code, expressed in the &lt;code class=&quot;highlighter-rouge&quot;&gt;instructions&lt;/code&gt; counter is definitely costing us something here:&lt;br /&gt;
The number of executed instructions inside our partition loop have gone up by 17%, which is a lot.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The slowdown we’ve measured here is directly related to NOT having &lt;code class=&quot;highlighter-rouge&quot;&gt;CMOV&lt;/code&gt; available to us through the CoreCLR JIT. but I really don’t think that this is the entire story here. It’s hard to express this in words, but
the slope at which the branchless code is slowing down compared to the previous version is very suspicious in my eyes.&lt;br /&gt;
There is an expression we use in Hebrew a lot for this sort of situation: “The operation was successful, but the patient died”. There is no question that this is one of those moments.
This failure to accelerate the sorting operation, and specifically the way it fails, increasingly as the problem size grows, is very telling in my eyes.
I have an idea of why this is and how we might be able to go around it. But, for today, our time is up. I’ll try and get back to this much much later in this series,
and hopefully, we’ll all be wiser for it.&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:0&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Remember that the CPU knows nothing about two different cache-lines. They might actually be on a page boundary as well, which means they might be in two different DRAM chips, or perhaps, a single split-line access causes our poor CPU to communicate with a different socket, where another memory controller is responsible to reading the memory from its own DRAM modules! &lt;a href=&quot;#fnref:0&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Most modern Intel CPUs can actually address the L1 cache units twice per cycle, at least when it comes to reading data, by virtue of having two load-ports. That means they can actually request two cache-line as the same time! But this still causes more load on the cache and bus. In our case, we must also remember we will be reading an additional cache-line for our permutation entry… &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;This specific AVX2 intrinsic will actually fail if/when used on non-aligned addresses. But it is important to note that it seems it won’t actually run faster than the previous load intrinsic we’ve used: &lt;code class=&quot;highlighter-rouge&quot;&gt;AVX2.LoadDquVector256&lt;/code&gt; as long as the actual addresses we pass to both instructions are 32-byte aligned. In other words, it’s very useful for debugging alignment issues, but not that critical to actually call that intrinsic! &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I could be wrong about that last statement, but I couldn’t find anything quite like this discussed anywhere, and believe me, I’ve searched. If anyone can point me out to someone doing this before, I’d really love to hear about it; there might be more good stuff to read about there… &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">Decimating Array.Sort with AVX2. I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics. There's no reason I should go down alone.</summary></entry><entry><title type="html">This Goes to Eleven (Pt. 4/∞)</title><link href="https://bits.houmus.org/2020-02-01/this-goes-to-eleven-pt4" rel="alternate" type="text/html" title="This Goes to Eleven (Pt. 4/∞)" /><published>2020-02-01T05:26:28+00:00</published><updated>2020-02-01T05:26:28+00:00</updated><id>https://bits.houmus.org/2020-02-01/this-goes-to-eleven-pt4</id><content type="html" xml:base="https://bits.houmus.org/2020-02-01/this-goes-to-eleven-pt4">&lt;p&gt;I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics, and there’s no reason I should go down alone.&lt;/p&gt;

&lt;p&gt;Since there’s a lot to go over here, I’ll split it up into a few parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-28/this-goes-to-eleven-pt1&quot;&gt;part 1&lt;/a&gt;, we start with a refresher on &lt;code class=&quot;highlighter-rouge&quot;&gt;QuickSort&lt;/code&gt; and how it compares to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-29/this-goes-to-eleven-pt2&quot;&gt;part 2&lt;/a&gt;, we go over the basics of vectorized hardware intrinsics, vector types, and go over a handful of vectorized instructions we’ll use in part 3. We still won’t be sorting anything.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-30/this-goes-to-eleven-pt3&quot;&gt;part 3&lt;/a&gt; we go through the initial code for the vectorized sorting, and start seeing some payoff. We finish agonizing courtesy of the CPU’s branch predictor, throwing a wrench into our attempts.&lt;/li&gt;
  &lt;li&gt;In this part, we go over a handful of optimization approaches that I attempted trying to get the vectorized partition to run faster, seeing what worked and what didn’t.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-02-02/this-goes-to-eleven-pt5&quot;&gt;part 5&lt;/a&gt;, we’ll take a deep dive into how to deal with memory alignment issues.&lt;/li&gt;
  &lt;li&gt;In part 6, we’ll take a pause from the vectorized partitioning, to get rid of almost 100% of the remaining scalar code, by implementing small, constant size array sorting with yet more AVX2 vectorization.&lt;/li&gt;
  &lt;li&gt;In part 7, We’ll circle back and try to deal with a nasty slowdown left in our vectorized partitioning code&lt;/li&gt;
  &lt;li&gt;In part 8, I’ll tell you the sad story of a very twisted optimization I managed to pull off while failing miserably at the same time.&lt;/li&gt;
  &lt;li&gt;In part 9, I’ll try some algorithmic improvements to milk those last drops of perf, or at least those that I can think of, from this code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;squeezing-some-more-juice&quot;&gt;Squeezing some more juice&lt;/h2&gt;

&lt;p&gt;I thought it would be nice to show a bunch of things I ended up trying to improve performance.
I tried to keep most of these experiments in separate implementations, both the ones that yielded positive results and the failures. These can be seen in the original repo under the &lt;a href=&quot;https://github.com/damageboy/VxSort/tree/research/VxSortResearch/Unstable/AVX2/Happy&quot;&gt;Happy&lt;/a&gt; and &lt;a href=&quot;https://github.com/damageboy/VxSort/tree/research/VxSortResearch/Unstable/AVX2/Sad&quot;&gt;Sad&lt;/a&gt; folders.&lt;/p&gt;

&lt;p&gt;While some worked, and some didn’t, I think a bunch of these were worth mentioning, so here goes:&lt;/p&gt;

&lt;h3 id=&quot;dealing-with-small-jit-hiccups-1&quot;&gt;Dealing with small JIT hiccups: :+1:&lt;/h3&gt;

&lt;p&gt;One of the more surprising things I’ve discovered during the optimization journey was that the JIT could generate much better code, specifically around/with pointer arithmetic. With the basic version we got working by the end of the &lt;a href=&quot;/2020-01-30/this-goes-to-eleven-pt3&quot;&gt;3&lt;sup&gt;rd&lt;/sup&gt; post&lt;/a&gt;, I started turning my attention to the body of the main loop. That main loop is where I presume we spend most of our execution time. I quickly encountered some red-flag raising assembly code, specifically with this single line of code, which we’ve briefly discussed before:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It looks innocent enough, but here’s the freely commented x86 asm code for it:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✓  copy readLeft&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r12&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✓  subtract writeLeft&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✘  wat?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;3Fh&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✘  wat?1?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;and&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✘  wat?!?!?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✘  wat!?!@#&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✘  wat#$@#$@&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rbp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;58h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; ✓✘ copy writeRight, but from stack?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓✘ in the loop body?!?!?, Oh lordy!&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓  subtract readRight&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✘  wat?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;3Fh&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✘  wat?!?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;and&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✘  wat!?!@#&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✘  wat#$@#$@&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;; ✘  wat^!#$!#$&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓  finally, comapre!&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s not every day that we get to see two JIT issues with one line of code, I know some people might take this as a bad sign, but in my mind this is great! To me this feels like digging for oil in Texas in the early 20s…
We’ve practically hit the ground with a pickaxe accidentally, only to see black liquid seeping out almost immediately!&lt;/p&gt;

&lt;h4 id=&quot;jit-bug-1-variable-not-promoted-to-register&quot;&gt;JIT Bug 1: variable not promoted to register&lt;/h4&gt;

&lt;p&gt;One super weird thing that we see happening here is the difference in the asm code that copies &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt; on &lt;span class=&quot;uk-label&quot;&gt;L8-9&lt;/span&gt; from the &lt;em&gt;stack&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;[rbp-58h]&lt;/code&gt;) before performing the subtraction when compared to &lt;span class=&quot;uk-label&quot;&gt;L1&lt;/span&gt; where a conceptually similar copy is performed for &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt; from a register (&lt;code class=&quot;highlighter-rouge&quot;&gt;rdx&lt;/code&gt;). The code merely tries to subtract two pairs of pointers, but the generated machine code is weird: 3 out of 4 pointers were correctly lifted out of the stack into registers outside the body of the loop (&lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt;), but the 4&lt;sup&gt;th&lt;/sup&gt; one, &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt;, is the designated black-sheep of the family and is being continuously read from the stack (and later in that loop body is also written back to the stack, to make things worse).&lt;br /&gt;
There is no good reason for this, and this clearly smells! What do we do?&lt;/p&gt;

&lt;p&gt;For one thing, I’ve &lt;a href=&quot;https://github.com/dotnet/runtime/issues/35495&quot;&gt;opened up an issue&lt;/a&gt; about this weirdness. The issue itself shows just how finicky the JIT is regarding this one variable, and (un)surprisingly, by fudging around the setup code this can be easily worked around for now.&lt;br /&gt;
As a refresher, here’s the original setup code I presented in the previous post, just before we enter the loop body:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;VectorizedPartitionInPlace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;- Why the hate?&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pBase&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Int32PermTables&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IntPermTablePtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And here’s a simple fix: moving the pointer declaration closer to the loop body seems to convince the JIT that we can all be friends once more:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;VectorizedPartitionInPlace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ... omitted for brevity&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// &amp;lt;- Oh, so now we're cool?&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The asm is &lt;em&gt;slightly&lt;/em&gt; cleaner:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓ copy readLeft&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r15&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓ subtract writeLeft&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✘ wat?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;3Fh&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✘ wat?1?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;and&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;; ✘ wat?!?!?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✘ wat!?!@#&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;; ✘ wat#$@#$@&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓ copy writeRight&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✓ subtract readRight&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✘ wat?1?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;3Fh&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; ✘ wat?!?!?&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;and&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✘ wat!?!@#&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r10&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;; ✘ wat#$@#$@&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sar&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;; ✘ wat^%#^#@!&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;; ✓ finally, comapre!&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It doesn’t look like much, but we’ve managed to remove two memory accesses from the loop body (the read, shown above and a symmetrical write to the same stack variable/location towards the end of the loop).
It’s also clear, at least from my comments that I’m not entirely pleased yet, so let’s move on to…&lt;/p&gt;

&lt;h4 id=&quot;jit-bug-2-not-optimizing-pointer-difference-comparisons&quot;&gt;JIT bug 2: not optimizing pointer difference comparisons&lt;/h4&gt;

&lt;p&gt;Calling this one a bug might be stretch, but in the world of the JIT, sub-optimal code generation can be considered just that. The original code performing the comparison is making the JIT (wrongfully) think that we want to perform &lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt; arithmetic for &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft - writeLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight - readRight&lt;/code&gt;. In other words: The JIT emits code subtracting both pointer pairs, generating a &lt;code class=&quot;highlighter-rouge&quot;&gt;byte *&lt;/code&gt; difference for each pair; which is great (I marked that with checkmarks in the listings). Then, it goes on to generate extra code converting those differences into &lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt; units: so lots of extra arithmetic operations. This is simply useless: we just care if one side is larger than the other. What the JIT is doing here is similar in spirit to converting two distance measurements taken in &lt;code class=&quot;highlighter-rouge&quot;&gt;cm&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;km&lt;/code&gt; just to compare which one is greater.&lt;br /&gt;
To work around this disappointing behaviour, I wrote this instead:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;By doing this sort of seemingly useless casting 4 times, we get the following asm generated:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; ✓ copy readRight&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r12&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; ✓ subtract writeLeft&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;; ✓ copy writeRight&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r13&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;; ✓ subtract readRight&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;; ✓ compare&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It doesn’t take a degree in reverse-engineering asm code to figure out this was a good idea.&lt;br /&gt;
Casting each pointer to &lt;code class=&quot;highlighter-rouge&quot;&gt;byte *&lt;/code&gt; coerces the JIT to do our bidding and just perform a simpler comparison.&lt;/p&gt;

&lt;h4 id=&quot;jit-bug-3-updating-the-write-pointers-more-efficiently&quot;&gt;JIT Bug 3: Updating the &lt;code class=&quot;highlighter-rouge&quot;&gt;write*&lt;/code&gt; pointers more efficiently&lt;/h4&gt;

&lt;p&gt;I discovered another missed opportunity in the pointer update code at the end of our inlined partitioning block. When we update the two &lt;code class=&quot;highlighter-rouge&quot;&gt;write*&lt;/code&gt; pointers, our intention is to update two &lt;code class=&quot;highlighter-rouge&quot;&gt;int *&lt;/code&gt; values with the result of the &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; intrinsic:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8U&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Unfortunately, the JIT isn’t smart enough to see that it would be wiser to left shift &lt;code class=&quot;highlighter-rouge&quot;&gt;popCount&lt;/code&gt; once by &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt; (e.g. convert to &lt;code class=&quot;highlighter-rouge&quot;&gt;byte *&lt;/code&gt; distance)  and reuse that left-shifted value &lt;strong&gt;twice&lt;/strong&gt; while mutating the two pointers.
Again, uglifying the originally clean code into the following god-awful mess get’s the job done:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;4U&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’ll skip the asm this time. It’s pretty clear from the C# that we pre-left shift (or multiply by 4) the &lt;code class=&quot;highlighter-rouge&quot;&gt;popCount&lt;/code&gt; result before mutating the pointers.
We’re now generating slightly denser code by eliminating a silly instruction from a hot loop.&lt;/p&gt;

&lt;p&gt;All 3 of these workarounds can be seen on my repo in the &lt;a href=&quot;https://github.com/damageboy/VxSort/tree/research&quot;&gt;research branch&lt;/a&gt;. I kept this pretty much as-is under &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/AVX2/Happy/B4_1_DoublePumpMicroOpt.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;B4_1_DoublePumpMicroOpt.cs&lt;/code&gt;&lt;/a&gt;.
Time to see whether all these changes help in terms of performance:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#f26d55b8-f3f3-45ad-a052-56e3d7306828'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;f26d55b8-f3f3-45ad-a052-56e3d7306828&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Naive,         1   , 1   , 1  , 1   , 1    , 1
MicroOpt, 1.01, 0.93, 0.93, 0.93, 0.89 , 0.87
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 3	}
  }]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Micro-optimized Sorting - Scaled to AVX2 Naive Sorting&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.84, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Naive        , 21.2415, 26.0040, 30.7502, 31.4513, 27.4290, 30.6499
MicroOpt, 21.3374, 23.9888, 28.4617, 29.1356, 24.4974, 26.8152
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 3	}
  }]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Naive+Micro-optimized Sorting - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 20,
          &quot;max&quot;: 35,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_1_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;This is quite better! I’ve artificially set the y-axis here to a narrow range of 80%-105% so that the differences would become more apparent. The improvement is &lt;em&gt;very&lt;/em&gt; measurable. Too bad we had to uglify the code to get here, but such is life. Our results just improved by another ~7-14% across the board.&lt;br /&gt;
If this is the going rate for ugly, I’ll bite the bullet :)&lt;/p&gt;

  &lt;p&gt;I did not include any statistics collection tab for this version since there is no algorithmic change involved.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;selecting-a-better-cut-off-threshold-for-scalar-sorting-1&quot;&gt;Selecting a better cut-off threshold for scalar sorting: :+1:&lt;/h3&gt;

&lt;p&gt;I briefly mentioned this at the end of the 3&lt;sup&gt;rd&lt;/sup&gt; post: While it made sense to start with the same threshold that &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; uses (&lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;) to switch from partitioning into small array sorting, there’s no reason to assume this is the optimal threshold for &lt;em&gt;our&lt;/em&gt; partitioning function: Given that the dynamics have changed with vectorized partitioning, the optimal cut-off point probably needs to move too.&lt;br /&gt;
In theory, we should retest the cut-off point after every optimization that succeeds in moving the needle; I won’t do this after every optimization, but I will do so again for the final version. For the meantime, let’s see how playing with the cut-off point changes the results: We’ll try &lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;48&lt;/code&gt; on top of &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;, and see what comes on top:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#324b4f6c-1fea-4605-8dc7-6abf1826ec74'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;324b4f6c-1fea-4605-8dc7-6abf1826ec74&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
MicroOpt_24,0.823310023,0.882747579,0.914373696,0.902330475,0.958166708,0.971168474
MicroOpt_32,0.817715618,0.766905542,0.839337033,0.850782566,0.973364241,0.9561571
MicroOpt_40,0.761305361,0.749485401,0.837020549,0.842011671,0.95013881,0.958056824
MicroOpt_48,0.758041958,0.75722345,0.823212214,0.839358026,0.966057806,0.962200074
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ 
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,33,220,.5)&quot;,
    &quot;hidden&quot;: &quot;true&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 12	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(220,33,33,.5)&quot;,
    &quot;hidden&quot;: &quot;true&quot;,    
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 90, &quot;hachureGap&quot;: 12	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,220,.5)&quot;,
    &quot;hidden&quot;: &quot;true&quot;,    
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 120, &quot;hachureGap&quot;: 12	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Sorting - Cut-off Tuning&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.70, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
MicroOpt_24,17.6195,25.5307,25.4022,26.5767,23.3013,25.6154
MicroOpt_32,17.3879,22.0054,25.9392,26.6394,23.3355,25.6553
MicroOpt_40,17.3027,23.2386,26.1287,26.3959,23.4568,25.7346
MicroOpt_48,17.0937,23.5973,25.6651,26.3667,23.2584,25.6
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ 
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,33,220,.5)&quot;,
    &quot;hidden&quot;: &quot;true&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 12	}    
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(220,33,33,.5)&quot;,
    &quot;hidden&quot;: &quot;true&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 90, &quot;hachureGap&quot;: 12	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,220,.5)&quot;,
    &quot;hidden&quot;: &quot;true&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 120, &quot;hachureGap&quot;: 12	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Sorting - Cut-off Tuning - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 30,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_2_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[5, 10, 15, 20]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;I’ve pulled a little trick with these charts: by default, I’ve &lt;em&gt;hidden&lt;/em&gt; everything but one of the cut-off points: &lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;, that being the best new cut-off point, at least in my opinion. If you care to follow my reasoning process, I suggest you start slowly clicking (or touching) the &lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;48&lt;/code&gt; series/titles in the legend. This will add them back into the chart, one by one. Stop to appreciate what you are seeing; Once you’ll do so, I think it’s easier to see that:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The initial value we started off with: &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;, the baseline for this series of benchmarks, is undoubtedly the &lt;em&gt;worst possible&lt;/em&gt; cut-off for vectorized partitioning…&lt;br /&gt;
&lt;em&gt;All of the other cut-off points have scaling values below 100%&lt;/em&gt;, hence they are faster.&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;24&lt;/code&gt; does not do us a world of good here either: It’s clearly always next worst option.&lt;/li&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;32&lt;/code&gt; is pretty good, except that in the lower edge of the chart, where the higher cut-off points seem to provide better value.&lt;/li&gt;
    &lt;li&gt;For the most part, using any one of &lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;48&lt;/code&gt; as a cut-off point seems to be the right way to go. These two cover the least area in the chart. In other words, they all provide the best improvement, on average, for our scenario.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;I ended up voting for &lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt;. There’s no good reason I can give for this except for (perhaps wrong) instinct. Lest we forget, another small pat of the back is in order: we’ve managed to speed up our sorting code with an improvement ranging from 5-25% throughout the entire spectrum, which is cause for a small celebration in itself.&lt;/p&gt;

  &lt;p&gt;To be completely honest here, there is another, ulterior motive, as far as I’m concerned, for showing the effect of changing the small sorting threshold so early into this series. By doing so, we can sense where this trail will take us on our journey: It’s pretty clear that we will end up with two equally important implementations, each handling a large part of the total workload for sorting:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The vectorized partitioning will be tasked with the initial heavy lifting, relegated to taking large arrays and breaking them down to many small, unsorted, yet completely distinct groups of elements.&lt;br /&gt;
To put it plainly: taking a million elements and splitting them up into 10,000-20,000 groups of ~50-100 elements each, that do not cross-over each other; that way we can use…&lt;/li&gt;
    &lt;li&gt;Small-sorting, which will end up doing a final pass taking many small ~50-100 element groups, sorting them in place, before moving on to the next group.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Given that we will always start with partitioning before concluding with small-sorting, we end up with a complete solution. Just as importantly, we can optimize &lt;em&gt;each&lt;/em&gt; of the two parts making up our solution &lt;em&gt;independently&lt;/em&gt;, in the coming posts.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;explicit-prefetching--1&quot;&gt;Explicit Prefetching: :-1:&lt;/h3&gt;

&lt;p&gt;I tried using prefetch intrinsics to give the CPU early hints as to where we are reading memory from.&lt;/p&gt;

&lt;p&gt;Generally speaking, explicit prefetching can be used to make sure the CPU always reads some data from memory into the cache &lt;em&gt;ahead of the actual time&lt;/em&gt; we require it so that the CPU never needs to wait for memory, which is very slow. The bottom line is that having to wait for RAM is a death sentence (200-300 cpu cycles), but even having to wait for L2 cache (14 cycles) when your entire loop’s throughput is around 9 cycles is unpleasant. With prefetch intrinsics we can explicitly instruct the CPU to prefetch specific cache lines all the way to L1 cache, or alternatively specify the target level as L2, L3.&lt;/p&gt;

&lt;p&gt;Just because we can do something, doesn’t mean we should: do we actually need to prefetch? CPU designers know all of the above just as much as we do, and the CPU already attempts to prefetch data based on complex and obscure heuristics. You might be tempted to think: “oh, what’s so bad about doing it anyway?”.  Well, quite a lot, to be honest: when we explicitly tell the CPU to prefetch data, we’re wasting both instruction cache and decode+fetch bandwidth. Those might be better used for executing our computation.&lt;br /&gt;
So, the bottom line remain somewhat hazy, but we can probably try and set-up some ground rules that are probably true in 2020:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;CPUs can prefetch data when we traverse memory sequentially.&lt;/li&gt;
  &lt;li&gt;They do so regardless of the traversal direction (increasing/decreasing addresses).&lt;/li&gt;
  &lt;li&gt;They can sucessfully figure out the &lt;em&gt;stride&lt;/em&gt; we use, when it is constant.&lt;/li&gt;
  &lt;li&gt;They do so by building up history of our reads, per call-site.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With all that in mind, it is quite likely that prefetching in our case would do little good: Our partitioning code pretty much hits every point in the previous list. But even so, you can never really tell without either trying out, or inspecting memory-related performance counters. The latter, turns out to be &lt;a href=&quot;https://gist.github.com/travisdowns/90a588deaaa1b93559fe2b8510f2a739&quot;&gt;more complicated than what you’d think&lt;/a&gt;, and sometimes, it’s just easier to try out something rather than attempt to measure it ahead of time. In our case, prefetching the &lt;em&gt;writable&lt;/em&gt; memory &lt;strong&gt;makes no sense&lt;/strong&gt;, as our loop code mostly reads from the same addresses just before writing to them in the next iteration or two, so I mostly focused on trying to prefetch the next read addresses.&lt;/p&gt;

&lt;p&gt;Whenever I modified &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt;, I immediately added code like this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Trying to be clever here,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// If we are reading from the left at this iteration,&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// we are likely to read from right in the next iteration&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Sse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Prefetch0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Same as above, only the other way around:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// After reading from the right, it's likely&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// that our next read will be on the left side&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Sse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Prefetch0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This tells the CPU we are about to use data in &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft + 64&lt;/code&gt; (the next cache-line from the left) and &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight -  64&lt;/code&gt; (the next cache-line from the right) in the following iterations.&lt;/p&gt;

&lt;p&gt;While this looks great on paper, the real world results of this were unnoticeable for me and even slightly negative. For the most part, it appears that the CPUs I used for testing did a good job without me constantly telling them to do what they had already been doing on their own… Still, it was worth a shot.&lt;/p&gt;

&lt;h3 id=&quot;simplifying-the-branch-1&quot;&gt;Simplifying the branch :+1:&lt;/h3&gt;

&lt;p&gt;I’m kind of ashamed at this particular optimization: I had been literally staring at this line of code and optimizing around it for months without stopping to really think about what it was that I’m &lt;strong&gt;really trying&lt;/strong&gt; to do. Let’s go back to our re-written branch from a couple of paragraphs ago:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; 
    &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’ve been describing this condition both in animated and code form in the previous part, explaining how for my double-pumping to work, I have to figure out which side we &lt;em&gt;must&lt;/em&gt; read from &lt;strong&gt;next&lt;/strong&gt; so we never end-up overwriting data before having a chance to read and partition yet. All of this is happening in the name of performing in-place partitioning. However, I’ve been over-complicating the actual condition!&lt;br /&gt;
At some, admittedly late stage, “it” hit me, so let’s play this out step-by-step:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We always start with the setup I’ve previously described, where we make &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements worth of space available on &lt;strong&gt;both&lt;/strong&gt; sides, by partitioning them away into the temporary memory.&lt;/li&gt;
  &lt;li&gt;When we get into the main partitioning loop, we pick one specific side to read from: so far, this has always been the left side (It doesn’t &lt;em&gt;really&lt;/em&gt; matter which side it is, but it arbitrarily ended up being the &lt;em&gt;left&lt;/em&gt; side due to the condition being &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;=&lt;/code&gt; rather than &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Given all of the above, we always &lt;em&gt;start&lt;/em&gt; reading from the left, there-by increasing the “breathing space” on that left side from &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; to &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; elements temporarily.&lt;/li&gt;
  &lt;li&gt;Once our trusty ole’ partitioning block is done, we can pause and reason on how both sides now look:
    &lt;ul&gt;
      &lt;li&gt;The left side either has:
        &lt;ul&gt;
          &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements of space (in the less likely, yet possible case that all elements read from it were smaller than the selected pivot) -or-&lt;/li&gt;
          &lt;li&gt;It has more than &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements of “free” space.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;In the first case, where the left side is now back to 8 elements of free space, the right side also has &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements of free space, since nothing was written on that side!&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;In all other cases, the left side has &lt;em&gt;more&lt;/em&gt; than &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements of free space, and the right side has less than &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements of free space, by definition.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Since these are the true dynamics, why should we even bother comparing &lt;strong&gt;both&lt;/strong&gt; heads and tails of each respective side?&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The answer to that last question is: &lt;strong&gt;We don’t have to!&lt;/strong&gt;&lt;br /&gt;
We could simplify the branch by comparing only the right head+tail pointer distance to see if it is smaller than the magical number &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; or not!
This new condition would be just as good at serving the original &lt;em&gt;intent&lt;/em&gt; (which is: “don’t end up overwriting unread data”) as the more complicated branch we used before…&lt;br /&gt;
When the right side has less than &lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; elements, we &lt;em&gt;have to&lt;/em&gt; read from the right side in the next round, since it is in danger of being over-written, otherwise, the only other option is that both sides are back at 8-elements each, and we should go back to reading from the left side again, essentially going back to our starting setup condition as described in (1). It’s kind of silly, and I really feel bad it took me 4 months or so to see this. The new condition ends up being much simpler to encode and execute:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This branch is just as “correct” as the previous one, but it is less taxing in a few ways:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Less instructions to decode and execute.&lt;br /&gt;
We’ve saved an additional 5 bytes worth of opcodes from the main loop!&lt;/li&gt;
  &lt;li&gt;Less data dependencies for the CPU to potentially wait for.&lt;br /&gt;
(The CPU doesn’t have to wait for the &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt; pointer mutation and subtraction to complete)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Naturally this ends up slightly faster, and can verify this with BDN once again:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#fcd8c2f3-b377-44eb-9b18-5964ad2a69b4'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;fcd8c2f3-b377-44eb-9b18-5964ad2a69b4&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
MicroOpt_40,1,1,1,1,1,1
SimpleBranch,1.01220256253813,0.946321321321321,0.982688056091031,0.938806414898963,1.00465999238207,0.962359905144129

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 SimpleBranch Sorting - Scaled to MicroOpt_40&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.92, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,
MicroOpt_40,16.3891,21.3124,24.0181,26.2096,23.1979,26.4655
SimpleBranch,16.5929,20.168,23.6023,24.6058,23.306,25.4694

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 MicroOpt_40 + SimplerBranch - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 27,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_3_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[5, 10, 15, 20]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;There’s not a lot to say about this, but I’ll point out a couple of things:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;There is a seemingly very slight slow down around 100, 1M elements. It’s authentic and repeatable in my tests. I honestly don’t know why it happens, yet. We spend a total of around 1.6μs for every 100 element sort, which might initially sound like not a lot of time, but at 2.8Ghz, that amounts to ~4500 cycles give or take. For the case of 1M elements, this phenomenon is even more peculiar; But such is life.&lt;/li&gt;
    &lt;li&gt;Otherwise, there is an improvement, even if modest, of roughly 2%-4% for most cases. it does look like this version of our code is better, in the end of the day.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;One interesting question that I personally did not know the answer to beforehand was: would this reduce branch mispredictions? There’s no reason to expect this since our input data, being random, is driving the outcome of this branch. However, if I’ve learned one thing throughout this long ordeal, is that there are always things you don’t even know that you don’t know. Any way of verifying our pet-theories is a welcome opportunity at learning some humility.&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;Let’s fire up &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; to inspect what its counters tell us about the two versions (each result is in a separate tab below):&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#123fd8ba-23ef-4144-b66c-871bc8f5aa58'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; CutOff@40&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; SimpleBranch&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;123fd8ba-23ef-4144-b66c-871bc8f5aa58&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ COMPlus_PerfMapEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; branch-misses &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    ./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpMicroOptCutOff_40 &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 1000000 &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt;
...
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-15&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Samples: 403K of event 'branch-misses'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Event count (approx.): 252554012&lt;/span&gt;
    43.73%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... DoublePumpMicroOptCutoff_40::InsertionSort&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;...&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    25.51%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... DoublePumpMicroOptCutoff_40+VxSortInt32::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;...&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ COMPlus_PerfMapEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; branch-misses &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    ./Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpSimpleBranch &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 1000000 &lt;span class=&quot;nt&quot;&gt;--no-check&lt;/span&gt;
...
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-15&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Samples: 414K of event 'branch-misses'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Event count (approx.): 241513903&lt;/span&gt;
    41.11%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... DoublePumpSimpleBranch::InsertionSort&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;...&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    26.59%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... DoublePumpSimpleBranch+VxSortInt32::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;...&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;


&lt;/div&gt;

  &lt;p&gt;Here we’re comparing the same two versions we’ve just benchmarked with a specific focus on the branch-misses HW counter. We can take this oppertunity both to appreciate how these results compare to the ones we recorded at the end of the previous post,
as well as how they compare to each other.&lt;/p&gt;

  &lt;p&gt;Compared to our &lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpedNaive&lt;/code&gt; implementation of yester-post, it would appear that the “burden of guilt” when it comes to branch mispredictions has shifted towards &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; by 3-4%. This is to be expected: We were using a cut-off point of &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt; previously, and we’ve just upped it to &lt;code class=&quot;highlighter-rouge&quot;&gt;40&lt;/code&gt; in the previous section, so it makes sense for &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; to perform more work in this new balance, taking a larger share of the branch-misses.&lt;/p&gt;

  &lt;p&gt;When comparing between the &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/AVX2/Happy/B4_2_DoublePumpMicroOptCutoff.cs#L798&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpMicroOptCutOff_40&lt;/code&gt;&lt;/a&gt; and the &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/AVX2/Happy/B4_3_DoublePumpSimpleBranch.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpSimpleBranch&lt;/code&gt;&lt;/a&gt; versions, that differ only in that nasty branch in the top of our main loop, both versions look mostly similar. First, we have to acknowledge that &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; is a statistical tool, that works by collecting samples of HW counters, so we’re not going to get an exact count of anything, even when running the same code time after time. In our case, both versions look roughly the same: Once we count how many branch misses of the total are attributed to the function we actually changed, it comes to &lt;code class=&quot;highlighter-rouge&quot;&gt;64,426,528&lt;/code&gt; misses for the previous version vs. &lt;code class=&quot;highlighter-rouge&quot;&gt;64,218,546&lt;/code&gt; for the newer simpler branch. It doesn’t amount to enough to call this a branch misprediction win. So it would seem with gained a bit with smaller code, but not by lowering the frequency of mispredictions.&lt;/p&gt;

&lt;/div&gt;

&lt;h3 id=&quot;packing-the-permutation-table-1st-attempt-1&quot;&gt;Packing the Permutation Table, 1&lt;sup&gt;st&lt;/sup&gt; attempt: :+1:&lt;/h3&gt;

&lt;p&gt;Ever since I started with this little time-succubus of a project, I was really annoyed at the way I was encoding the permutation tables. To me, wasting 8kb worth of data, or more specifically, wasting 8kb worth of precious L1 cache in the CPU for the permutation entries was tantamount to a cardinal sin. My emotional state set aside, the situation is even more horrid when you stop to consider that out of each 32-byte permutation entry, we were only really using 3 bits x 8 elements, or 24 bits of usable data. To be completely honest, I probably made this into a bigger problem in my head, imagining how the performance was suffering from this, than what it really is in reality, but we don’t always get to choose our made-up enemies. sometimes they choose us.&lt;/p&gt;

&lt;p&gt;My first attempt at packing the permutation entries was to try and use a specific Intel intrinsic called &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx2.converttovector256int32?view=netcore-3.1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertToVector256Int32&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;VPMOVZXBD&lt;/code&gt;&lt;/a&gt;. This intrinsic can read a 64-bit value directly from memory while also expanding it into 8x32bit values inside a &lt;code class=&quot;highlighter-rouge&quot;&gt;Vactor256&amp;lt;T&amp;gt;&lt;/code&gt; register. If nothing else, it buys me an excuse to do this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/yodawg.jpg&quot; alt=&quot;Yo Dawg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;More seriously though, the basic idea was that I would go back to the permutation entries and re-encode them as 64-bits (8x8bits) per single entry instead of 256-bits which is what I’ve been using thus far. This encoding would reduce the size of the entire permutation entry from 8kb to 2kb, which is a nice start.&lt;br /&gt;
Unfortunately, this initial attempt went south as I got hit by a &lt;a href=&quot;https://github.com/dotnet/runtime/issues/12835&quot;&gt;JIT bug&lt;/a&gt;. When I tried to circumvent that bug, the results didn’t look better, they were slightly worse, so I kind of left the code in a sub-optimal state and forgot about it. Luckily, I did revisit this at a later stage, after the bug was fixed, and to my delight, once the JIT was encoding this instruction correctly and efficiently, things start working smoothly.&lt;/p&gt;

&lt;p&gt;I ended up encoding a second permutation table, and by using the correct &lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertToVector256Int32&lt;/code&gt; we are kind of better off:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#057c19d6-b6ca-48e8-942e-5115c37b39cc'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N (Intel)&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N (AMD)&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks (Intel)&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks (AMD)&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;057c19d6-b6ca-48e8-942e-5115c37b39cc&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
SimpleBranch,1,1,1,1,1,1
Packed Intel,1.013605442,1.016909534,1.001868534,0.984072719,0.997337839,0.997892526
Packed AMD,0.896395352,0.813863407,0.919215529,0.916898529,0.926463363,0.981186383

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(0,113,197,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(237,28,36,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 3	}
  }  
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Packed Permutation Table Sorting - Scaled to SimpleBranch&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.80, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,
SimpleBranch,16.1715,20.1069,24.2436,25.7728,24.4249,26.6617
Packed,16.3927,20.4471,24.2889,25.3623,24.3599,26.6055

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  {     
    &quot;backgroundColor&quot;: &quot;rgba(0,113,197,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 SimplerBranch + Packed - log(Time/N) on Intel&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15.0,
          &quot;max&quot;: 27,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,
SimpleBranch,10.1852,13.3196,18.9534,22.6299,23.7335,24.3677
Packed,9.13,10.7383,18.8766,20.7494,21.9882,23.9092


&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(237,28,36,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 SimplerBranch + Packed - log(Time/N) on AMD&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 8.0,
          &quot;max&quot;: 26,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_4_Int32_-report.datatable.intel.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[5, 10, 15, 20]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_4_Int32_-report.datatable.amd.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[5, 10, 15, 20]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;These results bring a new, unwarranted dimension into our lives: CPU vendors and model-specific quirks. Up until now, I’ve been testing my various optimizations on three different processors models I had at hand: Intel Kaby Lake, Intel Broadwell, and AMD Ryzen. Every attempt I’ve presented here netted positive results on all three test beds, even if differently, so I opted for focusing on the Intel Kaby-Lake results to reduce the information overload.&lt;br /&gt;
Now is the first time we see uneven results: the two results I included represent two extremes of the performance spectrum; The newer Intel Kaby-Lake processors are not affected by this optimization. When I set out to implement it, I came into this with eyes wide-open: I knew that all in all, the CPU would roughly be doing the same work for the permutation entry loading per-se. I was gunning for a 2&lt;sup&gt;nd&lt;/sup&gt; order effect: Freeing up 6KB of L1 data-cache is no small saving, given its total size is 32KB in all of my tested CPUs.&lt;/p&gt;

  &lt;p&gt;What we see from the Intel Kaby-Lake results can basically be summarised as: Newer Intel CPUs &lt;em&gt;probably&lt;/em&gt; have a very efficient prefetch unit. One that performs well enough that we can’t feel or see the benefit of having more L1 room afforded by packing the permutation table more tightly. With AMD CPUs, and older Intel CPUs (Like Intel Broadwell, not shown here), freeing up the L1 cache does make a substantial dent in the total runtime.&lt;/p&gt;

  &lt;p&gt;All in all, while this is a slightly more complex scenario to reason about, we’re left with one, rather new CPU that is not affected by this optimization for better and for worse, and other, older/different CPUs where this is a very substantial win. As such, I decided to keep it in the code-base going forward.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;packing-the-permutation-table-2nd-attempt--1&quot;&gt;Packing the Permutation Table, 2&lt;sup&gt;nd&lt;/sup&gt; attempt: :-1:&lt;/h3&gt;

&lt;p&gt;Next, I tried to pack the permutation table even further, going from 2kb to 1kb of memory, by packing the 3-bit entries even further into a single 32-bit value.
The packing is the easy part, but how would we unpack these 32-bit compressed entries all the way back to a full 256-bit vector? Why, with yet more intrinsics of course. 
With this, my ultra packed permutation table now looked like this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;ReadOnlySpan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitPermTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10001000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11000110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11111010&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 0&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b01100011&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b01111101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b01000100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 7&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00010000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10011101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11110101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 170&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10001000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11000110&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b11111010&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 255&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And my unpacking code now uses the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.bmi2.x64.parallelbitdeposit?view=netcore-3.1#System_Runtime_Intrinsics_X86_Bmi2_X64_ParallelBitDeposit_System_UInt64_System_UInt64_&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ParallelBitDposit / PDEP&lt;/code&gt;&lt;/a&gt;, which I’ve accidentaly covered in more detail in a &lt;a href=&quot;/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2#pdep---parallel-bit-deposit&quot;&gt;previous post&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetBitPermutation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;magicMask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b00000111_00000111_00000111_00000111_00000111_00000111_00000111_00000111&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ConvertToVector256Int32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Vector128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;CreateScalarUnsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Bmi2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ParallelBitDeposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;magicMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsByte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What does this little monstrosity do exactly? We &lt;strong&gt;pack&lt;/strong&gt; the permutation bits (remember, we just need 3 bits per element, we have 8 elements, so 24 bits per permutation vector in total) into a single 32 bit value, then whenever we need to expand this into a full blown vector, we:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Unpack the 32-bit values into a 64-bit value using &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=pdep&amp;amp;expand=1532,4152&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ParallelBitDeposit&lt;/code&gt;&lt;/a&gt; from the &lt;code class=&quot;highlighter-rouge&quot;&gt;BMI2&lt;/code&gt; intrinsics extensions.&lt;/li&gt;
  &lt;li&gt;Convert (move) the 64-bit value into the lower 64-bits of a 128-bit SIMD register using &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector128.CreateScalarUnsafe&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Go back to using a different variant of &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cvtepi8_epi32&amp;amp;expand=1532&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ConvertToVector256Int32&lt;/code&gt;&lt;/a&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;VPMOVZXBD&lt;/code&gt;) that takes 8-bit elements from a 128-bit wide register and expands them into integers in a 256 bit registers.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In short, we chain 2 extra instructions compared to our 2KB permutation table, but save an additional 1KB of cache. Was it worth it?&lt;br /&gt;
I wish I could say with a complete and assured voice that it was, but the truth is that it had only very little positive effect, if any:&lt;/p&gt;

&lt;p&gt;While we end up saving 1kb of precious L1 cache, the extra instructions end up delaying and costing us more than whatever perf we’re gaining from the extra cache space.&lt;br /&gt;
To make things even worse, I &lt;a href=&quot;https://github.com/dotnet/runtime/issues/786&quot;&gt;later discovered&lt;/a&gt; that with AMD processors, the very same intrinsic I’m relying upon here, &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt;, is some sort of a bastardized instruction. It’s not really an instruction implemented with proper circuitry at the CPU level, but rather implemented as a plain loop inside the processor. As the discussion I linked to shows, it can take hundreds of cycles(!) depending on the provided mask value. For now we can simply chalk this attempt as a failure.&lt;/p&gt;

&lt;h3 id=&quot;skipping-some-permutations--1&quot;&gt;Skipping some permutations: :-1:&lt;/h3&gt;

&lt;p&gt;There are common cases where performing the permutation is completely un-needed. This means that almost the entire permutation block can be skipped:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;No need to load the perutation entry&lt;/li&gt;
  &lt;li&gt;Or perform the permutation&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To be percise, there are exactly 9 such cases in the permutation table, whenever all the &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits are already grouped in the upper (MSB) part of the &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; value in our permutation block, the values are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11111111&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11111110&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11111100&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11111000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11110000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11100000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b11000000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b10000000&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;0b00000000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I thought it might be a good idea to detect those cases. I ended up trying a switch case, and when that failed to speed things up,  comparing the amount of trailing zeros to (&lt;code class=&quot;highlighter-rouge&quot;&gt;8&lt;/code&gt; - population count). While both methods did technically work, the additional branch and associated branch misprediction didn’t make this worth while or yield any positive result. The simpler code which always permutes did just as good if not slightly better.&lt;br /&gt;
Of course, these results have to be taken with a grain of salt, since they depend on us sorting random data. There might be some other situation when such branches are predicted correctly where this could save a lot of cycles. But for now, let’s just drop it and move on…&lt;/p&gt;

&lt;h3 id=&quot;getting-intimate-with-x86-for-fun-and-profit-1&quot;&gt;Getting intimate with x86 for fun and profit: :+1:&lt;/h3&gt;

&lt;p&gt;I know the title sounds cryptic, but x86 is just weird, and I wanted to make sure you’re mentally geared for some weirdness in our journey to squeeze a bit of extra performance. We need to remember that this is a 40+ year-old CISC processor made in an entirely different era:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/your-fathers-lea.svg&quot; alt=&quot;Your Father's LEA&quot; /&gt;&lt;/p&gt;

&lt;p&gt;This last optimization trick I will go over repeats the same speil I’ve been doing throughtout this post: trimming the fat around our code. We’ll try generating slightly denser code in our vectorized block. The idea here is to trigger the JIT to encode the pointer update code at the end of our vectorized partitioning block with the space-efficient &lt;code class=&quot;highlighter-rouge&quot;&gt;LEA&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;To better explain this, we’ll start by going back to the last 3 lines of code I presented at the top of &lt;em&gt;this&lt;/em&gt; post, as part of the so-called micro-optimized version. Here is the C#:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;c1&quot;&gt;// end of partitioning block...&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopCnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;byte&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;8U&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we look at the corresponding disassembly for this code, it looks quite verbose. Here it is with some comments, and with the machine-code bytes on the right-hand side:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;;var popCount = PopCnt.PopCount(mask);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;r8d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;r8d&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; F3450FB8C0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;shl&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;r8d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;; 41C1E002&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;writeRight = (int*) ((byte*) writeRight - popCount);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;r9d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;r8d&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 458BC8&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r9&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; 492BC9&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;;writeLeft  = (int*) ((byte*) writeLeft + (8U &amp;lt;&amp;lt; 2) - popCount);&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;20h&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 4983C420&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;r8d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;r8d&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 458BC0&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; 4D2BE0&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If we count the bytes, everything after the &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; instruction is taking &lt;code class=&quot;highlighter-rouge&quot;&gt;20&lt;/code&gt; bytes in total: &lt;code class=&quot;highlighter-rouge&quot;&gt;4 + 3 + 3 + 4 + 3 + 3&lt;/code&gt; to complete both pointer updates.&lt;/p&gt;

&lt;p&gt;The motivation behind what I’m about to show is that we can replace all of this code with a &lt;strong&gt;much&lt;/strong&gt; shorter sequence, taking advantage of x86’s wacky memory addressing, by tweaking the C# code &lt;em&gt;ever&lt;/em&gt; so slightly. This, in turn, will enable the C# JIT, which is already aware of these x86 shenanigans, and is capable of generating the more compact x86 code, to do so when it encounters the right constructs at the MSIL/bytecode level.&lt;br /&gt;
We succeed here &lt;em&gt;if and when&lt;/em&gt; we end up using one &lt;code class=&quot;highlighter-rouge&quot;&gt;LEA&lt;/code&gt; instruction for each pointer modification.&lt;/p&gt;

&lt;p&gt;What is &lt;code class=&quot;highlighter-rouge&quot;&gt;LEA&lt;/code&gt; you ask? &lt;strong&gt;L&lt;/strong&gt;oad &lt;strong&gt;E&lt;/strong&gt;ffective &lt;strong&gt;A&lt;/strong&gt;ddress is an instruction that exposes the full extent of x86’s memory addressing capabilities in a single instruction. It allows us to encode rather complicated mathematical/address calculations with a minimal set of bytes, abusing the CPUs address generation units (AGU), while storing the result of that calculation back to a register.&lt;/p&gt;

&lt;p&gt;But what can the AGUs do for us? We need to learn just enough about them before we attempt to milk some performance out of them through &lt;code class=&quot;highlighter-rouge&quot;&gt;LEA&lt;/code&gt;. Out of curiosity, I went back in time to find out &lt;em&gt;when&lt;/em&gt; the memory addressing scheme was defined/last changed. To my surprise, I found out it was &lt;em&gt;much later&lt;/em&gt; than what I had originally thought: Intel last &lt;em&gt;expanded&lt;/em&gt; the memory addressing semantics as late as &lt;strong&gt;1986&lt;/strong&gt;! Of course this was later expanded again by AMD when they introduced &lt;code class=&quot;highlighter-rouge&quot;&gt;amd64&lt;/code&gt; to propel x86 from the 32-bit dark-ages into the brave world of 64-bit processing, but that was merely a machine-word expansion, not a functional change. I’m happy I researched this bit of history for this post because I found &lt;a href=&quot;/assets/images/230985-001_80386_Programmers_Reference_Manual_1986.pdf&quot;&gt;this scanned 80386 manual&lt;/a&gt;:&lt;/p&gt;

&lt;center&gt;
&lt;div&gt;
    &lt;p&gt;&lt;a href=&quot;../assets/images/230985-001_80386_Programmers_Reference_Manual_1986.pdf&quot;&gt;&lt;img src=&quot;/assets/images/80386-manual.png&quot; alt=&quot;80386&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/center&gt;

&lt;p&gt;In this reference manual, the “new” memory addressing semantics are described in section &lt;code class=&quot;highlighter-rouge&quot;&gt;2.5.3.2&lt;/code&gt; on page &lt;code class=&quot;highlighter-rouge&quot;&gt;2-18&lt;/code&gt;, reprinted here for some of its 1980s era je ne sais quoi:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/x86-effective-address-calculation-transparent.png&quot; alt=&quot;x86-effective-address-calculation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Figure &lt;code class=&quot;highlighter-rouge&quot;&gt;2-10&lt;/code&gt; in the original manual does a good job explaining the components and machinery that go into a memory address calculation in x86. Here it is together with my plans to abuse it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Segment register: This is an odd over-engineered 32-bit era remnant. It’s mostly never used, so let’s skip it in this context.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Base register&lt;/strong&gt;: This will be our pointer that we want to modify: &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Index&lt;/strong&gt;: Basically some offset to the base: In our case the &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; result, in some form.&lt;br /&gt;
The index has to be &lt;em&gt;added&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;) to the base register. The operation will always be an addition; of course nothing prevents us from adding a negative number…&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Scale&lt;/strong&gt;: The &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; result needs to be multiplied by 4, we’ll do it with the scale.
The scale is &lt;em&gt;limited&lt;/em&gt; to be one of &lt;code class=&quot;highlighter-rouge&quot;&gt;1/2/4/8&lt;/code&gt;, but &lt;em&gt;for us&lt;/em&gt; this is not a limitation, since multiplication by &lt;code class=&quot;highlighter-rouge&quot;&gt;4&lt;/code&gt; is exactly what we need.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Displacement&lt;/strong&gt;: Some other constant we can tack on to the address calculation. The displacement can be 8/32 bits and is also always used with an &lt;em&gt;addition&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;+&lt;/code&gt;) operation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;There’s a key point I need to stress here: while the mathematical operations performed by &lt;code class=&quot;highlighter-rouge&quot;&gt;LEA&lt;/code&gt; are always addition, we can take advantage of how twos-complement addition/subtraction works to effectively turn this so-called addition into a subtraction.&lt;/p&gt;

&lt;p&gt;The actual code change is, for lack of better words, underwhelming. But without all this pre-amble it wouldn’t make a lot of sense, here it is, in all its glory:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopCnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Surely, you must be joking, Mr. @damageboy!, I can almost hear you think, but really, this is it. By casting to long and &lt;em&gt;pre-negating&lt;/em&gt; the &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; result (see that little minus sign?) and reverting back to simpler pointer advancement code, without all the pre-left-shifting pizzaz from the beginning of this post, we get this beautiful, packed, assembly code automatically generated for us:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;  &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;; F3480FB8FF&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;neg&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;                 &lt;span class=&quot;c1&quot;&gt;; 48F7DF&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;lea&lt;/span&gt;     &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;; 488D04B8&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;lea&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;r15&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r15&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;20h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 4D8D7CBF20&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The new version is taking &lt;code class=&quot;highlighter-rouge&quot;&gt;3 + 4 + 5&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;12&lt;/code&gt; bytes in total, to complete both pointer updates. So it’s clearly denser. It is important to point out that this reduces the time taken by the CPU to fetch and decode these instructions. Internally, the CPU still has to perform the same calculations as before. I’ll refrain from digressing into the mechanics of x86’s frontend, backend, and all that jazz, as it is out of scope for this blog post, so let’s just be happy with what we have.&lt;/p&gt;

&lt;p&gt;Before we forget, though, does it improve performance?&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#3cd2c1d5-4b4b-4f73-9603-4b138aef5ef7'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;3cd2c1d5-4b4b-4f73-9603-4b138aef5ef7&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Packed,1,1,1,1,1,1
Jedi,1.013855422,0.938475624,1.00941461,0.992908734,0.955117129,0.96278825

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }  
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Jedi Sorting - Scaled to Packed&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.92, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,
Packed,16.6008,21.8446,24.2283,25.616,25.3775,27.6628
Jedi,16.8279,20.501,24.4564,25.4344,24.2384,26.6334

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,220,33,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Jedi Sorting + Packed - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 28,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_5_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[5, 10, 15, 20]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;All in all, this might not look like much, but it is real: another small 3-4% uneven improvement across the sorting spectrum if you disregard the weirdness around 10K elements. I do realize it may not look super impressive to boot, but here’s a spoiler: a few blog posts down the road, we’ll get to unroll our loops, you know, that place where all optimization efforts end up going. When we do get there, every byte we remove off this main loop body will pay in spades. In other words, while some of the optimizations may appear minor, I have a different metric, at least in my mind, when it comes to improving the loop body even by a single per-cent while we’re still not unrolling it. That’s one of those places where a little experience affords better foresight.&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;I have to come clean here: I’ve left some pennies here on the floor. We could still go one step further and get rid of one more 3-byte instruction in the loop. Alas, I’ve made an executive decision to no do so in this blog post: For one, this post has already become quite long, and I doubt a substantial number of people who have started reading it are still here with us, with a beating pulse. Moreover, this specific optimization that I have in mind would not really shine in this moment. As such, I’ll go back to it once we get to unroll this loop.&lt;/p&gt;

&lt;h2 id=&quot;weve-come-a-long-way-baby&quot;&gt;We’ve Come a Long Way, Baby!&lt;/h2&gt;

&lt;p&gt;We’ve done quite a lot to optimize the vectorized partitioning so far. All these incremental improvements pile up, when you multiply them on top of another.&lt;/p&gt;

&lt;p&gt;Don’t believe me? Here’s one last group of charts and data tables to show what distance we’ve travalled in one blog post:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#95c61e0c-ed74-4a51-9393-6468adfa0452'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;95c61e0c-ed74-4a51-9393-6468adfa0452&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
Naive,1,1,1,1,1,1
Jedi,0.70862069,0.717993202,0.795472874,0.783355194,0.824350492,0.82130157

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(218,165,32,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }  
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 end of Blog Pt. 4 - Scaled to end of Pt. 3&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.65, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,
Naive,23.2032,28.2439,30.9998,32.4093,29.5396,32.2364
Jedi,16.4365,20.2787,24.6595,25.388,24.351,26.4758

&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
  { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(218,165,32,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 60, &quot;hachureGap&quot;: 3	}
  }
  ]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 end of Pt. 4 + end of Pt. 3 - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;min&quot;: 15,
          &quot;max&quot;: 33,
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt4_6_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[5, 10, 15, 20]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;We can see that we’ve managed to trim a lot of excess fat off this little monster of ours. It’s shaping up to be one mean sorting machine, for sure. When comparing to where we were in the end of the previous blog post:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;We have a more pronounced effect for these optimizations in the lower end of the spectrum, cutting down an additional 30% of the runtime for anything below &lt;code class=&quot;highlighter-rouge&quot;&gt;1000&lt;/code&gt; elements.&lt;/li&gt;
    &lt;li&gt;Above &lt;code class=&quot;highlighter-rouge&quot;&gt;1000&lt;/code&gt; elements, we’ve “only” succeeded in reducing the runtime by 20%. Then again, it’s 20% off of tens and hundreds of milliseconds of total runtime, which is nothing to snicker at.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Next up, we’ll have to take on what is a non-trivial problem of dealing with memory alignment, in the scope of a complicated partitioning algorithm like QuickSort.&lt;/p&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">Decimating Array.Sort with AVX2. I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics. There's no reason I should go down alone.</summary></entry><entry><title type="html">This Goes to Eleven (Part. 3/∞)</title><link href="https://bits.houmus.org/2020-01-30/this-goes-to-eleven-pt3" rel="alternate" type="text/html" title="This Goes to Eleven (Part. 3/∞)" /><published>2020-01-30T03:26:28+00:00</published><updated>2020-01-30T03:26:28+00:00</updated><id>https://bits.houmus.org/2020-01-30/this-goes-to-eleven-pt3</id><content type="html" xml:base="https://bits.houmus.org/2020-01-30/this-goes-to-eleven-pt3">&lt;p&gt;Since there’s a lot to go over here, I’ve split it up into a few parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-28/this-goes-to-eleven-pt1&quot;&gt;part 1&lt;/a&gt;, we start with a refresher on &lt;code class=&quot;highlighter-rouge&quot;&gt;QuickSort&lt;/code&gt; and how it compares to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-29/this-goes-to-eleven-pt2&quot;&gt;part 2&lt;/a&gt;, we go over the basics of vectorized hardware intrinsics, vector types, and go over a handful of vectorized instructions we’ll use in part 3. We still won’t be sorting anything.&lt;/li&gt;
  &lt;li&gt;In this part, we go through the initial code for the vectorized sorting, and start seeing some payoff. We finish agonizing courtesy of the CPU’s branch predictor, throwing a wrench into our attempts.&lt;/li&gt;
  &lt;li&gt;In part 4, we go over a handful of optimization approaches that I attempted trying to get the vectorized partitioning to run faster. We’ll see what worked and what didn’t.&lt;/li&gt;
  &lt;li&gt;In part 5, we’ll see how we can almost get rid of all the remaining scalar code- by implementing small-constant size array sorting. We’ll use, drum roll…, yet more AVX2 vectorization.&lt;/li&gt;
  &lt;li&gt;Finally, in part 6, I’ll list the outstanding stuff/ideas I have for getting more juice and functionality out of my vectorized code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;unstable-vectorized-partitioning--quicksort&quot;&gt;Unstable Vectorized Partitioning + QuickSort&lt;/h2&gt;

&lt;p&gt;It’s time we mash all the new knowledge we picked up in the last posts about SIMD registers, instructions, and &lt;code class=&quot;highlighter-rouge&quot;&gt;QuickSort&lt;/code&gt;ing into something useful. Here’s the plan:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Vectorized in-place partitioning:
    &lt;ul&gt;
      &lt;li&gt;First, we learn to take 8-element blocks, or units of &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt;, and partition them with AVX2 intrinsics.&lt;/li&gt;
      &lt;li&gt;Then we take Berlin: We reuse our block to partition an entire array with a method I named double-pumping, suitable for processing large arrays in-place with this vectorized block.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Once we’ve covered vectorized partitioning, we finish up with some innocent glue-code wrapping the whole thing to look like a proper &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; replacement.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now that we’re doing our own thing, finally, It’s time to address a baby elephant hiding in the room: Stable vs. Unstable sorting. I should probably bother explaining: One possible way to categorize sorting algorithms is with respect for their stability: Do they reorder &lt;em&gt;equal&lt;/em&gt; values as they appear in the original input data or not. Stable sorting does not reorder, while unstable sorting provides no such guarantee.&lt;br /&gt;
Stability &lt;em&gt;might&lt;/em&gt; be critical for certain tasks, for example:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;When sorting an array of structs/classes according to a key embedded as a member, while providing a non-default &lt;code class=&quot;highlighter-rouge&quot;&gt;IComparer&amp;lt;T&amp;gt;&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Comparison&amp;lt;T&amp;gt;&lt;/code&gt;, we might care about preserving the order of the containing type.&lt;/li&gt;
  &lt;li&gt;Similarly, when sorting pairs of arrays: keys and values, reordering both arrays according to the sorted order of the keys, while preserving the ordering of values for equal keys.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;At the same time, stable sorting is a non-issue when:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Sorting arrays of simple primitives; stability is meaningless:&lt;br /&gt;
(what would a “stable sort” of the array &lt;code class=&quot;highlighter-rouge&quot;&gt;[7, 7, 7]&lt;/code&gt; even mean?)&lt;/li&gt;
  &lt;li&gt;At other times, we &lt;em&gt;know&lt;/em&gt; for a fact that our keys are unique. There is no unstable sorting for unique keys.&lt;/li&gt;
  &lt;li&gt;Lastly, sometimes, &lt;em&gt;we just don’t care&lt;/em&gt;. We’re fine if our data gets reordered.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In the .NET/C# world, one could say that the landscape regarding sorting is a little unstable (pun intended):&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.array.sort?view=netcore-3.1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;&lt;/a&gt; is unstable, as is clearly stated in the remarks section:&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;On the other hand, &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.linq.enumerable.orderby?view=netcore-3.1&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Enumerable.OrderBy&lt;/code&gt;&lt;/a&gt; is stable:&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;This method performs a stable sort; that is, if the keys of two elements are equal, the order of the elements is preserved.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general, what I came up with in my full repo/nuget package are algorithms capable of doing both stable and unstable sorting. But with two caveats:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stable sorting is considerably slower than unstable sorting (But still faster than &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;).&lt;/li&gt;
  &lt;li&gt;Stable sorting is less elegant/fun to explain.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Given this new information and the fact that I am only presenting pure primitive sorting anyway, where there is no notion of stability to begin with, for this series, I will be describing my unstable sorting approach. It doesn’t take a lot of imagination to get from here to the stable variant, but I’m not going to address this in these posts. It is also important to note that in general, when there is a doubt if stability is a requirement (e.g., for key/value, &lt;code class=&quot;highlighter-rouge&quot;&gt;IComparer&amp;lt;T&amp;gt;&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparison&amp;lt;T&amp;gt;&lt;/code&gt;, or non-primitive sorting) we should err on the side of safety and go for stable sorting.&lt;/p&gt;

&lt;h3 id=&quot;avx2-partitioning-block&quot;&gt;AVX2 Partitioning Block&lt;/h3&gt;

&lt;p&gt;Let’s start with this “simple” block, describing what we do with moving pictures.&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Hint&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;From here-on, The following icon means I have a thingy that animates:
&lt;object style=&quot;margin: auto; vertical-align: middle;&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/play.svg&quot;&gt;&lt;/object&gt;&lt;br /&gt;
Click/Touch/Hover &lt;b&gt;inside&lt;/b&gt; means: &lt;i class=&quot;glyphicon glyphicon-play&quot;&gt;&lt;/i&gt;&lt;br /&gt;
Click/Touch/Hover &lt;b&gt;outside&lt;/b&gt; means: &lt;i class=&quot;glyphicon glyphicon-pause&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;object class=&quot;animated-border&quot; width=&quot;100%&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/block-unified-with-hint.svg&quot;&gt;&lt;/object&gt;
&lt;p&gt;Here is the same block, in more traditional code form:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Outside any loop, top-level in the function&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MethodImpl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MethodImplOptions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AggressiveInlining&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                  &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dataPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MoveMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;CompareGreaterThan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsSingle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PermuteVar8x32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PermTablePtr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;popCount&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopCnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;There’s a lot of cheese here; let’s break this down:&lt;/p&gt;

  &lt;div class=&quot;divTable&quot;&gt;
&lt;div class=&quot;divTableBody&quot;&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L1&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;Broadcast the pivot value to a vector I’ve named &lt;code class=&quot;highlighter-rouge&quot;&gt;P&lt;/code&gt;. We’re merely creating 8-copies of the selected pivot value in a SIMD register.&lt;br /&gt;
Technically, this isn’t really part of the block as this is this happens only &lt;em&gt;once&lt;/em&gt; per partitioning function call! It’s included here for context.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L3-5&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;We wrap our block in a static function. We aggressively inline it in strategic places throughout the rest of the code.&lt;br /&gt;
This may look like an odd signature, but think of its purpose: We avoid copy-pasting codemwhile also avoiding any performance penalty.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L6&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;Load up data from somewhere in our array. &lt;code class=&quot;highlighter-rouge&quot;&gt;dataPtr&lt;/code&gt; points to some unpartitioned data. &lt;code class=&quot;highlighter-rouge&quot;&gt;dataVec&lt;/code&gt; will be loaded with data we intend to partition, and that’s the important bit.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L7-8&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;Perform an 8-way comparison using &lt;code class=&quot;highlighter-rouge&quot;&gt;CompareGreaterThan&lt;/code&gt;, then proceed to convert/compress the 256-bit result into an 8-bit value using the &lt;code class=&quot;highlighter-rouge&quot;&gt;MoveMask&lt;/code&gt; intrinsic.&lt;br /&gt;
The goal here is to generate a &lt;strong&gt;scalar&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; value, that contains a single &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bit for every comparison where the corresponding data element was &lt;em&gt;greater-than&lt;/em&gt; the pivot value and &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; bits for all others. If you are having a hard time following &lt;em&gt;why&lt;/em&gt; this does this, you need to head back to the &lt;a href=&quot;/2020-01-29/this-goes-to-eleven-pt2&quot;&gt;2&lt;sup&gt;nd&lt;/sup&gt; post&lt;/a&gt; and read up on these two intrinsics/watch their animations.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L9-10&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;Permute the loaded data according to a permutation vector; A-ha! A twist in the plot!&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; contains 8 bits, from LSB to MSB describing where each element belongs to (left/right). We could, of course, loop over those bits and perform 8 branches to determine which side each element belongs to, but that would be a terrible mistake. Instead, we’re going to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; as an &lt;em&gt;index&lt;/em&gt; into a lookup-table for permutation values!&lt;br /&gt;
This is one of the reasons it was critical to use &lt;code class=&quot;highlighter-rouge&quot;&gt;MoveMask&lt;/code&gt; in the first place. Without it, we would not have a scalar value we could use as an index to our table. Pretty neat, no?&lt;br /&gt;
With the permutation operation done, we’ve grouped all the &lt;em&gt;smaller-or-equal&lt;/em&gt; than values on one side of our &lt;code class=&quot;highlighter-rouge&quot;&gt;dataVec&lt;/code&gt; vector (the “left” side) and all the &lt;em&gt;greater-than&lt;/em&gt; values on the other side (the “right” side).&lt;br /&gt;
I’ve comfortably glanced over the actual values in the permutation lookup-table which &lt;code class=&quot;highlighter-rouge&quot;&gt;PermTablePtr&lt;/code&gt; is pointing to; I’ll address this a couple of paragraphs below.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

  &lt;p&gt;Partitioning is now practically complete: That is, our &lt;code class=&quot;highlighter-rouge&quot;&gt;dataVec&lt;/code&gt; vector is neatly partitioned. Except that that data is still “stuck” inside our vector. We need to write its contents back to memory. Here comes a small complication: Our &lt;code class=&quot;highlighter-rouge&quot;&gt;dataVec&lt;/code&gt; vector now contains values belonging &lt;em&gt;both&lt;/em&gt; to the left and right sides of the original array. We did separate them &lt;strong&gt;within&lt;/strong&gt; the vector, but we’re not done until each side is written back to memory, on both ends of our array.&lt;/p&gt;

  &lt;div class=&quot;divTable&quot;&gt;
&lt;div class=&quot;divTableBody&quot;&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L11-12&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;Store the permuted vector to both sides of the array. There is no cheap way to write &lt;em&gt;portions&lt;/em&gt; of a vector to each respective end, so we write the &lt;strong&gt;entire&lt;/strong&gt; partitioned vector to both the &lt;em&gt;left&lt;/em&gt; &lt;strong&gt;and&lt;/strong&gt; &lt;em&gt;right&lt;/em&gt; sides of the array.&lt;br /&gt;
At any given moment, we have two write pointers pointing to where we need to write to &lt;strong&gt;next&lt;/strong&gt; on either side: &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt;. How those are initialized and maintained will be dealt with further down where we start calling this block, but for now, let’s assume these pointers initially point to somewhere where it is &lt;strong&gt;safe&lt;/strong&gt; to write &lt;em&gt;at least&lt;/em&gt; an entire &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; and move on.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;divTableRow&quot;&gt;
&lt;div class=&quot;divTableCell&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;L13-15&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;divTableCell&quot;&gt;
          &lt;p&gt;Book-keeping time: We just wrote 8 elements to each side, and each side had a trail of unwanted data tacked to it. We didn’t care for it while we were writing it, because we knew we’re about to update the same write pointers in such a way that the &lt;em&gt;next&lt;/em&gt; writes operations will &lt;strong&gt;overwrite&lt;/strong&gt; the trailing/unwanted data that doesn’t belong to each respective side!&lt;br /&gt;
The vector gods are smiling at us: We have the &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; intrinsic to lend us a hand here. We issue &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; on the same &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; variable (again, &lt;code class=&quot;highlighter-rouge&quot;&gt;MoveMask&lt;/code&gt; was worth its weight in gold here) and get a count of how many bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; were &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;. This accounts for how many values &lt;strong&gt;inside&lt;/strong&gt; the vector were &lt;em&gt;greater-than&lt;/em&gt; the pivot value and belong to the right side.&lt;br /&gt;
This “happens” to be the amount by which we want to &lt;em&gt;decrease&lt;/em&gt; the &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt; pointer (&lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt; is “advanced” by decrementing it, this may seem weird for now, but will become clearer when we discuss the outer-loop!&lt;br /&gt;
Finally, we adjust the &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt; pointer: &lt;code class=&quot;highlighter-rouge&quot;&gt;popCount&lt;/code&gt; contains the number of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits; the number of &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; bits is by definition, &lt;code class=&quot;highlighter-rouge&quot;&gt;8 - popCount&lt;/code&gt; since &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; had 8 bits of content in it, to begin with. This accounts for how many values in the register were &lt;em&gt;less-than-or-equal&lt;/em&gt; the pivot value and grouped on the left side of the register.&lt;/p&gt;
        &lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

  &lt;p&gt;This was a full 8-element wise partitioning block, and it’s worth noting a thing or two about it:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;It is completely branch-less(!): We’ve given the CPU a nice juicy block with no need to speculate on what code gets executed next. It sure looks pretty when you consider the number of branches our scalar code would execute for the same amount of work. Don’t pop a champagne bottle quite yet though, we’re about to run into a wall full of thorny branches in a second, but sure feels good for now.&lt;/li&gt;
    &lt;li&gt;If we want to execute multiple copies of this block, the main dependency from one block to the next is the mutation of the &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt; pointers. It’s unavoidable given we set-out to perform in-place sorting (well, I couldn’t avoid it, maybe you can!), but worth-while mentioning nonetheless. If you need a reminder about how these data-dependencies can change the dynamics of efficient execution, you can read up on when I tried my best to go at it battling with &lt;a href=&quot;/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; to run screaming fast&lt;/a&gt;; If nothing else, you’ll get a clearer understanding of how the CPU extracts data-flows from our code.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;I thought it would be nice to wrap up the discussion of this block by showing off that the JIT is relatively well-behaved in this case with the generated x64 asm:&lt;br /&gt;
Anyone who has followed the C# code can use the intrinsics table from the previous post and read the assembly code without further help. Also, it becomes clear how this is a 1:1 translation of C# code. Congratulations: It’s 2020, and we’re x86 assembly programmers again!&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;vmovd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;xmm1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;r15d&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;; Broadcast&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vbroadcastd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;xmm1&lt;/span&gt;                &lt;span class=&quot;c1&quot;&gt;; pivot&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vlddqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymmword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; load 8 elements&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vpcmpgtd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;; compare&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovmskps&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;; movemask into scalar reg&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;r9d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ecx&lt;/span&gt;                         &lt;span class=&quot;c1&quot;&gt;; copy to r9&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;shl&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;r9d&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x3&lt;/span&gt;                         &lt;span class=&quot;c1&quot;&gt;; *= 8&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vlddqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;r9d&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;; load permutation&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vpermd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;; permute&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymmword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r12&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;; store left&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymmword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;r8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; store right&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ecx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;ecx&lt;/span&gt;                      &lt;span class=&quot;c1&quot;&gt;; popcnt&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;...&lt;/span&gt;                                  &lt;span class=&quot;c1&quot;&gt;; update writeLeft/writeRight pointers&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;permutation-lookup-table&quot;&gt;Permutation lookup table&lt;/h2&gt;

&lt;p&gt;If you made it this far, you are owed an explanation of the permutation lookup table. Let’s see what’s in it:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The table needs to have 2&lt;sup&gt;8&lt;/sup&gt; elements for all possible mask values.&lt;/li&gt;
  &lt;li&gt;Each element ultimately needs to be a &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; because that’s what the permutation intrinsic expects from us, so 8 x 4 bytes = 32 bytes per element.
    &lt;ul&gt;
      &lt;li&gt;That’s a whopping 8kb of lookup data in total (!).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The values inside are &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/TestBlog/PermutationTableTests.cs#L20&quot;&gt;pre-generated&lt;/a&gt; so that they would reorder the data &lt;em&gt;inside&lt;/em&gt; a &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; according to our wishes: all values that got a corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bit in the mask go to one side (right side), and the elements with a &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; go to the other side (left side). There’s no particular required order amongst the grouped elements since we’re merely partitioning around a pivot value, nothing more, nothing less.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here are 4 sample values from the generated permutation table that I’ve copy-pasted so we can get a feel for it:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ReadOnlySpan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PermTable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 0   =&amp;gt; 0b00000000&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 7   =&amp;gt; 0b00000111&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 170 =&amp;gt; 0b10101010&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
    &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;7&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 255 =&amp;gt; 0b11111111&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;ul&gt;
    &lt;li&gt;For &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; values 0, 255 the entries are trivial: All &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; bits were either &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; so there’s nothing we need to do with the data, we just leave it as is, the “null” permutation vector: &lt;code class=&quot;highlighter-rouge&quot;&gt;[0, 1, 2, 3, 4, 5, 6, 7]&lt;/code&gt; achieves just that.&lt;/li&gt;
    &lt;li&gt;When &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;0b00000111&lt;/code&gt; (decimal 7), the 3 lowest bits of the &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; are &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, they represent elements that need to go to the right side of the vector (e.g., elements that were &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt; pivot&lt;/code&gt;), while all other values need to go to the left (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;= pivot&lt;/code&gt;). The permutation vector: &lt;code class=&quot;highlighter-rouge&quot;&gt;[3, 4, 5, 6, 7, 0, 1, 2]&lt;/code&gt; does just that.&lt;/li&gt;
    &lt;li&gt;The checkered bit pattern for the &lt;code class=&quot;highlighter-rouge&quot;&gt;mask&lt;/code&gt; value &lt;code class=&quot;highlighter-rouge&quot;&gt;0b10101010&lt;/code&gt; (decimal 170) calls to move all the even elements to one side and the odd elements to the other… You can see that &lt;code class=&quot;highlighter-rouge&quot;&gt;[0, 2, 4, 6, 1, 3, 5, 7]&lt;/code&gt; does the work here.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--warning&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label uk-label-warning&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;&lt;div&gt;
          &lt;p&gt;The permutation table signature provided here is technically a lie: The &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/PermutationTables/Int32PermTables.cs#L12&quot;&gt;actual code&lt;/a&gt; uses &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt; as the table’s type, with the &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; values encoded as individual bytes in little-endian encoding. This is a C# 7.3 specific optimization where we get to treat the address of this table as a constant at JIT time. Kevin Jones (&lt;a href=&quot;https://twitter.com/vcsjones&quot;&gt;@vcsjones&lt;/a&gt;) did a wonderful job of &lt;a href=&quot;https://vcsjones.dev/2019/02/01/csharp-readonly-span-bytes-static/&quot;&gt;digging into it&lt;/a&gt;.&lt;br /&gt;
We &lt;strong&gt;must&lt;/strong&gt; use a &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt; for the optimization to trigger: Not reading &lt;em&gt;that&lt;/em&gt; fine-print cost me two nights of my life chasing what I was &lt;em&gt;sure&lt;/em&gt; had to be a GC/JIT bug. Normally, it would be a &lt;strong&gt;bad&lt;/strong&gt; idea to store a &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlySpan&amp;lt;int&amp;gt;&lt;/code&gt; as a &lt;code class=&quot;highlighter-rouge&quot;&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt;: we are forced to choose between little/big-endian encoding &lt;em&gt;at compile-time&lt;/em&gt;. This runs up against the fact that in C# we compile once and debug (and occasionally run :) everywhere. Therefore, we have to &lt;em&gt;assume&lt;/em&gt; our binaries might run on both little/big-endian machines where the CPU might not match the encoding we chose.&lt;br /&gt;
&lt;strong&gt;In this case&lt;/strong&gt;, praise the vector deities, blessed be their name and all that they touch, this is a &lt;em&gt;non-issue&lt;/em&gt;: The entire premise is &lt;strong&gt;x86&lt;/strong&gt; specific. This means that this code will &lt;strong&gt;never&lt;/strong&gt; run on a big-endian machine. We can simply assume little endianness here till the end of all times.&lt;/p&gt;
        &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;/div&gt;

&lt;p&gt;We’ve covered the basic layout of the permutation table. We’ll go back to it once we start optimization efforts in earnest on the 4&lt;sup&gt;th&lt;/sup&gt; post, but for now, we can move on to the loop surrounding our vectorized partition block.&lt;/p&gt;

&lt;h2 id=&quot;double-pumped-loop&quot;&gt;Double Pumped Loop&lt;/h2&gt;

&lt;p&gt;Armed with a vectorized partitioning block, it’s time to hammer our unsorted array with it, but there’s a wrinkle: In-place sorting. This brings a new challenge to the table: If you followed the previous section carefully, you might have noticed it already. For every &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; we read, we ended up writing that same vector twice to both ends of the array. You don’t have to be a math wizard to figure out that if we end up writing 16 elements for every 8 we read, that doesn’t sound very in-placy, to begin with. Moreover, this extra writing would have to overwrite data that we have &lt;em&gt;not read yet&lt;/em&gt;.&lt;br /&gt;
Initially, it would seem, we’ve managed to position ourselves between a rock and a hard place.&lt;/p&gt;

&lt;p&gt;But all is not lost! In reality, we immediately adjust the next write positions on both sides in such a way that their &lt;strong&gt;sum&lt;/strong&gt; advances by 8. In other words, we are at risk of overwriting unread data only temporarily while we store the data back. I ended up adopting a tricky approach: We will need to continuously make sure we have at least 8 elements (the size of our block) of free space on &lt;em&gt;both&lt;/em&gt; sides of the array so we could, in turn, perform a full, efficient 8-element write to both ends without overwriting a single bit of data we haven’t read yet.&lt;/p&gt;

&lt;p&gt;Here’s a visual representation of the mental model I was in while debugging/making this work (I’ll note I had the same facial expressions as this poor Charmander while writing and debugging that code):&lt;/p&gt;

&lt;video controls=&quot;&quot; playsinline=&quot;&quot; loop=&quot;&quot; preload=&quot;auto&quot; width=&quot;100%&quot;&gt;
    &lt;source src=&quot;../talks/intrinsics-sorting-2019/fire.webm&quot; type=&quot;video/webm&quot; /&gt;
    &lt;source src=&quot;../talks/intrinsics-sorting-2019/fire.mp4&quot; type=&quot;video/mp4&quot; /&gt;
    &lt;img src=&quot;../talks/intrinsics-sorting-2019/fire.gif &quot; alt=&quot;&quot; /&gt;
&lt;/video&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;Funny, right? It’s closer to what I actually do than I’d like to admit! I fondly named this approach in my code as “double-pumped partitioning”. It pumps values in-to/out-of &lt;strong&gt;both&lt;/strong&gt; ends of the array at all times. I’ve left it pretty much intact in the repo under the name &lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/AVX2/Happy/00_DoublePumpNaive.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpNaive&lt;/code&gt;&lt;/a&gt;, in case you want to dig through the full code. Like all good things in life, it comes in 3-parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Prime the pump (make some initial room inside the array).&lt;/li&gt;
  &lt;li&gt;Loop over the data in 8-element chunks executing our vectorized code block.&lt;/li&gt;
  &lt;li&gt;Finally, go over the last remaining data elements (e.g. the last remaining &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; 8&lt;/code&gt; block of unpartitioned data) and partition them using scalar code. This is a very common and unfortunate pattern we find in vectorized code, as we need to finish off with just a bit of scalar work.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let’s start with another visual aid I ended up doing to better explain this; note the different color codes and legend I’ve provided here, and try to watch a few loops noticing the various color transitions, this will become useful as you parse the text and code below:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
    &lt;object class=&quot;animated-border&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/double-pumped-loop-with-hint.svg&quot;&gt;&lt;/object&gt;
  &lt;/div&gt;
  &lt;object style=&quot;margin-top: 2em&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/double-pumped-loop-legend.svg&quot;&gt;&lt;/object&gt;

  &lt;ul&gt;
    &lt;li&gt;Each rectangle is 8-elements wide.
      &lt;ul&gt;
        &lt;li&gt;Except for the middle one, which represents the last group of up to 8 elements that need to be partitioned. This is often called in vectorized parlance the “remainder problem”.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;We want to partition the entire array, in-place, or turn it from &lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color: #db9d00ff&quot;&gt;orange&lt;/span&gt; into the green/red colors:
      &lt;ul&gt;
        &lt;li&gt;&lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color: #bbe33d&quot;&gt;Green&lt;/span&gt;: for smaller-than-or-equal to the pivot values, on the left side.&lt;/li&gt;
        &lt;li&gt;&lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color: #c9211e; color: white&quot;&gt;Red&lt;/span&gt;: for greater-than-or-equal the pivot values, on the right side.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Initially we “prime the pump”, or make some room inside the array, by partitioning into some temporary memory, marked as the 3x8-element blocks in &lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color: #f67eec&quot;&gt;purple&lt;/span&gt;:
      &lt;ul&gt;
        &lt;li&gt;We allocate this temporary space somewhere on the stack; We’ll discuss why this isn’t really a big deal below.&lt;/li&gt;
        &lt;li&gt;We read one vector’s worth of elements from the left and execute our partitioning block into the temporary space.&lt;/li&gt;
        &lt;li&gt;We repeat the process for the right side.&lt;/li&gt;
        &lt;li&gt;At this stage, one vector on each edge has already been partitioned, and their color is now &lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color:#b2b2b2ff&quot;&gt;gray&lt;/span&gt;, which represents data/area within our array we can freely &lt;em&gt;write&lt;/em&gt; into.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;From here-on, we’re in the main loop: this could go on for millions of iterations, even though in this animation we only see 4 iterations in total:
      &lt;ul&gt;
        &lt;li&gt;In every round, we &lt;em&gt;choose&lt;/em&gt; where we read from next: From the left &lt;em&gt;-or-&lt;/em&gt; right side of the &lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color: #db9d00ff&quot;&gt;orange&lt;/span&gt; area?&lt;br /&gt;
How? Easy-peasy: Whichever side has a &lt;strong&gt;smaller&lt;/strong&gt; &lt;span style=&quot;padding: 1px; border: 1px solid black; border-radius: 2px; background-color:#b2b2b2ff&quot;&gt;gray&lt;/span&gt; area!
          &lt;ul&gt;
            &lt;li&gt;&lt;em&gt;Intuition&lt;/em&gt;: The gray area represents the distance between the head (read) and tail (write) pointers we set up for each side, the smaller the distance/area is, the more likely that our next 8-element partition &lt;em&gt;might&lt;/em&gt; end with us overwriting that side’s head with the tail.&lt;/li&gt;
            &lt;li&gt;&lt;strong&gt;We really don’t want that to happen…&lt;/strong&gt;&lt;/li&gt;
            &lt;li&gt;We read from the only side &lt;em&gt;where this might happen next&lt;/em&gt;, thereby adding 8 more elements of breathing space to that side just in time before we cause a meltdown. (you can see this clearly in the animation as each orange block turns gray &lt;em&gt;after&lt;/em&gt; we read it, &lt;em&gt;but before&lt;/em&gt; we write to both sides…)&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
        &lt;li&gt;We partition the data inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; we just read and write it to the next write position on each side.&lt;/li&gt;
        &lt;li&gt;We advance each write pointer according to how much of that register was red/green, we’ve discussed the how of it when we toured the vectorized block. Here you can see the end result reflected in how the red portion of the written copy on the left-hand side turns into gray, and the green portion on the right-hand side turns into gray correspondingly.&lt;br /&gt;
&lt;strong&gt;Remember&lt;/strong&gt;: We’ve seen the code in detail when we previously discussed the partitioning block; I repeat it here since it is critical for understanding how the whole process clicks together.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;For the finishing touch:
      &lt;ul&gt;
        &lt;li&gt;Left with less than 8 elements, we partition with plain old scalar code the few remaining elements, into the temporary memory area again.&lt;/li&gt;
        &lt;li&gt;We copy back each side of the temporary area back to the main array, and we’re done!&lt;/li&gt;
        &lt;li&gt;We move the pivot value that was left untouched all this time on the right edge of our segment and move it to where the new boundary is.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Let’s go over it again, in more detail, this time with code:&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;setup-make-some-room&quot;&gt;Setup: Make some room!&lt;/h3&gt;

&lt;p&gt;What I eventually opted for was to read from &lt;em&gt;one&lt;/em&gt; area and write to &lt;em&gt;another&lt;/em&gt; area in the same array. But we need to make some spare room inside the array for this. How?&lt;/p&gt;

&lt;p&gt;We cheat! (¯\&lt;em&gt;(ツ)&lt;/em&gt;/¯), but not really: we allocate some temporary space on stack, by using the relatively new &lt;code class=&quot;highlighter-rouge&quot;&gt;ref struct&lt;/code&gt; feature in C# in combination with &lt;code class=&quot;highlighter-rouge&quot;&gt;fixed&lt;/code&gt; arrays, here’s why this isn’t really cheating in any reasonable person’s book:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stack allocation doesn’t put pressure on the GC, and its allocation is super fast/slim.&lt;/li&gt;
  &lt;li&gt;We allocate &lt;em&gt;once&lt;/em&gt; at the top of our entire sort operation and reuse that space while recursing.&lt;/li&gt;
  &lt;li&gt;“Just a bit” is really just a bit: For our 8-element partition block we need room for 1 x 8-elements vector on &lt;strong&gt;each&lt;/strong&gt; side of the array, so we allocate a total of 2 x 8 integers. In addition, we allocate 8 more elements for handling the remainder (well technically, 7 would be enough, but I’m not a monster, I like round numbers just like the next person), so a total of 96 bytes. Not too horrid.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Here’s the signature + setup code:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;VectorizedPartitionInPlace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Treated by JIT as constant!&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;          &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;The function accepts two parameters: &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; pointing to the edges of the partitioning task we were handed. The selected pivot is “passed” in an unconventional way: the caller (The top-level sort function) is responsible for &lt;strong&gt;moving&lt;/strong&gt; it to the right edge of the array before calling the partitioning function. In other words, we start executing the function expecting the pivot to be already selected and placed at the right edge of the segment (e.g., &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; points to it). This is a remnant of my initial copy-pasting of CoreCLR code, and to be honest, I don’t care enough to change it.&lt;/p&gt;

  &lt;p&gt;We start by setting up various pointers we’ll be using on &lt;span class=&quot;uk-label&quot;&gt;L5-8&lt;/span&gt;: The &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt; pointers pointing into the internal edges of our array (excluding the last element which is pointing to the selected pivot), while the &lt;code class=&quot;highlighter-rouge&quot;&gt;tmpLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tmpRight&lt;/code&gt; pointers are pointing into the internal edges of the temporary space.&lt;br /&gt;
One recurring pattern is that the right-side pointers are pointing on vector’s worth on elements &lt;strong&gt;left&lt;/strong&gt; of their respective edge. This makes sense given that we will be using vectorized write operations that take a pointer to memory and write 8 elements at a time; the pointers are setup accounting for that assymetry.&lt;/p&gt;

  &lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;&lt;div&gt;
          &lt;p&gt;I’m using a “variable” (&lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;) on &lt;span class=&quot;uk-label&quot;&gt;L3&lt;/span&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;.Count&lt;/code&gt;. There’s a reason for those double quotes: At JIT time, the right-hand expression is considered as a constant as far as the JIT is concerned. Furthermore, once we initialize N with its value and &lt;em&gt;never&lt;/em&gt; modify it, the JIT treats N as a constant as well! So really, I get to use a short/readable name and pay no penalty in for it.&lt;/p&gt;
        &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

  &lt;p&gt;We proceed to partition a single 8-element vector on &lt;em&gt;each&lt;/em&gt; side on &lt;span class=&quot;uk-label&quot;&gt;L13-14&lt;/span&gt;, with our good-ole’ partitioning block &lt;strong&gt;straight into&lt;/strong&gt; that temporary space through the pointers we just setup. It is important to remember that having done that, we don’t care about the original contents of the area we just read from anymore: we’re free to write up to one &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; to each edge of the array in the future. We’ve made enough room inside our array available for writing in-place while partitioning.&lt;/p&gt;

  &lt;p&gt;We finish the setup on &lt;span class=&quot;uk-label&quot;&gt;L16-17&lt;/span&gt; by initializing read pointers for every side (&lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt;); An alternative way to think about these pointers is that each side gets its own head (read) and tail (write) pointers. We will be continuously reading from &lt;strong&gt;one&lt;/strong&gt; of the heads and writing to &lt;strong&gt;both&lt;/strong&gt; tails from now on.&lt;/p&gt;

  &lt;p&gt;The setup ends with &lt;code class=&quot;highlighter-rouge&quot;&gt;readLeft&lt;/code&gt; pointing a single &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; &lt;em&gt;right&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;left&lt;/code&gt; , and &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt; pointing 1 element + 2x&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; &lt;em&gt;left&lt;/em&gt; of &lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt;. The setup of &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt; might initially seem peculiar, but easily explained:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;right&lt;/code&gt; itself points to the selected pivot; we’re not going to (re-)partition it, so we skip that element (this explains the &lt;code class=&quot;highlighter-rouge&quot;&gt;- 1&lt;/code&gt;).&lt;/li&gt;
    &lt;li&gt;As with the &lt;code class=&quot;highlighter-rouge&quot;&gt;tmpRight&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeWrite&lt;/code&gt; pointers, when we read/write using &lt;code class=&quot;highlighter-rouge&quot;&gt;Avx2.LoadDquVector256&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;Avx.Store&lt;/code&gt; we always have to supply the &lt;em&gt;start&lt;/em&gt; address to read from or write to!&lt;br /&gt;
Since There is no ability to read/write to the “left” of the pointer, we pre-decrement that pointer by &lt;code class=&quot;highlighter-rouge&quot;&gt;2*N&lt;/code&gt; to account for the data that was already partitioned and to prepare it for the next read.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;h3 id=&quot;loop&quot;&gt;Loop&lt;/h3&gt;

  &lt;p&gt;Here’s the same loop we saw in the animation with our vectorized block smack in its middle, in plain-old C#:&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;nf&quot;&gt;PartitionBlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nextPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;This is the heart of the partitioning operation and where we spend most of the time sorting the array. Looks quite boring, eh?&lt;/p&gt;

  &lt;p&gt;This loop is all about calling our good ole’ partitioning block on the entire array. We-reuse the same block on &lt;span class=&quot;uk-label&quot;&gt;L11&lt;/span&gt;, but here, for the first time, actually use it as an in-place partitioning block, since we are both reading and writing to the same array.&lt;br /&gt;
While the runtime of the loop is dominated by the partitioning block, the interesting bit is that beefy condition on &lt;span class=&quot;uk-label&quot;&gt;L3&lt;/span&gt; that we described/animated before: it calculates the distance between each head and tail on both sides and compares them to determine which side has less space left, or which side is closer to being overwritten. Given that the &lt;strong&gt;next&lt;/strong&gt; read will happen from the side we choose here, we’ve just added 8 more integers worth of &lt;em&gt;writing&lt;/em&gt; space to that same endangered side, thereby eliminating the risk of overwriting.&lt;br /&gt;
While it might be easy to read in terms of correctness or motivation, this is a very &lt;em&gt;sad line of code&lt;/em&gt;, as it will haunt us in the next posts!&lt;/p&gt;

  &lt;p&gt;Finally, as we exit the loop once there are &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt; 8&lt;/code&gt; elements left (remember that we pre-decremented &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt; by &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; elements before the loop), we are done with all vectorized work for this partitioning call. as such, this is as good a time to re-adjust both &lt;code class=&quot;highlighter-rouge&quot;&gt;readRight&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;tmpRight&lt;/code&gt; that were pre-decremented by &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; elements to make them ready-to-go for the final step of handling the remainder with scalr sorting, on &lt;span class=&quot;uk-label&quot;&gt;L13-14&lt;/span&gt;.&lt;/p&gt;

  &lt;h3 id=&quot;handling-the-remainder-and-finishing-up&quot;&gt;Handling the remainder and finishing up&lt;/h3&gt;

  &lt;p&gt;Here’s the final piece of this function:&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;readRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;*--&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftTmpSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmpLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;CopyBlockUnaligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tmpStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftTmpSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftTmpSize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rightTmpSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_tempEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Unsafe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;CopyBlockUnaligned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tmpRight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rightTmpSize&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;writeLeft&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;Finally, we come out of the loop once we have less than 8-elements to partition (1-7 elements). We can’t use vectorized code here, so we drop to plain-old scalar partitioning on &lt;span class=&quot;uk-label&quot;&gt;L1-8&lt;/span&gt;. To keep things simple, we partition these last elements straight into the temporary area. This is the reason we’re allocating 8 more elements in the temporary area in the first place.&lt;/p&gt;

  &lt;p&gt;Once we’re done with this remainder nuisance, we copy back the already partitioned data from the temporary area back into the array to the area left between &lt;code class=&quot;highlighter-rouge&quot;&gt;writeLeft&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;writeRight&lt;/code&gt;, it’s a quick 64-96 byte copy in two operations, performed &lt;span class=&quot;uk-label&quot;&gt;L10-14&lt;/span&gt; and we are nearly done. We still need to move the pivot &lt;em&gt;back&lt;/em&gt; to the newly calculated pivot position (remember the caller placed it on the right edge of the array as part of pivot selection) and report this position back as the return value for this to be officially be christened as AVX2 partitioning function.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&quot;pretending-were-arraysort&quot;&gt;Pretending we’re Array.Sort&lt;/h2&gt;

&lt;p&gt;Now that we have a proper partitioning function, it’s time to string it into a quick-sort like dispatching function: This will be the entry point to our sort routine:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DoublePumpNaive&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unmanaged&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IComparable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ArgumentNullException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;nameof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;fixed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sorter&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;VxSortInt32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;startPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;sorter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pi&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLACK_PER_SIDE_IN_VECTORS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

  &lt;/div&gt;

  &lt;p&gt;Most of this is pretty dull code:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;We start with a top-level static class &lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpNaive&lt;/code&gt; containing a single &lt;code class=&quot;highlighter-rouge&quot;&gt;Sort&lt;/code&gt; entry point accepting a normal managed array.&lt;/li&gt;
    &lt;li&gt;We special case, relying on generic type elision, for  &lt;code class=&quot;highlighter-rouge&quot;&gt;typeof(int)&lt;/code&gt;, newing up a &lt;code class=&quot;highlighter-rouge&quot;&gt;VxSortInt32&lt;/code&gt; struct and finally calling its internal &lt;code class=&quot;highlighter-rouge&quot;&gt;.Sort()&lt;/code&gt; method to initiate the recursive sorting.
      &lt;ul&gt;
        &lt;li&gt;This is a good time as any to remind, again, that for the time being, I only implemented vectorized sorting when &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;. To fully replace &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt; more tweaked versions of this code will have to be written to eventually support unsigned integers, both larger and smaller than 32 bits as well as floating-point types.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Continuing on to &lt;code class=&quot;highlighter-rouge&quot;&gt;VxSortInt32&lt;/code&gt; itself:&lt;/p&gt;

&lt;/div&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;
    &lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;VxSortInt32&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLACK_PER_SIDE_IN_ELEMENTS&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLACK_PER_SIDE_IN_VECTORS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TMP_SIZE_IN_ELEMENTS&lt;/span&gt;          &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SLACK_PER_SIDE_IN_ELEMENTS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SMALL_SORT_THRESHOLD_ELEMENTS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_startPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;_endPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                      &lt;span class=&quot;n&quot;&gt;_tempStart&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_tempEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;fixed&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TMP_SIZE_IN_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;VxSortInt32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_startPtr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;startPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;_endPtr&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endPtr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;fixed&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pTemp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_temp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_tempStart&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pTemp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;_tempEnd&lt;/span&gt;   &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pTemp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TMP_SIZE_IN_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/div&gt;

  &lt;p&gt;This is where the real top-level sorting entry point for 32-bit signed integers is:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;This struct contains a bunch of constants and members that are initialized for a single sort-job/call and immediately discarded once sorting is complete.&lt;/li&gt;
    &lt;li&gt;There’s a little semingly nasty bit hiding in plain sight there, where we exfiltrate an interior pointer obtained inside a &lt;code class=&quot;highlighter-rouge&quot;&gt;fixed&lt;/code&gt; block and store it for the lifetime of the struct, outside of the &lt;code class=&quot;highlighter-rouge&quot;&gt;fixed&lt;/code&gt; block.
      &lt;ul&gt;
        &lt;li&gt;This is generally a no-no, since, in theory, we don’t have a guarantee that the struct won’t be boxed/stored inside a managed object on a heap where the GC is free to move our memory around.&lt;/li&gt;
        &lt;li&gt;In this case, we &lt;em&gt;are ensuring&lt;/em&gt; that instances of &lt;code class=&quot;highlighter-rouge&quot;&gt;VxSortInt32&lt;/code&gt; are never promoted to the managed heap by declaring it as a &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/ref#ref-struct-types&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ref struct&lt;/code&gt;&lt;/a&gt;.&lt;/li&gt;
        &lt;li&gt;The motivation behind this is to ensure that the &lt;code class=&quot;highlighter-rouge&quot;&gt;fixed&lt;/code&gt; temporary memory resides close to the other struct fields, taking advantage of &lt;a href=&quot;https://en.wikipedia.org/wiki/Locality_of_reference&quot;&gt;locality of reference&lt;/a&gt;.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

&lt;/div&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;        &lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// Go to insertion sort below this threshold&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SMALL_SORT_THRESHOLD_ELEMENTS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nf&quot;&gt;InsertionSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// Compute median-of-three, of:&lt;/span&gt;
            &lt;span class=&quot;c1&quot;&gt;// the first, mid and one before last elements&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;c1&quot;&gt;// Pivot is mid, place it in the right hand side&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Swap&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;VectorizedPartitionInPlace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;nf&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;Sort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;boundary&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;  &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lastly, we have the &lt;code class=&quot;highlighter-rouge&quot;&gt;Sort&lt;/code&gt; method for the &lt;code class=&quot;highlighter-rouge&quot;&gt;VxSortInt32&lt;/code&gt; struct. Most of this is code I blatantly copied for &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/src/System.Private.CoreLib/shared/System/Collections/Generic/ArraySortHelper.cs#L182&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ArraySortHelper&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;. What it does is:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Special case for lengths of 0-3.&lt;/li&gt;
  &lt;li&gt;When length &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;= 16&lt;/code&gt; we just go straight to &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; and skip all the recursive jazz (go back to post 1 if you want to know why &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt; does this).&lt;/li&gt;
  &lt;li&gt;When we have &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;= 17&lt;/code&gt; elements, we go to vectorized partitioning:
    &lt;ul&gt;
      &lt;li&gt;We do median of 3 pivot selection.&lt;/li&gt;
      &lt;li&gt;Swap that pivot so that it resides on the right-most index of the partition.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Call &lt;code class=&quot;highlighter-rouge&quot;&gt;VectorizedPartitionInPlace&lt;/code&gt;, which we’ve seen before.
    &lt;ul&gt;
      &lt;li&gt;We conveniently take advantage of the fact we have &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; to cover us for the small partitions, and our partitioning code can always assume that it can prime the pump with at least two vectors worth of vectorized partitioning without additional checks…&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Recurse to the left.&lt;/li&gt;
  &lt;li&gt;Recurse to the right.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;initial-performance&quot;&gt;Initial Performance&lt;/h2&gt;

&lt;p&gt;Are we fast yet?&lt;/p&gt;

&lt;p&gt;Yes! This is by no means the end, on the contrary, this is only a rather impressive beginning. We finally have something working, and it is even not entirely unpleasant, if I may say so:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#503d6f7d-7740-4997-968f-b1462f12e371'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Stats&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;503d6f7d-7740-4997-968f-b1462f12e371&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
ArraySort,         1   , 1   , 1  , 1   , 1    , 1
DoublePumpedNaive, 1.67, 0.77, 0.6, 0.50, 0.39 , 0.36
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,33,220,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 6	}
  }]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;AVX2 Naive Sorting - Scaled to Array.Sort&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{
       &quot;ticks&quot;: {
         &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
         &quot;min&quot;: 0.2, 
         &quot;callback&quot;: &quot;ticksPercent&quot;
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
ArraySort        , 19.9202, 35.4067, 52.3293, 64.6518, 70.5598, 81.0416
DoublePumpedNaive, 35.4138, 26.9828, 31.5477, 32.1774, 27.8901, 29.4917
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [ { 
    &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 9, &quot;fillWeight&quot;: 0.3	}
  },
  { 
    &quot;backgroundColor&quot;: &quot;rgba(33,33,220,.9)&quot;,
    &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 30, &quot;hachureGap&quot;: 6	}
  }]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;Array.Sort + AVX2 Naive Sorting - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:16}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt3_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;

&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/unmanaged-vs-doublepumpednaive-stats.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;false&quot; data-intro=&quot;Each row in this table contains statistics collected &amp;amp; averaged out of thousands of runs with random data&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;MethodName&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;Method&lt;br /&gt;Name&lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;ProblemSize&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;div data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
            &lt;div class=&quot;rotated-header&quot;&gt;Size&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;MaxDepthScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;The maximal depth of recursion reached while sorting&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Max&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Depth&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumPartitionOperationsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of partitioning operations per sort&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Part&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;itions&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumVectorizedLoadsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of vectorized load operations&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Vector&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Loads&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumVectorizedStoresScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of vectorized store operations&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Vector&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Stores&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumPermutationsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;# of vectorized permutation operations&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Vector&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Permutes&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;AverageSmallSortSizeScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;For hybrid sorting, the average size that each small sort operation was called with (e.g. InsertionSort)&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Small&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Sort&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Size&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumScalarComparesScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;div data-intro=&quot;How many branches were executed in each sort operation that were based on the unsorted array elements&quot; data-position=&quot;top&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Data&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Based&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Branches&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;PercentSmallSortCompares&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-percentage&quot;&gt;
            &lt;div data-intro=&quot;What percent of&amp;lt;/br&amp;gt;⬅&amp;lt;br/&amp;gt;branches happenned as part of small-sorts&quot; data-position=&quot;bottom&quot; class=&quot;rotated-header-container&quot;&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Small&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Sort&lt;/div&gt;
              &lt;div class=&quot;rotated-header&quot;&gt;Branches&lt;/div&gt;
            &lt;/div&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;We’re off to a very good start:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;We can see that as soon as we hit 1000 element arrays (even earlier, in earnest), we already outperform &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; (87% runtime), and by the time we get to 1M / 10M element arrays, we see speed-ups north of 2.5x (39%, 37% runtime) over the scalar C++ code!&lt;/p&gt;
    &lt;/li&gt;
    &lt;li&gt;
      &lt;p&gt;While &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; is behaving like we would expect from a &lt;code class=&quot;highlighter-rouge&quot;&gt;QuickSort&lt;/code&gt;-like function: it is slowing down at rate you’d expect given that it has a Big-O notation of \(\mathcal{O}(n\log{}n)\), our own &lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpedNaive&lt;/code&gt; is peculiar: The time spent sorting every single element starts going up as we increase &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;, then goes down a bit and back up. Huh? It actually improves as we sort more data? Quite unreasonable, unless we remind ourselves that we are executing a mix of scalar insertion sort and vectorized code. Where are we actually spending more CPU cycles though?  We’ll run some profiling sessions in a minute, to get a better idea of what’s going on.&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;If you recall, on the first post in this series, I presented some statistics about is going on inside our sort routine. This is a perfect time to switch to the statistics tab, where I’ve beefed up the table with some vectorized counters that didn’t make sense before with the scalar version. From here we can learn a few interesting facts:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The number of partitioning operations / small sorts is practically the same
      &lt;ul&gt;
        &lt;li&gt;You could ask yourself, or me, why they are not &lt;strong&gt;exactly&lt;/strong&gt; the same?
To which I’d answer:
          &lt;ul&gt;
            &lt;li&gt;The thresholds are 16 vs. 17, which has some effect.&lt;/li&gt;
            &lt;li&gt;We have to remember that the resulting partitions from each implementation end up looking slightly different because of the double pumping + temporary memory shenanigans. Once the partitions look different, the following pivots selected are different, and the entire whole sort mechanic looks slightly different.&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;We are doing a lot of vectorized work:
      &lt;ul&gt;
        &lt;li&gt;Loading two vectors per 8-element(1 data vector + 1 permutation vector)&lt;/li&gt;
        &lt;li&gt;Storing two vectors (left+right) for every vector read&lt;/li&gt;
        &lt;li&gt;In a weird coincidence, this means we perform the same number of vectorized loads and stores for every test case.&lt;br /&gt;
In future posts, I will discard one of these columns to reduce the amount of information load…&lt;/li&gt;
        &lt;li&gt;Finally, lest we forget, we perfom compares/permutations at exactly half of the load/store rate.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;All of this is helping us by reducing the number of scalar comparisons, but there’s still quite a lot of it left too:
      &lt;ul&gt;
        &lt;li&gt;We continue to do scalar partitioning inside &lt;code class=&quot;highlighter-rouge&quot;&gt;VectorizedPartitionInPlace&lt;/code&gt;, as part of handling the remainder that doesn’t fit into a &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt;.&lt;/li&gt;
        &lt;li&gt;We are still executing scalar comparisons as part of small-sorting/inside of the insertion sort at an alarming rate:
          &lt;ul&gt;
            &lt;li&gt;The absolute number of comparisons is quite high: We’re still doing millions of data-based branches.&lt;/li&gt;
            &lt;li&gt;It is also clear from the counters that the overwhelming majority of these are from &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt;: If we focus on the 1M/10M cases here,    we see that &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; went up from attributing 28.08%/24.60% of scalar comparisons in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Unmanaged&lt;/code&gt; (scalar) test-case all the way to 66.4%/62.74% in the vectorized &lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpNaive&lt;/code&gt; version. Of course this rise is merely in percent terms, but clearly we will have to deal with this if we intend to make this thing fast(er).&lt;/li&gt;
          &lt;/ul&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;This is but the beginning of our profiling journey, but we are already learning a complicated truth: Right now, as fast as this is already going, the scalar code we use for insertion sort will always put an upper limit on how fast we can possibly go by optimizing the &lt;em&gt;vectorized code&lt;/em&gt; we’ve gone over so far, &lt;em&gt;unless&lt;/em&gt; we get rid of &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; alltogether, replacing it with something better. But first thing’s first, we must remain focused: 65% of instructions executed are still spent doing vectorized partitioning; That is the biggest target on our scope!&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;As promised, it’s time we profile the code to see what’s really up: We can fire up the venerable Linux &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; tool, through a simple test binary/project I’ve coded up which allows me to execute some dummy sorting by selecting the sort method I want to invoke and specify some parameters for it through the command line, for example:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ~/projects/public/VxSort/Example
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dotnet publish &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; release &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; linux-x64 &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; linux-x64
&lt;span class=&quot;c&quot;&gt;# Run AVX2DoublePumped with 1,000,000 elements x 100 times&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./linux-x64/Example &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpNaive &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 1000000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here we call the &lt;code class=&quot;highlighter-rouge&quot;&gt;DoublePumpedNaive&lt;/code&gt; implementation we’ve been discussing from the beginning of this post with 1M elements, and sort the random data 100 times to generate some heat in case global warming is not cutting it for you.&lt;br /&gt;
I know that calling &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet publish ...&lt;/code&gt; seems superfluous, but trust&lt;sup id=&quot;fnref:0&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:0&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt; me and go with me on this one:&lt;/p&gt;

&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#0022d19b-dd68-4bb7-a13e-8acabcb4c12f'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;1M&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;10K&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;0022d19b-dd68-4bb7-a13e-8acabcb4c12f&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ COMPlus_PerfMapEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; instructions ./Example &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpedNaive &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 1000000
...
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-15&lt;/span&gt;
...
&lt;span class=&quot;c&quot;&gt;# Overhead  Symbol&lt;/span&gt;
    65.66%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
    22.43%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::InsertionSort&lt;span class=&quot;o&quot;&gt;(!!&lt;/span&gt;0&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,!!0&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
     5.43%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::QuickSortInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;OptimizedTier1]
     4.00%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::Memmove&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;uint8&amp;amp;,uint8&amp;amp;,uint64&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;OptimizedTier1]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ COMPlus_PerfMapEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; instructions ./Example &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
       &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; AVX2DoublePumpedNaive &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 10000
...
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-15&lt;/span&gt;
...
&lt;span class=&quot;c&quot;&gt;# Overhead  Symbol&lt;/span&gt;
    54.59%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
    29.87%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::InsertionSort&lt;span class=&quot;o&quot;&gt;(!!&lt;/span&gt;0&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,!!0&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
     7.02%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::QuickSortInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;OptimizedTier1]
     5.23%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ... ::Memmove&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;uint8&amp;amp;,uint8&amp;amp;,uint64&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;OptimizedTier1]
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;p&gt;This is a trimmed summary of &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; session recording performance metrics, specifically: number of instructions executed for running a 1M element sort 100 times, followed by running a 10K element sort, 10K times. I was shocked when I saw this for the first time, but we’re starting to understand the previous oddities we saw with the &lt;code class=&quot;highlighter-rouge&quot;&gt;Time/N&lt;/code&gt; column!&lt;br /&gt;
We’re spending upwards of 20% of our time doing scalar insertion sorting! I lured you here with promises of vectorized sorting and yet, somehow, “only” 65% of the time is spent in doing “vectorized” work (which also has some scalar partitioning, if we’re honest). Not only that, but as the size of the array decreases, the percentage of time spent in scalar code &lt;em&gt;increases&lt;/em&gt; (from 22.43% to 29.87%), which should not surprise us anymore.&lt;br /&gt;
Before anything else, let me clearly state that this is not necessarily a bad thing! As the size of the partition decreases, the &lt;em&gt;benefit&lt;/em&gt; of doing vectorized partitioning decreases in general, and even more so for our AVX2 partitioning, which has non-trivial start-up overhead. We shouldn’t care about the amount of time we’re spending on scalar code per se, but the amount of time taken to sort the entire array.&lt;br /&gt;
The decision to go to with scalar insertion-sort or stick to vectorized code is controlled by the threshold I mentioned before, which is still sitting there at &lt;code class=&quot;highlighter-rouge&quot;&gt;16&lt;/code&gt;. We’re only beginning our optimization phase in the next post, so for now, we’ll stick with the threshold selected for &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; by the CoreCLR developers, this is the “correct” starting point both in terms of allowing us to compare apples-to-apples and also as I am a firm believer at doing very incremental modifications for this sort of work.&lt;br /&gt;
Having said that, this is definitely something we will tweak later for our particular implementation.&lt;/p&gt;

&lt;h2 id=&quot;finishing-off-with-a-sour-taste&quot;&gt;Finishing off with a sour taste&lt;/h2&gt;

&lt;p&gt;I’ll end this post with a not so easy pill to swallow: let’s re-run &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; and measure a different aspect of our code: Let’s see how the code is behaving in terms of top-level performance counters. The idea here is to use counters that our CPU is already capable of collecting at the hardware level, with almost no performance impact, to see where/if we’re hurting. What I’ll do before invoking &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; is use a Linux utility called &lt;a href=&quot;https://github.com/lpechacek/cpuset&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cset&lt;/code&gt;&lt;/a&gt; which can be &lt;a href=&quot;https://stackoverflow.com/a/13076880/9172&quot;&gt;used to&lt;/a&gt; evacuate all user threads and (almost all) kernel threads from a given physical CPU core, using &lt;a href=&quot;https://github.com/torvalds/linux/blob/master/Documentation/admin-guide/cgroup-v1/cpusets.rst&quot;&gt;cpusets&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;cset shield &lt;span class=&quot;nt&quot;&gt;--cpu&lt;/span&gt; 3 &lt;span class=&quot;nt&quot;&gt;-k&lt;/span&gt; on
cset: &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; activating shielding:
cset: moving 638 tasks from root into system cpuset...
&lt;span class=&quot;o&quot;&gt;[==================================================]&lt;/span&gt;%
cset: kthread shield activated, moving 56 tasks into system cpuset...
&lt;span class=&quot;o&quot;&gt;[==================================================]&lt;/span&gt;%
cset: &lt;span class=&quot;k&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; 38 tasks are not movable, impossible to move
cset: &lt;span class=&quot;s2&quot;&gt;&quot;system&quot;&lt;/span&gt; cpuset of CPUSPEC&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;0-2&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; with 667 tasks running
cset: &lt;span class=&quot;s2&quot;&gt;&quot;user&quot;&lt;/span&gt; cpuset of CPUSPEC&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; with 0 tasks running
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we have “shielded” a single CPU core, we execute the &lt;code class=&quot;highlighter-rouge&quot;&gt;Example&lt;/code&gt; binary we used before much in the same way while collecting different top-level hardware statistics from befre using a the following &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; command line:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf &lt;span class=&quot;nb&quot;&gt;stat&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-a&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;--topdown&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;cset shield &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; ./Example &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpedNaive &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 1000000
cset: &lt;span class=&quot;nt&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; last message, executed args into cpuset &lt;span class=&quot;s2&quot;&gt;&quot;/user&quot;&lt;/span&gt;, new pid is: 16107

 Performance counter stats &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'system wide'&lt;/span&gt;:
        retiring      bad speculation       frontend bound        backend bound
...
S0-C3 1    37.6%                32.3%                16.9%                13.2%

       3.221968791 seconds &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;elapsed

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’m purposely showing only the statistics collected for our shielded core since we know we only care about that core in the first place.&lt;/p&gt;

&lt;p&gt;Here are some bad news: core #3 is really not having a good time running our code. &lt;code class=&quot;highlighter-rouge&quot;&gt;perf --topdown&lt;/code&gt; is essentially screaming from the top of its lungs with that &lt;code class=&quot;highlighter-rouge&quot;&gt;32.3%&lt;/code&gt; under the &lt;code class=&quot;highlighter-rouge&quot;&gt;bad speculation&lt;/code&gt; column. This might seem like an innocent metric if you haven’t done this sort of thing before (in which case, read the info box below), but this is &lt;strong&gt;really bad&lt;/strong&gt;. In plain English and &lt;a href=&quot;https://easyperf.net/blog/2019/02/09/Top-Down-performance-analysis-methodology&quot;&gt;without getting into the intricacies of top-down perfromance analysis&lt;/a&gt;, this metric represents cycles where the CPU isn’t doing useful work because of an earlier mis-speculation. Here, the mis-speculation is mis-predicted branches. The penalty for &lt;em&gt;each&lt;/em&gt; such mis-predicted branch is an entire flush of the pipeline (hence the wasted time), which costs us around 14-15 cycles on modern Intel CPUs.&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0; vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none; padding-top: 0; padding-bottom: 0&quot;&gt;&lt;div&gt;
        &lt;p&gt;We have to remember that efficient execution on modern CPUs means keeping the CPU pipeline as busy as possible; This is quite a challenge given its length is about 15 stages, and the CPU itself is super-scalar (For example: an &lt;a href=&quot;https://en.wikichip.org/wiki/intel/microarchitectures/skylake_(client)#Individual_Core&quot;&gt;Intel Skylake CPU has 8 ports&lt;/a&gt; that can execute some instruction every cycle!). If, for example, all instructions in the CPU have a constant latency in cycles, this means it &lt;em&gt;has&lt;/em&gt; to process 100+ instructions into “the future” while it’s just finishing up with a current one to avoid doing nothing. That’s enough of a challenge for regular code, but what should it do when it sees a branch? It could attempt and execute &lt;strong&gt;both&lt;/strong&gt; branches, which quickly becomes a fool’s errand if somewhere close-by there would be even more branches. What CPU designers did was opt for speculative execution: add complex machinery to &lt;em&gt;predict&lt;/em&gt; if a branch will be taken and speculatively execute the next instruction according to the prediction. But the predictor isn’t all knowing, and it will mis-predict, and then we end up paying a huge penalty: The CPU will have to push those mis-predicted instructions through the pipeline flushing the results out as if the whole thing never happenned. This is why the rate of mis-prediction is a life and death matter when it comes to performance.&lt;/p&gt;
      &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Wait, I sense some optimistic thoughts all across the internet… maybe it’s not our precious vectorized so-called branch-less code? Maybe we can chalk it all up on that mean scalar &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; function doing those millions and millions of scalar comparisons? We are, after all, using it for sorting small partitions, which we’ve already measured at more than 20% of the total run-time? Let’s see this again with &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt;, &lt;em&gt;this time&lt;/em&gt; focusing on the &lt;code class=&quot;highlighter-rouge&quot;&gt;branch-misses&lt;/code&gt; HW counter and try to figure out how the mis-predictions are distributed amongst our call-stacks:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMPlus_PerfMapEnabled&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;c&quot;&gt;# Make perf speak to the JIT&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Record some performance information:&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf record &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; max &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; branch-misses ./Example &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;--type-list&lt;/span&gt; DoublePumpedNaive &lt;span class=&quot;nt&quot;&gt;--size-list&lt;/span&gt; 1000000
...
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;perf report &lt;span class=&quot;nt&quot;&gt;--stdio&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-F&lt;/span&gt; overhead,sym | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-17&lt;/span&gt;
...
    40.97%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...::InsertionSort&lt;span class=&quot;o&quot;&gt;(!!&lt;/span&gt;0&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,!!0&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
    32.30%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...::VectorizedPartitionInPlace&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
     9.64%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...::Memmove&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;uint8&amp;amp;,uint8&amp;amp;,uint64&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;OptimizedTier1]
     9.64%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...::QuickSortInt&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;OptimizedTier1]
     5.62%  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;.] ...::VectorizedPartitionOnStack&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;,int32&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)[&lt;/span&gt;Optimized]
...
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;No such luck. While &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; is definitely starring here with 41% &lt;em&gt;of the&lt;/em&gt; branch misprediction events, we still have &lt;strong&gt;32%&lt;/strong&gt; of the bad speculation coming from our own new vectorized code. This is a red-flag as far as we’re concerned: It means that our vectorized code still contains a lot of mis-predicted branches. Given that we’re in the bussiness of sorting (random data) and the high rate of recorded mis-prediction the only logical conclusion is that we have branches that are data-dependent. Another thing to keep in mind is that the resulting pipeline flush is a large penalty to pay given that our entire 8-element partition block has a throughput of around 8-9 cycles. That means we are hitting that 15 cycle pan-to-the-face way too often to feel good about ourselves.&lt;/p&gt;

&lt;p&gt;I’ll finish this post here. We have a &lt;strong&gt;lot of work&lt;/strong&gt; cut out for us. This is no-where near over.&lt;br /&gt;
In the next post, I’ll try to give the current vectorized code a good shakeup. After all, it’s still our biggest target in terms of number of instructions executed, and 2&lt;sup&gt;nd&lt;/sup&gt; when it comes to branch mis-predictions. Once we finish squeezing that lemon for all its performance juice on the 4&lt;sup&gt;th&lt;/sup&gt; post, We will turn our focus to the &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; function on the 5&lt;sup&gt;th&lt;/sup&gt; post , and we’ll see if we can appease the performance gods to make that part of the sorting effort faster.&lt;br /&gt;
In the meantime, you can go back to the vectorized partitioning function and try to figure out what is causing all those nasty branch mis-predictions if you’re up for a small challenge. We’ll be dealing with it head-on in the next post.&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:0&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;For some, &lt;code class=&quot;highlighter-rouge&quot;&gt;perf&lt;/code&gt; wasn’t in the mood to show me function names without calling &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet publish&lt;/code&gt;  and using the resulting binary, and I didn’t care enough to investigate further… &lt;a href=&quot;#fnref:0&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">Decimating Array.Sort with AVX2. I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics. There's no reason I should go down alone.</summary></entry><entry><title type="html">This Goes to Eleven (Part. 2/∞)</title><link href="https://bits.houmus.org/2020-01-29/this-goes-to-eleven-pt2" rel="alternate" type="text/html" title="This Goes to Eleven (Part. 2/∞)" /><published>2020-01-29T05:26:28+00:00</published><updated>2020-01-29T05:26:28+00:00</updated><id>https://bits.houmus.org/2020-01-29/this-goes-to-eleven-pt2</id><content type="html" xml:base="https://bits.houmus.org/2020-01-29/this-goes-to-eleven-pt2">&lt;p&gt;Since there’s a lot to over go over here, I’ve split it up into no less than 6 parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-28/this-goes-to-eleven-pt1&quot;&gt;part 1&lt;/a&gt;, we start with a refresher on &lt;code class=&quot;highlighter-rouge&quot;&gt;QuickSort&lt;/code&gt; and how it compares to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;In this part, we go over the basics of vectorized hardware intrinsics, vector types, and go over a handful of vectorized instructions we’ll use in part 3. We still won’t be sorting anything.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-30/this-goes-to-eleven-pt3&quot;&gt;part 3&lt;/a&gt;, we go through the initial code for the vectorized sorting, and start seeing some payoff. We finish agonizing courtesy of the CPU’s branch predictor, throwing a wrench into our attempts.&lt;/li&gt;
  &lt;li&gt;In part 4, we go over a handful of optimization approaches that I attempted trying to get the vectorized partitioning to run faster. We’ll see what worked and what didn’t.&lt;/li&gt;
  &lt;li&gt;In part 5, we’ll see how we can almost get rid of all the remaining scalar code- by implementing small-constant size array sorting. We’ll use, drum roll…, yet more AVX2 vectorization.&lt;/li&gt;
  &lt;li&gt;Finally, in part 6, I’ll list the outstanding stuff/ideas I have for getting more juice and functionality out of my vectorized code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;intrinsics--vectorization&quot;&gt;Intrinsics / Vectorization&lt;/h2&gt;

&lt;p&gt;I’ll start by repeating my own words from the first &lt;a href=&quot;/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1#the-whatwhy-of-intrinsics&quot;&gt;blog post where I discussed intrinsics&lt;/a&gt; in the CoreCLR 3.0 alpha days:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Processor intrinsics are a way to directly embed specific CPU instructions via special, fake method calls that the JIT replaces at code-generation time. Many of these instructions are considered exotic, and normal language syntax cannot map them cleanly.&lt;br /&gt;
The general rule is that a single intrinsic “function” becomes a single CPU instruction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;You can go and re-read that introduction if you care for a more general and gentle introduction to processor intrinsics. For this series, we are going to focus on vectorized intrinsics in Intel processors. This is the largest group of CPU specific intrinsics in our processors, and I want to start by showing this by the numbers. I gathered some statistics by processing Intel’s own &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/files/data-3.4.6.xml&quot;&gt;data-3.4.6.xml&lt;/a&gt;. This XML file is part of the &lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/&quot;&gt;Intel Intrinsics Guide&lt;/a&gt;, an invaluable resource on intrinsics in itself, and the “database” behind the guide. What I learned was that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;There are no less than 1,218 intrinsics in Intel processors&lt;sup id=&quot;fnref:0&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:0&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;!
    &lt;ul&gt;
      &lt;li&gt;Those can be combined in 6,180 different ways (according to operand sizes and types).&lt;/li&gt;
      &lt;li&gt;They’re grouped into 67 different categories/groups, these groups loosely correspond to various generations of CPUs as more and more intrinsics were gradually added.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;More than 94% are vectorized hardware intrinsics, which we’ll define more concretely below.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That last point is super-critical: CPU intrinsics, at least in 2020, are overwhelmingly about being able to execute vectorized instructions. That’s really why you &lt;em&gt;should&lt;/em&gt; be paying them attention in the first place. Sure, there’s additional stuff in there: if you’re a kernel developer, or writing crypto code, or some other niche-cases, but vectorization is why you are really here, whether you knew it or not.&lt;/p&gt;

&lt;p&gt;In C#, we’ve mostly shied away from having intrinsics until CoreCLR 3.0 came along, where intrinsic support became official/complete, championed by &lt;a href=&quot;https://twitter.com/tannergooding&quot;&gt;@tannergooding&lt;/a&gt; as well as others from Microsoft and Intel. but as single-threaded performance has virtually stopped improving, more programming languages started adding intrinsics support (go, rust, Java and now C#) so developers in those languages would have access to these specialized, much more efficient instructions. CoreCLR 3.0 does not support all 1,218 intrinsics that I found, but a more modest 226 intrinsics in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86?view=netcore-3.0&amp;amp;viewFallbackFrom=dotnet-plat-ext-3.0&quot;&gt;15 different classes&lt;/a&gt; for x86 Intel and AMD processors. Each class is filled with many static functions, all of which are unique processor intrinsics, and represent a 1:1 mapping to Intel group/code names. As C# developers, we roughly get access to everything that Intel incorporated in their processors manufactured from 2014 and onwards&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;, and for AMD processors, from 2015 onwards.&lt;/p&gt;

&lt;p&gt;What are these vectorized intrinsics?&lt;br /&gt;
We need to cover a few base concepts specific to that category of intrinsics before we can start explaining specific intrinsics/instructions:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;What are vectorized intrinsics, and why have they become so popular.&lt;/li&gt;
  &lt;li&gt;How vectorized intrinsics interact with specialized vectorized &lt;em&gt;registers&lt;/em&gt;.&lt;/li&gt;
  &lt;li&gt;How those registers are reflected as, essentially, new primitive types in CoreCLR 3.0.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;simd-what--why&quot;&gt;SIMD What &amp;amp; Why&lt;/h3&gt;

&lt;p&gt;I’m going to use vectorization and SIMD interchangeably from here-on, but for the first and last time, let’s spell out what SIMD is: &lt;strong&gt;S&lt;/strong&gt;ingle &lt;strong&gt;I&lt;/strong&gt;nstruction &lt;strong&gt;M&lt;/strong&gt;ultiple &lt;strong&gt;D&lt;/strong&gt;ata is really a simple idea when you think about it. A lot of code ends up doing “stuff” in loops, usually, processing vectors of data one element at a time. SIMD instructions bring a simple new idea to the table: The CPU adds special instructions that can do arithmetic, bit-operations, comparisons and many other types of generalized operations on “vectors”, e.g. process multiple elements per instruction.&lt;/p&gt;

&lt;p&gt;The benefit of using this approach to computing is that it allows for much greater efficiency: When we use vectorized intrinsics we end up executing the same &lt;em&gt;number&lt;/em&gt; of instructions to process, for example, 8 data elements per instruction. Therefore, we reduce the amount of time the CPU spends decoding instructions for the same amount of work; furthermore, most vectorized instructions operate &lt;em&gt;independently&lt;/em&gt; on the various &lt;strong&gt;elements&lt;/strong&gt; of the vector and complete their operation at the same number of CPU cycles as the equivalent non-vectorized (or scalar) instruction. In short, in the land of CPU feature economics, vectorization is considered a high bang-for-buck feature: You can get a lot of &lt;em&gt;potential&lt;/em&gt; performance for relatively little transistors added to the CPU, as long as people are willing to adapt their code (e.g. rewrite it) to use these new intrinsics, or compilers somehow magically manage to auto-vectorize the code (spoiler: There are tons of problems with that too)&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Another equally important thing to embrace and understand about vectorized intrinsics is what they don’t and cannot provide: branching. It’s pretty much impossible to even attempt to imagine what a vectorized branch instruction would mean. These two concepts don’t begin to mix. Appropriately, a substantial part of vectorizing code is forcing oneself to accomplishing the given task without using branching. As we will see, branching begets unpredictability, at the CPU level, and unpredictability is our enemy, when we want to go fast.&lt;/p&gt;

&lt;p&gt;Of course, I’m grossly over-romanticizing vectorized intrinsics and their benefits: There are also many non-trivial overheads involved both using them and adding them to our processors and to using them in our code. However, all in all, in the grand picture of CPU/performance economics adding and using vectorized instructions is still, compared to other potential improvements, quite cheap, under the assumption that programmers are willing to make the effort to re-write and maintain vectorized code.&lt;/p&gt;

&lt;h4 id=&quot;simd-registers&quot;&gt;SIMD registers&lt;/h4&gt;

&lt;p&gt;After our short introduction to vectorized intrinsics, we need to discuss SIMD registers, and how this piece of the puzzle fits the grand picture: Teaching our CPU to execute 1,000+ vectorized instructions is just part of the story, these instructions need to somehow operate on our data. Do all of these instructions simply take a pointer to memory and run wild with it? The short answer is: &lt;strong&gt;No&lt;/strong&gt;. For the &lt;em&gt;most&lt;/em&gt; part, CPU instructions dealing with vectorization (with a few notable exceptions) use special registers inside our CPU that are called SIMD registers. This is analogous to scalar (regular, non-vectorized) code we write in any programming language: while some instructions read and write directly to memory, and occasionally some instruction will accept a memory address as an operand, most instructions are register ↔ register only.&lt;/p&gt;

&lt;p&gt;Just like scalar CPU registers, SIMD registers have a constant bit-width. In Intel these come at 64, 128, 256 and recently 512 bit wide registers. Unlike scalar registers, though, SIMD registers, end up &lt;em&gt;containing multiple&lt;/em&gt; data-elements of another primitive type. The same register can and will be used to process a wide-range of primitive data-types, depending on which instruction is using it, as we will shortly demonstrate.&lt;/p&gt;

&lt;p&gt;For now, this is all I care to explain about SIMD Registers at the CPU level: We need to be aware of their existence (we’ll see them in disassembly dumps anyway), and since we are dealing with high-perfomance code we kind of need to know how many of them exist inside our CPU.&lt;/p&gt;

&lt;h4 id=&quot;simd-intrinsic-types-in-c&quot;&gt;SIMD Intrinsic Types in C\#&lt;/h4&gt;

&lt;p&gt;We’ve touched lightly upon SIMD intrinsics and how they operate (e.g. accept and modify) on SIMD registers. Time to figure out how we can fiddle with everything in C#; we’ll start with the types:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;C# Type&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;x86 Registers&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Width (bits)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector64?view=netcore-3.0&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector64&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mmo-mm7&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;64&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector128?view=netcore-3.0&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector128&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xmm0-xmm15&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;128&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256?view=netcore-3.0&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;ymm0-ymm15&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;256&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;These are primitive vector value-types recognized by the JIT while it is generating machine code. We should try and think about these types just like we think about other special-case primitive types such as &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;, with one exception: These vector types all accept a generic parameter &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, which may seem a little odd for a primitive type at a first glance, until we remember that their purpose is to contain &lt;em&gt;other&lt;/em&gt; primitive types (there’s a reason they put the word “Vector” in there…); moreover, this generic parameter can’t just be any type or even value-type we’d like… It is limited to the types supported on our CPU and its vectorized intrinsics.&lt;/p&gt;

&lt;p&gt;Let’s take &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt;, which I’ll be using exclusively in this series, as an example; &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; can be used &lt;strong&gt;only&lt;/strong&gt; with the following primitive types:&lt;/p&gt;

&lt;table class=&quot;fragment&quot;&gt;
&lt;thead&gt;&lt;th style=&quot;border: none&quot;&gt;&lt;code&gt;typeof(T)&lt;/code&gt;&lt;/th&gt;
&lt;th /&gt;
&lt;th style=&quot;border: none&quot;&gt;# Elements&lt;/th&gt;
&lt;th style=&quot;border: none&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;border: none&quot;&gt;Element Width (bits)&lt;/th&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;&lt;td style=&quot;border: none&quot;&gt;&lt;code&gt;byte / sbyte&lt;/code&gt;&lt;/td&gt;  &lt;td style=&quot;border: none&quot;&gt;➡&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;32&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;x&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;8b&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;border: none&quot;&gt;&lt;code&gt;short / ushort&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;➡&lt;/td&gt; &lt;td style=&quot;border: none&quot;&gt;16&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;x&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;16b&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;border: none&quot;&gt;&lt;code&gt;int / uint&lt;/code&gt;&lt;/td&gt;    &lt;td style=&quot;border: none&quot;&gt;➡&lt;/td&gt; &lt;td style=&quot;border: none&quot;&gt;8&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;x&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;32b&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;border: none&quot;&gt;&lt;code&gt;long / ulong&lt;/code&gt;&lt;/td&gt;  &lt;td style=&quot;border: none&quot;&gt;➡&lt;/td&gt; &lt;td style=&quot;border: none&quot;&gt;4&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;x&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;64b&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;border: none&quot;&gt;&lt;code&gt;float&lt;/code&gt;&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;➡&lt;/td&gt; &lt;td style=&quot;border: none&quot;&gt;8&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;x&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;32b&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td style=&quot;border: none&quot;&gt;&lt;code&gt;double&lt;/code&gt;&lt;/td&gt; &lt;td style=&quot;border: none&quot;&gt;➡&lt;/td&gt; &lt;td style=&quot;border: none&quot;&gt;4&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;x&lt;/td&gt;&lt;td style=&quot;border: none&quot;&gt;64b&lt;/td&gt;&lt;/tr&gt;
    &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;No matter which type of the supported primitive set we’ll choose, we’ll end up with a total of 256 bits, or the underlying SIMD register width.&lt;br /&gt;
Now that we’ve kind of figured out of vector types/registers are represented in C#, let’s perform some operations on them.&lt;/p&gt;

&lt;h3 id=&quot;a-few-vectorized-instructions-for-the-road&quot;&gt;A few Vectorized Instructions for the road&lt;/h3&gt;

&lt;p&gt;Armed with this new understanding and knowledge of &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; we can move on and start learning a few vectorized instructions.&lt;/p&gt;

&lt;p&gt;Chekhov famously said: “If in the first act you have hung a pistol on the wall, then in the following one it should be fired. Otherwise, don’t put it there”. Here are seven loaded AVX2 pistols; rest assured they are about to fire in the next act. I’m obviously not going to explain all 1,000+ intrinsics mentioned before, if only not to piss off Anton Chekhov. We will &lt;strong&gt;thoroughly&lt;/strong&gt; explain the ones needed to get this party going.&lt;br /&gt;
Here’s the list of what we’re going to go over:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;x64 asm&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Intel&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;CoreCLR&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vbroadcastd&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_broadcastd_epi32&amp;amp;expand=542&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm256_broadcastd_epi32&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.vector256.create?view=netcore-3.0#System_Runtime_Intrinsics_Vector256_Create_System_Int32_&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256.Create(int)&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vlddqu&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_lddqu_si256&amp;amp;expand=3296&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm256_lddqu_si256&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx.loaddquvector256?view=netcore-3.0#System_Runtime_Intrinsics_X86_Avx_LoadDquVector256_System_Int32__&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Avx.LoadDquVector256&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmovdqu&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_storeu_si256&amp;amp;expand=5654&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm256_storeu_si256&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx.store?view=netcore-3.0#System_Runtime_Intrinsics_X86_Avx_Store_System_Int32__System_Runtime_Intrinsics_Vector256_System_Int32__&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Avx.Store&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vpcmpgtd&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_cmpgt_epi32&amp;amp;expand=900&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm256_cmpgt_epi32&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx2.comparegreaterthan?view=netcore-3.0#System_Runtime_Intrinsics_X86_Avx2_CompareGreaterThan_System_Runtime_Intrinsics_Vector256_System_Int32__System_Runtime_Intrinsics_Vector256_System_Int32__&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Avx2.CompareGreaterThan&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmovmskps&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_movemask_ps&amp;amp;expand=3870&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm256_movemask_ps&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx.movemask?view=netcore-3.0#System_Runtime_Intrinsics_X86_Avx_MoveMask_System_Runtime_Intrinsics_Vector256_System_Single__&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Avx.MoveMask&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;popcnt&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm_popcnt_u32&amp;amp;expand=4378&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm_popcnt_u32&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.popcnt.popcount?view=netcore-3.0#System_Runtime_Intrinsics_X86_Popcnt_PopCount_System_UInt32_&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Popcnt.PopCount&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vpermd&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;a href=&quot;https://software.intel.com/sites/landingpage/IntrinsicsGuide/#text=_mm256_permutevar8x32_epi32&amp;amp;expand=4201&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_mm256_permutevar8x32_epi32&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.runtime.intrinsics.x86.avx2.permutevar8x32?view=netcore-3.0#System_Runtime_Intrinsics_X86_Avx2_PermuteVar8x32_System_Runtime_Intrinsics_Vector256_System_Int32__System_Runtime_Intrinsics_Vector256_System_Int32__&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Avx2.PermuteVar8x32&lt;/code&gt;&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I understand that for first time readers, this list looks like I’m just name-dropping lots of fancy code names to make myself sound smart, but the unfortunate reality is that we &lt;em&gt;kind of need&lt;/em&gt; to know all of these, and here is why: On the right column I’ve provided the actual C# Intrinsic function we will be calling in our code and linked to their docs. But here’s a funny thing: There is no “usable” documentation on Microsoft’s own docs regarding most of these intrinsics. All those docs do is simply point back to the Intel C/C++ intrinsic name, which I’ve also provided in the middle column, with links to the real documentation, the sort that actually explains what the instruction does with pseudo code. Finally, since we’re practically writing assembly code anyways, and I can guarantee we’ll end up inspecting JIT’d code down the road, I provided the x86 assembly opcodes for our instructions as well.&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;
Now, What does each of these do? Let’s find out…&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Hint&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none&quot;&gt;From here-on, The following icon means I have a thingy that animates: &lt;object style=&quot;margin: auto; position: relative; top: 1.1em&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/play.svg&quot;&gt;&lt;/object&gt;&lt;br /&gt;
Click/Touch/Hover &lt;b&gt;inside&lt;/b&gt; means: &lt;i class=&quot;glyphicon glyphicon-play&quot;&gt;&lt;/i&gt;&lt;br /&gt;
Click/Touch/Hover &lt;b&gt;outside&lt;/b&gt; means: &lt;i class=&quot;glyphicon glyphicon-pause&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;h4 id=&quot;vector256createint-value&quot;&gt;Vector256.Create(int value)&lt;/h4&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
    &lt;object class=&quot;animated-border&quot; width=&quot;100%&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/inst-animations/vbroadcast-with-hint.svg&quot;&gt;&lt;/object&gt;
  &lt;/div&gt;

  &lt;p&gt;We start with a couple of simple instructions, and nothing is more simple than this first: This intrinsic accepts a single scalar value and simply “broadcasts” it to an entire SIMD register, this is how you’d use it:&lt;/p&gt;

  &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;someVector256&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Create&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0x42&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;This will load up &lt;code class=&quot;highlighter-rouge&quot;&gt;someVector256&lt;/code&gt; with 8 copies of &lt;code class=&quot;highlighter-rouge&quot;&gt;0x42&lt;/code&gt; once executed, and in x64 assembly, the JIT will produce something quite simple:&lt;/p&gt;

  &lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;vmovd&lt;/span&gt;  &lt;span class=&quot;nv&quot;&gt;xmm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;; 3 cycle latency / 1 cycle throughput&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vpbroadcastd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;xmm0&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;; 3 cycle latency / 1 cycle throughput&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;This specific intrinsic is translated into two intel opcodes, since there is no direct single instruction that performs this.&lt;/p&gt;
&lt;/div&gt;

&lt;h4 id=&quot;avx2loaddquvector256--avxstore&quot;&gt;Avx2.LoadDquVector256 / Avx.Store&lt;/h4&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
    &lt;object class=&quot;animated-border&quot; width=&quot;100%&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/inst-animations/lddqu-with-hint.svg&quot;&gt;&lt;/object&gt;
  &lt;/div&gt;

  &lt;p&gt;Next up we have a couple of brain dead simple intrinsics that we use to read/write from memory into SIMD registers and conversely store from SIMD registers back to memory. These are amongst the most common intrinsics out there, as you can imagine:&lt;/p&gt;

  &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Get some pointer to a big enough array&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;And in x64 assembly:&lt;/p&gt;

  &lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;vlddqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymmword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; 5 cycle latency + cache/memory&lt;/span&gt;
                                &lt;span class=&quot;c1&quot;&gt;; 0.5 cycle throughput&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;vmovdqu&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymmword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rdi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; Same as above&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;I only included an SVG animation for &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadDquVector256&lt;/code&gt;, but you can use your imagination and visualize how &lt;code class=&quot;highlighter-rouge&quot;&gt;Store&lt;/code&gt; simply does the same thing in reverse.&lt;/p&gt;
&lt;/div&gt;

&lt;h4 id=&quot;comparegreaterthan&quot;&gt;CompareGreaterThan&lt;/h4&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
    &lt;object class=&quot;animated-border&quot; width=&quot;100%&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/inst-animations/vpcmpgtd-with-hint.svg&quot;&gt;&lt;/object&gt;
  &lt;/div&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CompareGreaterThan&lt;/code&gt; does an &lt;em&gt;n&lt;/em&gt;-way, element-by-element &lt;em&gt;greater-than&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;) comparison between two &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;T&amp;gt;&lt;/code&gt; instances. In our case where &lt;code class=&quot;highlighter-rouge&quot;&gt;T&lt;/code&gt; is really &lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt;, this means comparing 8 integers in one go, instead of performing 8 comparisons serially!&lt;/p&gt;

  &lt;p&gt;But where is the result? In a new &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; of course! The resulting vector contains 8 results for the corresponding comparisons between the elements of the first and second vectors. Each position where the element in the first vector was &lt;em&gt;greater-than&lt;/em&gt; (&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;) the second vector, the corresponding element in the result vector gets a &lt;code class=&quot;highlighter-rouge&quot;&gt;-1&lt;/code&gt; value, or &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; otherwise.&lt;br /&gt;
Calling this is rather simple:&lt;/p&gt;

  &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comperand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;CompareGreaterThan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;comperand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;And in x64 assembly, this is pretty simple too:&lt;/p&gt;

  &lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;vpcmpgtd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm0&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 1 cycle latency&lt;/span&gt;
                          &lt;span class=&quot;c1&quot;&gt;; 0.5 cycle throughput&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

&lt;/div&gt;
&lt;h4 id=&quot;movemask&quot;&gt;MoveMask&lt;/h4&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
    &lt;object class=&quot;animated-border&quot; width=&quot;100%&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/inst-animations/vmovmskps-with-hint.svg&quot;&gt;&lt;/object&gt;
  &lt;/div&gt;

  &lt;p&gt;Another intrinsic which will prove to be very useful is the ability to extract some bits from a vectorized register into a normal, scalar one. &lt;code class=&quot;highlighter-rouge&quot;&gt;MoveMask&lt;/code&gt; does just this. This intrinsic takes the top-level (MSB) bit from every element and moves it into our scalar result:&lt;/p&gt;

  &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;MoveMask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AsSingle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;There’s an oddity here, as you can tell by that awkward &lt;code class=&quot;highlighter-rouge&quot;&gt;.AsSingle()&lt;/code&gt; call, try to ignore it if you can, or hit this footnote&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt; if you can’t. The assembly instruction here is exactly as simple as you would think:&lt;/p&gt;

  &lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;vmovmskps&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; 5 cycle latency&lt;/span&gt;
                     &lt;span class=&quot;c1&quot;&gt;; 1 cycle throughput&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

&lt;/div&gt;

&lt;h4 id=&quot;popcount&quot;&gt;PopCount&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; is a very powerful intrinsic, which &lt;a href=&quot;/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2&quot;&gt;I’ve covered extensively before&lt;/a&gt;: &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; returns the number of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits in a 32/64 bit primitive.&lt;br /&gt;
In C#, we would use it as follows:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PopCnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b0000111100110011&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// result == 8&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And in x64 assembly code:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; 3 cycle latency&lt;/span&gt;
                 &lt;span class=&quot;c1&quot;&gt;; 1 cycle throughput&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this series, &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount&lt;/code&gt; is the only intrinsic I use that is not purely vectorized&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;h4 id=&quot;permutevar8x32&quot;&gt;PermuteVar8x32&lt;/h4&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
    &lt;object class=&quot;animated-border&quot; type=&quot;image/svg+xml&quot; data=&quot;../talks/intrinsics-sorting-2019/inst-animations/vpermd-with-hint.svg&quot;&gt;&lt;/object&gt;
  &lt;/div&gt;

  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PermuteVar8x32&lt;/code&gt; accepts two vectors: source, permutation and performs a permutation operation &lt;strong&gt;on&lt;/strong&gt; the source value &lt;em&gt;according to the order provided&lt;/em&gt; in the permutation value. If this sounds confusing go straight to the visualization below…&lt;/p&gt;

  &lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;PermuteVar8x32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;perm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

  &lt;p&gt;While technically speaking, both the &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;perm&lt;/code&gt; parameters are of type &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; and can contain any integer value in their elements, only the 3 least significant bits in &lt;code class=&quot;highlighter-rouge&quot;&gt;perm&lt;/code&gt; are taken into account for permutation of the elements in &lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;.&lt;br /&gt;
This should make sense, as we are permuting an 8-element vector, so we need 3 bits (2&lt;sup&gt;3&lt;/sup&gt; == 8) in every permutation element to figure out which element goes where… In x64 assembly this is:&lt;/p&gt;

  &lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nf&quot;&gt;vpermd&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ymm1&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; 3 cycles latency&lt;/span&gt;
                        &lt;span class=&quot;c1&quot;&gt;; 1 cycles throughput&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;  &lt;/div&gt;

&lt;/div&gt;

&lt;h3 id=&quot;thats-it-for-now&quot;&gt;That’s it for now&lt;/h3&gt;

&lt;p&gt;This post was all about laying the groundwork before this whole mess comes together.&lt;br /&gt;
Remember, we’re re-implementing QuickSort with AVX2 intrinsics in this series, which for the most part, means re-implementing the partitioning function from our scalar code listing in the previous post.&lt;br /&gt;
I’m sure wheels are turning in many heads now as you are trying to figure out what comes next…&lt;br /&gt;
I think it might be a good time as any to end this post and leave you with a suggestion: Try to take a piece of paper or your favorite text editor, and see if you can cobble up these instructions into something that can partition numbers given a selected pivot.&lt;/p&gt;

&lt;p&gt;When you’re ready, head on to the &lt;a href=&quot;/2020-01-30/this-goes-to-eleven-pt3&quot;&gt;next post&lt;/a&gt; to see how the whole thing comes together, and how fast we can get it to run with a basic version…&lt;/p&gt;

&lt;hr /&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:0&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;To be clear, some of these are intrinsics in unreleased processors, and even of those that are all released in the wild, there is no single processor support all of these… &lt;a href=&quot;#fnref:0&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;CoreCLR supports roughly everything up to and including the AVX2 intrinsics, which were introduced with the  Intel Haswell processor, near the end of 2013. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;In general, auto-vectorizing compilers are a huge subject in their own, but the bottom line is that without completely changing the syntax and concepts of our programming language, there is very little that an auto-vectorizing compiler can do with existing code, and making one that really works often involves designing programming language with vectorization baked into them from day one. I really recommend reading &lt;a href=&quot;https://pharr.org/matt/blog/2018/04/30/ispc-all.html&quot;&gt;this series about Intel’s attempt&lt;/a&gt; at this space if you are into this sort of thing. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Now, If I was in my annoyed state of mind, I’d bother to mention that &lt;a href=&quot;https://github.com/dotnet/corefx/issues/2209#issuecomment-317124449&quot;&gt;I personally always thought&lt;/a&gt; that introducing 200+ functions with already established names (in C/C++/rust) and forcing everyone to learn new names whose only saving grace is that they look BCL&lt;em&gt;ish&lt;/em&gt; to begin with was not the friendliest move on Microsoft’s part, and that trying to give C# names to the utter mess that Intel created in the first place was a thankless effort that would only annoy everyone more, and would eventually run up against the inhumane names Intel went for (Yes, I’m looking at you &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadDquVector256&lt;/code&gt;, you are not looking very BCL-ish to me with the &lt;code class=&quot;highlighter-rouge&quot;&gt;Dqu&lt;/code&gt; slapped in the middle there : (╯°□°)╯︵ ┻━┻)… But thankfully, I’m not in my annoyed state. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;While this looks like we’re really doing “something” with our &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;int&amp;gt;&lt;/code&gt; and somehow casting it do single-precision floating point values, let me assure you, this is just smoke and mirrors: The intrinsic simply accepts only floating point values (32/64 bit ones), so we have to “cast” the data to &lt;code class=&quot;highlighter-rouge&quot;&gt;Vector256&amp;lt;float&amp;gt;&lt;/code&gt;, or alternatively call &lt;code class=&quot;highlighter-rouge&quot;&gt;.AsSingle()&lt;/code&gt; before calling &lt;code class=&quot;highlighter-rouge&quot;&gt;MoveMask&lt;/code&gt;. Yes, this is super awkward from a pure C# perspective, but in reality, the JIT understands these shenanigans and really ignores them completely. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;By the way, although this intrinsic doesn’t accept nor return one of the SIMD registers / types, and considered to be a non-vectorized intrinsic as far as classification goes, as far as I’m concerned bit-level intrinsic functions that operate on scalar registers are just as “vectorized” as their “pure” vectorized sisters, as they mostly deal with scalar values as vectors of bits. &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">Decimating Array.Sort with AVX2. I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics. There's no reason I should go down alone.</summary></entry><entry><title type="html">This Goes to Eleven (Part 1/∞)</title><link href="https://bits.houmus.org/2020-01-28/this-goes-to-eleven-pt1" rel="alternate" type="text/html" title="This Goes to Eleven (Part 1/∞)" /><published>2020-01-28T05:26:28+00:00</published><updated>2020-01-28T05:26:28+00:00</updated><id>https://bits.houmus.org/2020-01-28/this-goes-to-eleven-pt1</id><content type="html" xml:base="https://bits.houmus.org/2020-01-28/this-goes-to-eleven-pt1">&lt;h1 id=&quot;lets-do-this&quot;&gt;Let’s do this&lt;/h1&gt;

&lt;p&gt;Let’s get in the ring and show what AVX/AVX2 intrinsics can really do for a non-trivial problem, and even discuss potential improvements that future CoreCLR versions could bring to the table.&lt;/p&gt;

&lt;p&gt;Everyone needs to sort arrays, once in a while, and many algorithms we take for granted rely on doing so. We think of it as a &lt;em&gt;solved&lt;/em&gt; problem and that nothing can be &lt;em&gt;further&lt;/em&gt; done about it in 2020, except for waiting for newer, marginally faster machines to pop-up&lt;sup id=&quot;fnref:0&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:0&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;. However, that is not the case, and while I’m not the first to have thoughts about it; or the best at implementing it, if you join me in this rather long journey, we’ll end up with a replacement function for &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;, written in pure C# that outperforms CoreCLR’s C++&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt; code by a factor north of 10x on most modern Intel CPUs, and north of 11x on my laptop.&lt;br /&gt;
Sounds interesting? If so, down the rabbit hole we go…&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--warning&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none;vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none&quot;&gt;&lt;div&gt;
        &lt;p&gt;In the final days before posting this series, Intel started seeding a CPU microcode update that is/was affecting the performance of the released version of CoreCLR 3.0/3.1 quite considerably. I managed to stir up a &lt;a href=&quot;https://twitter.com/damageboy/status/1194751035136450560&quot;&gt;small commotion&lt;/a&gt; as this was unraveling in my benchmarks. As it happened, my code was (not coincidentally) less affected by this change, while CoreCLRs &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt; &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/27877&quot;&gt;took a 20% nosedive&lt;/a&gt;. Let it never be said I’m nothing less than chivalrous, for I rolled back the microcode update, and for this &lt;strong&gt;entire&lt;/strong&gt; series, I’m going to run against a much faster version of &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt; than what you, the reader, are probably using, Assuming you update your machine from time to time. For the technically inclined, here’s a whole footnote&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; on how to double-check what your machine is actually running. I also opened two issues in the CoreCLR repo about attempting to mitigate this both in CoreCLRs C++ code and separately in the JIT. If/when there is movement on those fronts, the microcode you’re running will become less of an issue, to begin with, but for now, this just adds another level of unwarranted complexity to our lives.&lt;/p&gt;
      &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;A while back now, I was reading the post by Stephen Toub about &lt;a href=&quot;https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-core-3-0/&quot;&gt;Improvements in CoreCLR 3.0&lt;/a&gt;, and it became apparent that hardware intrinsics were common to many of these, and that so many parts of CoreCLR could still be sped up with these techniques, that one thing led to another, and I decided an attempt to apply hardware intrinsics to a larger problem than I had previously done myself was in order. To see if I could rise to the challenge, I decided to take on array sorting and see how far I can go.&lt;/p&gt;

&lt;p&gt;What I came up with eventually would become a re-write of &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt; with AVX2 hardware intrinsics. Fortunately, choosing sorting and focusing on QuickSort makes for a great blog post series, since:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Everyone should be familiar with the domain and even the original (sorting is the bread and butter of learning computer science, really, and QuickSort is the queen of all sorting algorithms).&lt;/li&gt;
  &lt;li&gt;It’s relatively easy to explain/refresh on the original.&lt;/li&gt;
  &lt;li&gt;If I can make it there, I can make it anywhere.&lt;/li&gt;
  &lt;li&gt;I had no idea how to do it.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I started with searching various keywords and found an interesting paper titled: &lt;a href=&quot;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.1009.7773&amp;amp;rep=rep1&amp;amp;type=pdf&quot;&gt;Fast Quicksort Implementation Using AVX Instructions&lt;/a&gt; by Shay Gueron and Vlad Krasnov. That title alone made me think this is about to be a walk in the park. While initially promising, it wasn’t good enough as a drop-in replacement for &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; for reasons I’ll shortly go into. I ended up having a lot of fun expanding on their basic approach. &lt;a href=&quot;https://github.com/dotnet/runtime/pull/33152#issuecomment-596405021&quot;&gt;&lt;del&gt;I will submit a proper pull-request to start a discussion with CoreCLR devs about integrating this code into the main dotnet repository&lt;/del&gt;&lt;/a&gt;&lt;sup id=&quot;fnref:5&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:5&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;, but for now, let’s talk about sorting.&lt;/p&gt;

&lt;p&gt;Since there’s a lot to go over here, I’ve split it up into no less than 6 parts:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;In this part, we start with a refresher on QuickSort and how it compares to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt;. If you don’t need a refresher, skip it and get right down to part 2 and onwards. I recommend skimming through, mostly because I’ve got excellent visualizations which should be in the back of everyone’s mind as we deal with vectorization &amp;amp; optimization later.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-29/this-goes-to-eleven-pt2&quot;&gt;part 2&lt;/a&gt;, we go over the basics of vectorized hardware intrinsics, vector types, and go over a handful of vectorized instructions we’ll use in part 3. We still won’t be sorting anything.&lt;/li&gt;
  &lt;li&gt;In &lt;a href=&quot;/2020-01-30/this-goes-to-eleven-pt3&quot;&gt;part 3&lt;/a&gt;, we go through the initial code for the vectorized sorting, and we’ll start seeing some payoff. We finish agonizing courtesy of the CPU’s Branch Predictor, throwing a wrench into our attempts.&lt;/li&gt;
  &lt;li&gt;In part 4, we go over a handful of optimization approaches that I attempted trying to get the vectorized partitioning to run faster. We’ll see what worked and what didn’t.&lt;/li&gt;
  &lt;li&gt;In part 5, we’ll see how we can almost get rid of all the remaining scalar code- by implementing small-constant size array sorting. We’ll use, drum roll…, yet more AVX2 vectorization.&lt;/li&gt;
  &lt;li&gt;Finally, in part 6, I’ll list the outstanding stuff/ideas I have for getting more juice and functionality out of my vectorized code.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;quicksort-crash-course&quot;&gt;QuickSort Crash Course&lt;/h2&gt;

&lt;p&gt;QuickSort is deceivingly simple.&lt;br /&gt;
No, it really is.&lt;br /&gt;
In 20 lines of C# or whatever language you can sort numbers. Lots of them, and incredibly fast. However, try and change something about it; nudge it in the wrong way, and it will quickly turn around and teach you a lesson in humility. It is hard to improve on it without breaking any of the tenants it is built upon.&lt;/p&gt;

&lt;h3 id=&quot;in-words&quot;&gt;In words&lt;/h3&gt;

&lt;p&gt;Before we discuss any of that, let’s describe QuickSort in words, code, pictures, and statistics:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;It uses a &lt;em&gt;divide-and-conquer&lt;/em&gt; approach.
    &lt;ul&gt;
      &lt;li&gt;In other words, it’s recursive.&lt;/li&gt;
      &lt;li&gt;It performs \(\mathcal{O}(n\log{}n)\) comparisons to sort &lt;em&gt;n&lt;/em&gt; items.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;It performs an in-place sort.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;That last point, referring to in-place sorting, sounds simple and neat, and it sure is from the perspective of the user: no additional memory allocation needs to occur regardless of how much data they’re sorting. While that’s great, I’ve spent days trying to overcome the correctness and performance challenges that arise from it, specifically in the context of vectorization. It is also essential to remain in-place since I intend for this to become a &lt;em&gt;drop-in&lt;/em&gt; replacement for &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;More concretely, QuickSort works like this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Pick a pivot value.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Partition&lt;/strong&gt; the array around the pivot value.&lt;/li&gt;
  &lt;li&gt;Recurse on the left side of the pivot.&lt;/li&gt;
  &lt;li&gt;Recurse on the right side of the pivot.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Picking a pivot could be a mini-post in itself, but again, in the context of competing with &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; we don’t need to dive into it, we’ll copy whatever CoreCLR does, and get on with our lives.&lt;br /&gt;
CoreCLR uses a pretty standard scheme of median-of-three for pivot selection, which can be summed up as: “Let’s sort these 3 elements: In the first, middle and last positions, then pick the middle one of those three as the pivot”.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Partitioning&lt;/strong&gt; the array is where we spend most of the execution time: we take our selected pivot value and rearrange the array segment that was handed to us such that all numbers &lt;em&gt;smaller-than&lt;/em&gt; the pivot are in the beginning or &lt;strong&gt;left&lt;/strong&gt;, in no particular order amongst themselves. Then comes the &lt;em&gt;pivot&lt;/em&gt;, in its &lt;strong&gt;final&lt;/strong&gt; resting position, and following it are all elements &lt;em&gt;greater-than&lt;/em&gt; the pivot, again in no particular order amongst themselves.&lt;/p&gt;

&lt;p&gt;After partitioning is complete, we recurse to the left and right of the pivot, as previously described.&lt;/p&gt;

&lt;p&gt;That’s all there is: this gets millions, billions of numbers sorted, in-place, efficiently as we know how to do 60+ years after its invention.&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;Bonus trivia points for those who are still here with me: &lt;a href=&quot;https://en.wikipedia.org/wiki/Tony_Hoare&quot;&gt;Tony Hoare&lt;/a&gt;, who invented QuickSort back in the early 60s also took responsibility for inventing the &lt;code class=&quot;highlighter-rouge&quot;&gt;null&lt;/code&gt; pointer concept. So I guess there really is no good without evil in this world.&lt;/p&gt;

&lt;h3 id=&quot;in-code&quot;&gt;In code&lt;/h3&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PickPivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivotPos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivotPos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;QuickSort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivotPos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PickPivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;  &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;nf&quot;&gt;SwapIfGreater&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;   &lt;span class=&quot;k&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Partition&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pivot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;--;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++]&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;right&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;--]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;left&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I did say it is deceptively simple, and grasping how QuickSort really works sometimes feels like trying to lift sand through your fingers; To that end I’ve included two more visualizations of QuickSort, which are derivatives of the amazing work done by &lt;a href=&quot;https://observablehq.com/@mbostock&quot;&gt;Michael Bostock (@mbostock)&lt;/a&gt; with &lt;a href=&quot;https://d3js.org/&quot;&gt;d3.js&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;visualizing-quicksorts-recursion&quot;&gt;Visualizing QuickSort’s recursion&lt;/h3&gt;

&lt;p&gt;One thing that we have to keep in mind is that the same data is partitioned over-and-over again, many times, with ever-shrinking partition sizes until we end up having a partition size of 2 or 3, in which case we can trivially sort the partition as-is and return.&lt;/p&gt;

&lt;p&gt;To help see this better, we’ll use this way of visualizing arrays and their intermediate states in QuickSort:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;

    &lt;p&gt;&lt;img src=&quot;/talks/intrinsics-sorting-2019/quicksort-mbostock/quicksort-vis-legend.svg&quot; alt=&quot;QuickSort Legend&quot; /&gt;&lt;/p&gt;

  &lt;/div&gt;

  &lt;p&gt;Here, we see an unsorted array of 200 elements (in the process of getting sorted).&lt;br /&gt;
The different sticks represent numbers in the  [-45°..+45°] range, and the angle of each individual stick represents its value, as I hope it is easy to discern.&lt;br /&gt;
We represent the pivots with &lt;strong&gt;two&lt;/strong&gt; colors:&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;&lt;span style=&quot;color: red&quot;&gt;&lt;strong&gt;Red&lt;/strong&gt;&lt;/span&gt; for the currently selected pivot at a given recursion level.&lt;/li&gt;
    &lt;li&gt;&lt;span style=&quot;color: green&quot;&gt;&lt;strong&gt;Green&lt;/strong&gt;&lt;/span&gt; for previous pivots that have already been partitioned around in previous rounds/levels of the recursion.&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Our ultimate goal is to go from the messy image above to the visually appeasing one below:&lt;/p&gt;

&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/talks/intrinsics-sorting-2019/quicksort-mbostock/quicksort-vis-sorted.svg&quot; alt=&quot;QuickSort Sorted&quot; /&gt;&lt;/p&gt;

&lt;p&gt;What follows is a static (e.g., non-animated) visualization that shows how pivots are randomly selected at each level of recursion and how, by the next step, the unsorted segments around them become partitioned until we finally have a completely sorted array. Here is how the whole thing looks:&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;These visuals are auto-generated in Javascript + d3.js, so feel free to hit that “Reload” button and/or change the number of elements in the array  if you feel you want to see a new set of random sticks sorted.&lt;/p&gt;

&lt;iframe src=&quot;../talks/intrinsics-sorting-2019/quicksort-mbostock/qs-static-reload.html&quot; scrolling=&quot;no&quot; style=&quot;width:1600px; max-width: 100%;background: transparent;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;p&gt;I encourage you to look at this and try to explain to yourself what QuickSort “does” here, at every level. What you can witness here is the interaction between pivot selection, where it “lands” in the next recursion level (or row), and future pivots to its left and right and in the next levels of recursion. We also see how, with every level of recursion, the partition sizes decrease in until finally, every element is a pivot, which means sorting is complete.&lt;/p&gt;

&lt;h3 id=&quot;visualizing-quicksorts-comparisonsswaps&quot;&gt;Visualizing QuickSort’s Comparisons/Swaps&lt;/h3&gt;

&lt;p&gt;While the above visualization really does a lot to help understand &lt;strong&gt;how&lt;/strong&gt; QuickSort works, I also wanted to leave you with an impression of the total amount of work done by QuickSort:&lt;/p&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
&lt;iframe src=&quot;../talks/intrinsics-sorting-2019/quicksort-mbostock/qs-animated-playpause.html&quot; scrolling=&quot;no&quot; style=&quot;width:1600px; height: 250px; max-width: 100%;background: transparent;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;

  &lt;p&gt;Above is an &lt;strong&gt;animation&lt;/strong&gt; of the whole process as it goes over the same array, slowly and recursively going from an unsorted mess to a completely sorted array.&lt;/p&gt;

  &lt;p&gt;We can witness just how many comparisons and swap operations need to happen for a 200 element QuickSort to complete successfully. There’s genuinely a lot of work that needs to happen per element (when considering how we re-partition virtually all elements again and again) for the whole thing to finish.&lt;/p&gt;
&lt;/div&gt;

&lt;h3 id=&quot;arraysort-vs-quicksort&quot;&gt;Array.Sort vs. QuickSort&lt;/h3&gt;

&lt;p&gt;It’s important to note that &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; uses a couple of more tricks to get better performance and avoid certain dark-spots the come with QuickSort. I would be irresponsible if I didn’t mention those since in the later posts, I borrow at least one idea from its play-book, and improve upon it with intrinsics.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; isn’t strictly QuickSort; it is a variation on it called &lt;a href=&quot;https://en.wikipedia.org/wiki/Introsort&quot;&gt;Introspective Sort&lt;/a&gt; invented by &lt;a href=&quot;https://en.wikipedia.org/wiki/David_Musser&quot;&gt;David Musser&lt;/a&gt; in 1997. What it roughly does is combine Quick-Sort, Heap-Sort, and Insertion-Sort by dynamically switching between them: more specifically it starts with quick-sort and &lt;em&gt;may&lt;/em&gt; switch to heap-sort if the recursion depth goes beyond a specific threshold while also switching into insertion-sort if the size of the partition goes below a different threshold. This hybrid approach is a clever way of mitigating the two biggest shortcomings in quick-sort alone:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;QuickSort is notorious for degenerating into \(\mathcal{O}(n^2)\) for various edge-cases input sequences. I won’t go very deeply into this, but think about an array that is made up of a single repeated number. In such an extreme case, partitioning results in a bad separation around the pivot (e.g. one sub-partition will always have a size of &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;) for each partitioning attempt, and the whole thing goes south very quickly.
    &lt;ul&gt;
      &lt;li&gt;Introspective-sort mitigates such bad cases by tracking the current recursion depth vs. an acceptable worst-case depth (usually \(\mathcal 2*(floor(log_{2}(n))+1)\)). Once the measured/actual depth crosses over that threshold, introspective-sort switches internally from partitioning/quick-sort to heap-sort which deals with such cases better, on average.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Lastly, once the partition is small enough, introspective-sort switches to using insertion-sort. This is a critical improvement when we consider that recursive calls are never cheap (even more so for the code I’ll present later in this series). In CoreCLR/C#, where this threshold was selected to be 16 elements, this hybrid approach manages to replace up to 3 levels of recursive calls (or \(\mathcal 2^{n+1}-1 = {2^4}-1 = 15\) partitioning calls on average) with a &lt;strong&gt;single&lt;/strong&gt; call to insertion-sort, which is very effective for these small input sizes anyway. The impact of this optimization, where recursion is replaced with simpler loop-based code, cannot be overstated.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As mentioned, I ended up borrowing this last idea for my code as the issues around smaller partition sizes are exacerbated by using vectorized intrinsics in the following posts.&lt;/p&gt;

&lt;p&gt;For the unfriendly cases I mentioned before, I have no vectorized approach yet (OK, I kind of do, but I have no intention of making this a 9-post blog series :). However, I have no problem admitting to this while weaseling my way out of this pit of despair in the most direct way: use the same logic that introspective-sort uses for switching to heap-sort (where it triggers when the depth exceeds some dynamically computed threshold) and in-turn switch to… &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;; We let &lt;em&gt;it&lt;/em&gt; stumble a bit with the same input until it will give up and switch internally to heap-sort. It’s slightly nasty, but it works…&lt;/p&gt;

&lt;h2 id=&quot;comparing-scalar-variants&quot;&gt;Comparing Scalar Variants&lt;/h2&gt;

&lt;p&gt;With all this new information, this is a good time to measure how a couple of different scalar (e.g. non-vectorized) versions compare to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;. I’ll show some results generated using &lt;a href=&quot;https://benchmarkdotnet.org/&quot;&gt;BenchmarkDotNet&lt;/a&gt; (BDN) with:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort()&lt;/code&gt; as the baseline.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/Scalar/Managed.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Managed&lt;/code&gt;&lt;/a&gt; as the code I’ve just presented above.
    &lt;ul&gt;
      &lt;li&gt;This version is just basic QuickSort using regular/safe C#. With this version, every time we access an array element, the JIT inserts bounds-checking machine code around our actual access that ensures the CPU does not read/write outside the memory region owned by the array.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/damageboy/VxSort/blob/research/VxSortResearch/Unstable/Scalar/Unmanaged.cs&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Unmanaged&lt;/code&gt;&lt;/a&gt; as an alternative/faster version to &lt;code class=&quot;highlighter-rouge&quot;&gt;Scalar&lt;/code&gt; where:
    &lt;ul&gt;
      &lt;li&gt;The code uses native pointers and unsafe semantics (using C#‘s new &lt;code class=&quot;highlighter-rouge&quot;&gt;unmanaged&lt;/code&gt; constraint, neat!).&lt;/li&gt;
      &lt;li&gt;We switch to &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; (again, copy-pasted from CoreCLR) when below 16 elements, just like &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; does.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ve prepared this last version to show that with unsafe code + &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt;, we can remove most of the performance gap between C# and C++ for this type of code, which mainly stems from bounds-checking, that the JIT cannot elide for these sort of random-access patterns as well as the jump-to &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; optimization.&lt;/p&gt;

&lt;table style=&quot;margin-bottom: 0em&quot; class=&quot;notice--info&quot;&gt;
&lt;tr&gt;
&lt;td style=&quot;border: none;vertical-align: top&quot;&gt;&lt;span class=&quot;uk-label&quot;&gt;Note&lt;/span&gt;&lt;/td&gt;
&lt;td style=&quot;border: none&quot;&gt;&lt;div&gt;
        &lt;p&gt;Throughout this series, I’ll benchmark each sorting method with various array sizes (BDN parameter: &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;): \(10^i_{i=1\cdots7}\). I’ve added a custom column to the BDN column to the report: &lt;code class=&quot;highlighter-rouge&quot;&gt;Time / N&lt;/code&gt;. This represents the time spent sorting &lt;em&gt;per element&lt;/em&gt; in the array, and as such, very useful to compare the results on a more uniform scale.&lt;br /&gt;
In addition, I will only start with purely randon and unique sets of values, as that is a classical input type where I want to focus for this series.&lt;br /&gt;
When I actually get to submitting a PR, I will have to show more test cases and prove that the whole thing doesn’t crumble once the input is less than optimal, but that is &lt;em&gt;outside of the scope&lt;/em&gt; for this series.&lt;/p&gt;
      &lt;/div&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;Here are the results in the form of charts and tables. I’ve included a handy large button you can press to get a quick tour of what each tab contains, what we have here is:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;A chart scaling the performance of various implementations being compared to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; as a ratio.&lt;/li&gt;
  &lt;li&gt;A chart showing time spent sorting a single element in an array of N elements (Time / N).&lt;/li&gt;
  &lt;li&gt;BDN results in a friendly table form.&lt;/li&gt;
  &lt;li&gt;Statistics/Counters that teach us about what is actually going on under the hood.&lt;/li&gt;
&lt;/ol&gt;

&lt;div&gt;
  &lt;div class=&quot;stickemup&quot;&gt;
&lt;ul class=&quot;uk-tab&quot; data-uk-switcher=&quot;{connect:'#e34157f6-a85d-4a6d-9972-3d77cd7e5f87'}&quot;&gt;

	&lt;li class=&quot;uk-active&quot;&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Scaling&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-stats&quot;&gt;&lt;/i&gt; Time/N&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Benchmarks&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-list-alt&quot;&gt;&lt;/i&gt; Statistics&lt;/a&gt;&lt;/li&gt;

	&lt;li&gt;&lt;a href=&quot;#&quot;&gt;&lt;i class=&quot;glyphicon glyphicon-info-sign&quot;&gt;&lt;/i&gt; Setup&lt;/a&gt;&lt;/li&gt;

&lt;/ul&gt;

&lt;ul id=&quot;e34157f6-a85d-4a6d-9972-3d77cd7e5f87&quot; class=&quot;uk-switcher uk-margin&quot;&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Performance scale: Array.Sort (solid gray) is always 100%, and the other methods are scaled relative to it&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
ArraySort,1,1,1,1,1,1
Scalar,2.04,1.57,1.33,1.12,1.09,1.11
Unmanaged,1.75,1.01,0.99,0.97,0.93,0.95
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
    { 
      &quot;backgroundColor&quot;: &quot;rgba(66,66,66,0.35)&quot;,
      &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;solid&quot;, &quot;hachureAngle&quot;: -30, &quot;hachureGap&quot;: 7	}
    },
    { 
      &quot;backgroundColor&quot;: &quot;rgba(220,33,33,.6)&quot;, 
      &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 15, &quot;hachureGap&quot;: 6	} 
    },
    { 
      &quot;backgroundColor&quot;: &quot;rgba(33,33,220,.9)&quot;,
      &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -45, &quot;hachureGap&quot;: 6	} 
    }]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;Scalar Sorting - Scaled to Array.Sort&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;ticks&quot;: { 
          &quot;min&quot;: 0.8, 
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;callback&quot;: &quot;ticksPercent&quot; 
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Scaling (%)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;div data-intro=&quot;Size of the sorting problem, 10..10,000,000 in powers of 10&quot; data-position=&quot;bottom&quot;&gt;
&lt;div data-intro=&quot;Time in nanoseconds spent sorting per element. Array.Sort (solid gray) is the baseline, again&quot; data-position=&quot;left&quot;&gt;
&lt;div data-intro=&quot;Click legend items to show/hide series&quot; data-position=&quot;right&quot;&gt;
&lt;div class=&quot;benchmark-chart-container&quot;&gt;
&lt;canvas data-chart=&quot;line&quot;&gt;
N,100,1K,10K,100K,1M,10M
ArraySort,12.1123,30.5461,54.641,60.4874,70.7539,80.8431
Scalar,24.7385,47.8796,72.7528,67.7419,77.3906,89.7593
Unmanaged,21.0955,30.9692,54.3112,58.9577,65.7222,76.8631
&lt;!-- 
{ 
 &quot;data&quot; : {
  &quot;datasets&quot; : [
    { &quot;backgroundColor&quot;:&quot;rgba(66,66,66,0.35)&quot;, &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;solid&quot;, &quot;hachureGap&quot;: 6	} },
    { &quot;backgroundColor&quot;:&quot;rgba(33,220,33,.6)&quot;, &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: 15, &quot;hachureGap&quot;: 6	} },
    { &quot;backgroundColor&quot;:&quot;rgba(33,33,220,.9)&quot;, &quot;rough&quot;: { &quot;fillStyle&quot;: &quot;hachure&quot;, &quot;hachureAngle&quot;: -45, &quot;hachureGap&quot;: 6	} }
]
 },
 &quot;options&quot;: {
    &quot;title&quot;: { &quot;text&quot;: &quot;Scalar Sorting - log(Time/N)&quot;, &quot;display&quot;: true },
    &quot;scales&quot;: { 
      &quot;yAxes&quot;: [{ 
        &quot;type&quot;: &quot;logarithmic&quot;,
        &quot;ticks&quot;: {
          &quot;callback&quot;: &quot;ticksNumStandaard&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;          
        },
        &quot;scaleLabel&quot;: {
          &quot;labelString&quot;: &quot;Time/N (ns)&quot;,
          &quot;fontFamily&quot;: &quot;Indie Flower&quot;,
          &quot;display&quot;: true
        }
      }]
    }
 },
 &quot;defaultOptions&quot;: {&quot;scales&quot;:{&quot;xAxes&quot;:[{&quot;scaleLabel&quot;:{&quot;display&quot;:&quot;true,&quot;,&quot;labelString&quot;:&quot;N (elements)&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;},&quot;ticks&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}]},&quot;legend&quot;:{&quot;display&quot;:true,&quot;position&quot;:&quot;bottom&quot;,&quot;labels&quot;:{&quot;fontFamily&quot;:&quot;Indie Flower&quot;,&quot;fontSize&quot;:14}},&quot;title&quot;:{&quot;position&quot;:&quot;top&quot;,&quot;fontFamily&quot;:&quot;Indie Flower&quot;}}
}
--&gt; &lt;/canvas&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/Bench.BlogPt1_Int32_-report.datatable.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table represents a benchmark result&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;TargetMethodColumn.Method&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;
            Method&lt;br /&gt;Name
          &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;N&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;
            Problem&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;TimePerNDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-interval-muted&quot;&gt;
            &lt;span data-intro=&quot;Time in nanoseconds spent sorting each element in the array (with confidence intervals in parenthesis)&quot; data-position=&quot;top&quot;&gt;
              Time /&lt;br /&gt;Element (ns)
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;RatioDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal-percentage&quot;&gt;
            &lt;span data-intro=&quot;Each result is scaled to its baseline (Array.Sort in this case)&quot; data-position=&quot;top&quot;&gt;
                  Scaling
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;Measurements&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-vertical&quot;&gt;
            &lt;span data-intro=&quot;Raw benchmark results visualize how stable the result it. Longest/Shortest runs marked with &amp;lt;span style='color: red'&amp;gt;Red&amp;lt;/span&amp;gt;/&amp;lt;span style='color: green'&amp;gt;Green&amp;lt;/span&amp;gt;&quot; data-position=&quot;top&quot;&gt;Measurements&lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div&gt;
&lt;button class=&quot;helpbutton&quot; data-toggle=&quot;chardinjs&quot; onclick=&quot;$('body').chardinJs('start')&quot;&gt;&lt;object style=&quot;pointer-events: none;&quot; type=&quot;image/svg+xml&quot; data=&quot;/assets/images/help.svg&quot;&gt;&lt;/object&gt;&lt;/button&gt;
&lt;table class=&quot;table datatable&quot; data-json=&quot;../_posts/scalar-vs-unmanaged-stats.json&quot; data-id-field=&quot;name&quot; data-pagination=&quot;true&quot; data-page-list=&quot;[9, 18]&quot; data-intro=&quot;Each row in this table contains statistics collected &amp;amp; averaged out of thousands of runs with random data&quot; data-position=&quot;left&quot; data-show-pagination-switch=&quot;false&quot;&gt;
  &lt;thead data-intro=&quot;The header can be used to sort/filter by clicking&quot; data-position=&quot;right&quot;&gt;
    &lt;tr&gt;
        &lt;th data-field=&quot;MethodName&quot; data-sortable=&quot;true&quot; data-filter-control=&quot;select&quot;&gt;
          &lt;span data-intro=&quot;The name of the benchmarked method&quot; data-position=&quot;top&quot;&gt;Method&lt;br /&gt;Name&lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;ProblemSize&quot; data-sortable=&quot;true&quot; data-value-type=&quot;int&quot; data-filter-control=&quot;select&quot;&gt;
            &lt;span data-intro=&quot;The size of the sorting problem being benchmarked (# of integers)&quot; data-position=&quot;top&quot;&gt;Problem&lt;br /&gt;Size&lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;MaxDepthScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;span data-intro=&quot;The maximal depth of recursion reached while sorting&quot; data-position=&quot;top&quot;&gt;Max&lt;br /&gt;Depth&lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumPartitionOperationsScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;span data-intro=&quot;# of partitioning operations for each sort&quot; data-position=&quot;top&quot;&gt;#&lt;br /&gt;Part-&lt;br /&gt;itions&lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;AverageSmallSortSizeScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;span data-intro=&quot;For hybrid sorting, the average size that each small sort operation was called with (e.g. InsertionSort)&quot; data-position=&quot;top&quot;&gt;
            Avg.&lt;br /&gt;Small&lt;br /&gt;Sorts&lt;br /&gt;Size
            &lt;/span&gt;
        &lt;/th&gt;
        &lt;th data-field=&quot;NumScalarComparesScaledDataTable&quot; data-sortable=&quot;true&quot; data-value-type=&quot;inline-bar-horizontal&quot;&gt;
            &lt;span data-intro=&quot;How many branches were executed in each sort operation that were based on the unsorted array elements&quot; data-position=&quot;top&quot;&gt;
            # Data-&lt;br /&gt;Based&lt;br /&gt;Branches
            &lt;/span&gt;
            &lt;/th&gt;
        &lt;th data-field=&quot;PercentSmallSortCompares&quot; data-sortable=&quot;true&quot; data-value-type=&quot;float2-percentage&quot;&gt;
            &lt;span data-intro=&quot;What percent of&amp;lt;/br&amp;gt;⬅&amp;lt;br/&amp;gt;branches happenned as part of small-sorts&quot; data-position=&quot;top&quot;&gt;
            % Small&lt;br /&gt;Sort&lt;br /&gt;Data-&lt;br /&gt;Based&lt;br /&gt;Branches
            &lt;/span&gt;
        &lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/li&gt;

	&lt;li&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;v0.12.0, &lt;span class=&quot;nv&quot;&gt;OS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clear-linux-os 32120
Intel Core i7-7700HQ CPU 2.80GHz &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Kaby Lake&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 1 CPU, 4 logical and 4 physical cores
.NET Core &lt;span class=&quot;nv&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3.1.100
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Host]     : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT
  Job-DEARTS : .NET Core 3.1.0 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;CoreCLR 4.700.19.56402, CoreFX 4.700.19.56404&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, X64 RyuJIT

&lt;span class=&quot;nv&quot;&gt;InvocationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;3  &lt;span class=&quot;nv&quot;&gt;IterationCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;15  &lt;span class=&quot;nv&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;2
&lt;span class=&quot;nv&quot;&gt;UnrollFactor&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1  &lt;span class=&quot;nv&quot;&gt;WarmupCount&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;10

&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;grep&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'stepping\|model\|microcode'&lt;/span&gt; /proc/cpuinfo | &lt;span class=&quot;nb&quot;&gt;head&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-4&lt;/span&gt;
model           : 158
model name      : Intel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Core&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;TM&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; i7-7700HQ CPU @ 2.80GHz
stepping        : 9
microcode       : 0xb4
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;/li&gt;

&lt;/ul&gt;

&lt;/div&gt;

  &lt;p&gt;Surprisingly&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;5&lt;/a&gt;&lt;/sup&gt;, the unmanaged C# version is running slightly faster than &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;, but with one caveat: it only outperforms the C++ version for large inputs. Otherwise, everything is as expected: The purely &lt;code class=&quot;highlighter-rouge&quot;&gt;Managed&lt;/code&gt; variant is just slow, and the &lt;code class=&quot;highlighter-rouge&quot;&gt;Unamanged&lt;/code&gt; one mostly is on par with &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;.&lt;br /&gt;
These C# implementations were written to &lt;strong&gt;verify&lt;/strong&gt; that we can get to &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; &lt;em&gt;like&lt;/em&gt; performance in C#, and they do just that. Running 5% faster for &lt;em&gt;some&lt;/em&gt; input sizes will not cut it for me; I want it &lt;em&gt;much&lt;/em&gt; faster. An equally important reason for re-implementing these basic versions is that we can now sprinkle &lt;em&gt;statistics-collecting-code&lt;/em&gt; magic fairy dust&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;6&lt;/a&gt;&lt;/sup&gt; on them so that we have even more numbers to dig into in the “Statistics” tab: These counters will assist us in deciphering and comparing future results and implementations. In this post they serve us by establishing a baseline. We can see, per each &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; value (with some commentary):&lt;/p&gt;

  &lt;ul&gt;
    &lt;li&gt;The maximal recursion depth. Note that:
      &lt;ul&gt;
        &lt;li&gt;The unmanaged version, like CoreCLR’s &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; switches to &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; for the last couple of recursion levels, therefore, its maximal depth is smaller.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;The total number of partitioning operations performed.
      &lt;ul&gt;
        &lt;li&gt;Same as above, less recursion ⮚ less partitioning calls.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;The average size of what I colloquially refer to as “small-sort” operations performed (e.g., &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Unmanaged&lt;/code&gt; variant).
      &lt;ul&gt;
        &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;Managed&lt;/code&gt; version doesn’t have any of this, so it’s just 0.&lt;/li&gt;
        &lt;li&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Unmanaged&lt;/code&gt; version, we see a consistent value of 9.x: Given that we special case 1,2,3 in the code and 16 is the upper limit, 9.x seems like a reasonable outcome here.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;The number of branch operations that were user-data dependent; This one may be hard to relate to at first, but it becomes apparent why this is a crucial number to track starting with the 3&lt;sup&gt;rd&lt;/sup&gt; post onwards. For now, a definition: This statistic counts &lt;em&gt;how many&lt;/em&gt; times our code did an &lt;code class=&quot;highlighter-rouge&quot;&gt;if&lt;/code&gt; or a &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt; or any other branch operation &lt;em&gt;whose condition depended on unsorted user supplied data&lt;/em&gt;!
      &lt;ul&gt;
        &lt;li&gt;The numbers boggle the mind, this is the first time we get to show how much work is involved.&lt;/li&gt;
        &lt;li&gt;What’s even more surprising that for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Unmanged&lt;/code&gt; variant, the number is even higher (well only surprising if you don’t know anything about how &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt; works…) and yet this version seems to run faster… I have an entire post dedicated just to this part of the problem in this series, so let’s just make note of this for now, but already we see peculiar things.&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;Finally, I’ve also included a statistic here that shows what percent of those data-based branches came from small-sort operations. Again, this was 0% for the &lt;code class=&quot;highlighter-rouge&quot;&gt;Managed&lt;/code&gt; variant, but we can see that a large part of those compares are now coming from those last few levels of recursion that were converted to &lt;code class=&quot;highlighter-rouge&quot;&gt;InsertionSort&lt;/code&gt;…&lt;/li&gt;
  &lt;/ul&gt;

  &lt;p&gt;Some of these statistics will remain pretty much the same for the rest of this series, regardless of what we do next in future versions, while others radically change; We’ll observe and make use of these as key inputs in helping us to figure out how/why something worked, or not!&lt;/p&gt;

&lt;/div&gt;
&lt;h2 id=&quot;all-warmed-up&quot;&gt;All Warmed Up?&lt;/h2&gt;

&lt;p&gt;We’ve spent quite some time polishing our foundations concerning QuickSort and &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt;. I know lengthy introductions are somewhat dull, but I think time spent on this post will pay off with dividend when we next encounter our actual implementation in the 3&lt;sup&gt;rd&lt;/sup&gt; post and later on. This might be also a time to confess that just doing the leg-work to provide this refresher helped me come up with at least one, super non-trivial optimization, which I think I’ll keep the lid on all the way until the 6&lt;sup&gt;th&lt;/sup&gt; and final post. So never underestimate the importance of “just” covering the basics.&lt;/p&gt;

&lt;p&gt;Before we write vectorized code, we need to pick up some knowhow specific to vectorized intrinsics and introduce a few select intrinsics we’ll be using, so, this is an excellent time to break off this post, grab a fresh cup of coffee and head to the &lt;a href=&quot;/2020-01-29/this-goes-to-eleven-pt2&quot;&gt;next post&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:0&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Which is increasingly taking &lt;a href=&quot;https://github.com/damageboy/analyze-spec-benchmarks#integer&quot;&gt;more and more&lt;/a&gt; time to happen, due to Dennard scaling and the slow-down of Moore’s law… &lt;a href=&quot;#fnref:0&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Since CoreCLR 3.0 was release, a &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/27700&quot;&gt;PR&lt;/a&gt; to provide a span based version of this has been recently merged into the 5.0 master branch, but I’ll ignore this for the time being as it doesn’t seem to matter in this context. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;You can grab your microcode signature in one of the following methods: On Windows, the easiest way is to install and run the excellent HWiNFO64 application, it will show you the microcode signature. On line a &lt;code class=&quot;highlighter-rouge&quot;&gt;grep -i microcode /proc/cpuinfo&lt;/code&gt; does the tricks, and macOs: &lt;code class=&quot;highlighter-rouge&quot;&gt;sysctl -a | grep -i microcode&lt;/code&gt; will get the job done. Unfortunately you’ll have to consult your specific CPU model to figure out the before/after signature, and I can’t help you there, except to point out that the microcode update in question came out in November 13&lt;sup&gt;th&lt;/sup&gt; and is about mitigating the JCC errata. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:5&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I came, I Tried, &lt;a href=&quot;https://github.com/dotnet/runtime/pull/33152#issuecomment-596405021&quot;&gt;I Folded&lt;/a&gt; &lt;a href=&quot;#fnref:5&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Believe it or not, I pretty much wrote every other version features in this series &lt;em&gt;before&lt;/em&gt; I wrote the &lt;code class=&quot;highlighter-rouge&quot;&gt;Unmanaged&lt;/code&gt; one, so I really was quite surprised that it ended up being slightly faster that &lt;code class=&quot;highlighter-rouge&quot;&gt;Array.Sort&lt;/code&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;I have a special build configuration called &lt;code class=&quot;highlighter-rouge&quot;&gt;Stats&lt;/code&gt; which compiles in a bunch of calls into various conditionally compiled functions that bump various counters, and finally, dump it all to json and it eventually makes it all the way into these posts (if you dig deep you can get the actual json files :) &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">Decimating Array.Sort with AVX2. I ended up going down the rabbit hole re-implementing array sorting with AVX2 intrinsics. There's no reason I should go down alone.</summary></entry><entry><title type="html">Unsafe Bounds Checking</title><link href="https://bits.houmus.org/2019-11-08/unsafe-bounds-checking" rel="alternate" type="text/html" title="Unsafe Bounds Checking" /><published>2019-11-08T05:26:28+00:00</published><updated>2019-11-08T05:26:28+00:00</updated><id>https://bits.houmus.org/2019-11-08/unsafe-bounds-checking</id><content type="html" xml:base="https://bits.houmus.org/2019-11-08/unsafe-bounds-checking">&lt;h1 id=&quot;unsafe-bounds-checking&quot;&gt;Unsafe Bounds Checking&lt;/h1&gt;

&lt;p&gt;I thought I’d write a really short post on a nifty technique/trick I came up while trying to debug my own horrible unsafe code for vectorized sorting. I don’t think I’ve seen it used/shown before, and it really saved me tons of time.
It all boils down to a combination of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;using static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;#if DEBUG&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Local functions in C#&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Imagine this is our starting point:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GenerateRollingSum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lengthInVectors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This get's folded as a constant by the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// JIT and I hate typing this all over the place&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lengthInVectors&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pRead&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pWrite&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I’m providing here a very &lt;strong&gt;wrong&lt;/strong&gt; implementation, obviously, for the purpose of this post. Keen eyes will immediately notice that this method is going to make us very unhappy as it is writing partially into the same memory it is about to read in the next iteration. It’s definitely not going to work. But at the same time, it’s important to note that it isn’t going to crash or generate any exception, except for not doing it’s job.&lt;/p&gt;

&lt;p&gt;Unfortunately, for me, I’ve managed to write many variations of this bug, so I had to come up with something that would negate my in-built idiocy, here’s what I normally write with code like this these days:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// We import all the static methods in Avx&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GenerateRollingSum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lengthInVectors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// This get's folded as a constant by the&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// JIT and I hate typing this all over the place&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pEnd&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lengthInVectors&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pRead&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pWrite&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pEnd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pWrite&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;acc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cp&quot;&gt;#if DEBUG
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// &quot;Hijack&quot; LoadDquVector256 under DEBUG configuration&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// and assert for various constraint violations&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lengthInVectors&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;s&quot;&gt;&quot;Reading past end of array&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Finally call the real LoadDquVector256()&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;LoadDquVector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// &quot;Hijack&quot; LoadDquVector256 under DEBUG configuration&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// and assert for various constraint violations&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Vector256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lengthInVectors&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;s&quot;&gt;&quot;Writing past end of array&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pRead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                   &lt;span class=&quot;s&quot;&gt;&quot;Writing will overwrite unread data&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// Finally call the real Store()&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;Avx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see, this is a nifty way to abuse &lt;code class=&quot;highlighter-rouge&quot;&gt;using static&lt;/code&gt; statements with local functions. We override the &lt;code class=&quot;highlighter-rouge&quot;&gt;LoadDquVector256()&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;Store&lt;/code&gt; intrinsics only in &lt;code class=&quot;highlighter-rouge&quot;&gt;DEBUG&lt;/code&gt; mode, so there’s no performance hit that they incur in &lt;code class=&quot;highlighter-rouge&quot;&gt;RELEASE&lt;/code&gt;, and we also make use of the fact that they are defined as local functions to perform some in-depth &lt;code class=&quot;highlighter-rouge&quot;&gt;Debug.Assert()&lt;/code&gt;ing  that is based on the internal state of the function. Without defining these functions as local we would not be able to do so…&lt;/p&gt;

&lt;p&gt;This isn’t necessarily useful for vectorized code exclusively, but any code that is potentially tricky. I hope you find this useful! I don’t think I’ve seen this in the wild before.&lt;/p&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">Unsafe Bounds Checking</summary></entry><entry><title type="html">Hacking CoreCLR on Linux with CLion</title><link href="https://bits.houmus.org/2019-05-01/hacking-coreclr-on-linux-with-clion" rel="alternate" type="text/html" title="Hacking CoreCLR on Linux with CLion" /><published>2019-05-01T05:26:28+00:00</published><updated>2019-05-01T05:26:28+00:00</updated><id>https://bits.houmus.org/2019-05-01/hacking-coreclr-on-linux-with-clion</id><content type="html" xml:base="https://bits.houmus.org/2019-05-01/hacking-coreclr-on-linux-with-clion">&lt;h2 id=&quot;whatwhy&quot;&gt;What/Why?&lt;/h2&gt;

&lt;p&gt;Being a regular Linux user, when I can, I was looking for a decent setup for myself to grok then hack on CoreCLR’s C++ code.&lt;/p&gt;

&lt;p&gt;CoreCLR, namely the C++ code that implements the runtime (GC, JIT and more) is a BIG project, and trying to peel through its layers for the first time is no easy task for sure. While there are many great resources available for developers that want to read about the runtime such as the &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/README.md&quot;&gt;BotR&lt;/a&gt;, for me, there really is no replacement for reading the code and trying to reason about what/how it gets stuff done, preferably during a debug session, with a very focused task/inquiry at hand. For this reason, I really wanted a proper IDE for the huge swaths of C++ code, and I couldn’t think of anything else but &lt;a href=&quot;https://www.jetbrains.com/clion/&quot;&gt;JetBrains’ own CLion IDE&lt;/a&gt; under Linux (and macOS, which I’m not a user of).&lt;br /&gt;
With my final setup, I really can do non-trivial navigation on the code base such as:&lt;/p&gt;

&lt;video width=&quot;900&quot; controls=&quot;&quot;&gt;
    &lt;source src=&quot;../assets/images/clion-coreclr.webm&quot; type=&quot;video/webm&quot; /&gt;
&lt;/video&gt;

&lt;h2 id=&quot;loading-coreclr-with-clion-navigation&quot;&gt;Loading CoreCLR with CLion Navigation&lt;/h2&gt;

&lt;p&gt;CoreCLR is a beast of a project, and getting it to parse properly under CLion, moreover, it requires some non-trivial setup, so I thought I’d disclose my process here, for other people to see and maybe even improve upon…&lt;/p&gt;

&lt;p&gt;Generally speaking, all the puzzle pieces should fit since the CoreCLR build-system is 95% made of running &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; to generate standard GNU makefiles, and then builds the whole thing using said makefiles, where the other 5% is made of some scripts wrapping the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; build-system. At the same time, CLion builds upon &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; to bootstrap its own internal project representation, &lt;em&gt;provided&lt;/em&gt; that it can invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; just like the normal build would.&lt;/p&gt;

&lt;p&gt;Here’s what I did to get everything working:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First, We’ll clone and perform a single build of CoreCLR by &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/building/linux-instructions.md#environment&quot;&gt;following the instructions&lt;/a&gt;, What I did on my Ubuntu machine consisted of:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;sudo &lt;/span&gt;apt &lt;span class=&quot;nb&quot;&gt;install &lt;/span&gt;cmake llvm-3.9 clang-3.9 lldb-3.9 liblldb-3.9-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libcurl4-openssl-dev libssl-dev libnuma-dev libkrb5-dev
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;./build.sh checked
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Once the build is over, you should have everything under the &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/Product/Linux.x64.Checked&lt;/code&gt; like so:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;ls &lt;/span&gt;bin/Product/Linux.x64.Checked
bin           libcoreclr.so                  netcoreapp2.0
coreconsole   libcoreclrtraceptprovider.so   PDB
corerun       libdbgshim.so                  sosdocsunix.txt
createdump    libmscordaccore.so             SOS.NETCore.dll
crossgen      libmscordbi.so                 SOS.NETCore.pdb
gcinfo        libprotononjit.so              superpmi
IL            libsosplugin.so                System.Globalization.Native.a
ilasm         libsos.so                      System.Globalization.Native.so
ildasm        libsuperpmi-shim-collector.so  System.Private.CoreLib.dll
inc           libsuperpmi-shim-counter.so    System.Private.CoreLib.ni.&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;fe21e59b-7903-49b4-b2d3-67de152c1d7d&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;.map
lib           libsuperpmi-shim-simple.so     System.Private.CoreLib.xml
libclrgc.so   Loader
libclrjit.so  mcs
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Now that an initial build is over, we can be sure that some scripts that were crucial to generate a few headers essential for the rest of the compilation process were generated and CLion will be able to find all the necessary source code once we teach it how to…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;CLion needs to invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; with the same arguments that the build scripts use. To sniff out the &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; command-line we’ll use an *nix old-timer’s trick to generate traces for &lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt; run: use &lt;code class=&quot;highlighter-rouge&quot;&gt;bash -x&lt;/code&gt;. Unfortunately, nothing is ever so simple in life, and CoreCLR’s &lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt; script doesn’t directly invoke &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt;, so we will need to make this &lt;code class=&quot;highlighter-rouge&quot;&gt;-x&lt;/code&gt; parameter sticky or recursive. There is no better way to do this than the following somewhat convoluted procedure:&lt;br /&gt;
First we need to generate a wrapper-script for &lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt;, we’ll call it &lt;code class=&quot;highlighter-rouge&quot;&gt;build-wrapper.sh&lt;/code&gt;:&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;export SHELLOPTS &amp;amp;&amp;amp; ./build.sh &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\$&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;@&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; build-wrapper.sh
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;After we have our wrapper in place. we run it instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;build.sh&lt;/code&gt; like this:&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;bash &lt;span class=&quot;nt&quot;&gt;-x&lt;/span&gt; ./build-wrapper.sh checked
... &lt;span class=&quot;c&quot;&gt;# omitted&lt;/span&gt;
+ /usr/bin/cmake &lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Unix Makefiles'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;CHECKED &lt;span class=&quot;nt&quot;&gt;-DCMAKE_INSTALL_PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/dmg/projects/public/coreclr/bin/Product/Linux.x64.Checked &lt;span class=&quot;nt&quot;&gt;-DCMAKE_USER_MAKE_RULES_OVERRIDE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCLR_CMAKE_PGO_INSTRUMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;nt&quot;&gt;-DCLR_CMAKE_OPTDATA_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/dmg/.nuget/packages/optimization.linux-x64.pgo.coreclr/99.99.99-master-20190716.1 &lt;span class=&quot;nt&quot;&gt;-DCLR_CMAKE_PGO_OPTIMIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; /home/dmg/projects/public/coreclr &lt;span class=&quot;nt&quot;&gt;-B&lt;/span&gt; /home/dmg/projects/public/coreclr/bin/obj/Linux.x64.Checked
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Boom! We’ve hit that jackpot. For folks following this that are feeling a bit shaky, I’ve isolated the exact part we’re after below:&lt;/p&gt;

    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;-G&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Unix Makefiles'&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCMAKE_BUILD_TYPE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;CHECKED &lt;span class=&quot;nt&quot;&gt;-DCMAKE_INSTALL_PREFIX&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/dmg/projects/public/coreclr/bin/Product/Linux.x64.Checked &lt;span class=&quot;nt&quot;&gt;-DCMAKE_USER_MAKE_RULES_OVERRIDE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-DCLR_CMAKE_PGO_INSTRUMENT&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0 &lt;span class=&quot;nt&quot;&gt;-DCLR_CMAKE_OPTDATA_PATH&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/dmg/.nuget/packages/optimization.linux-x64.pgo.coreclr/99.99.99-master-20190716.1 &lt;span class=&quot;nt&quot;&gt;-DCLR_CMAKE_PGO_OPTIMIZE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;1 &lt;span class=&quot;nt&quot;&gt;-S&lt;/span&gt; /home/dmg/projects/public/coreclr &lt;span class=&quot;nt&quot;&gt;-B&lt;/span&gt; /home/dmg/projects/public/coreclr/bin/obj/Linux.x64.Checked
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The “hard” part is over. It’s a series of boring clicks from here on. it’s time to open up CLion and get this show on the road:
We’ll start with defining a clang-3.9 based toolchain, since on Linux Clion defaults to using the gcc toolchain (at least on Linux), while CoreCLR needs clang-3.9 to build itself:&lt;img src=&quot;/assets/images/clion-toolchains-coreclr.png&quot; alt=&quot;clion-toolchains-coreclr&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;With a toolchain setup, we need to tell &lt;code class=&quot;highlighter-rouge&quot;&gt;cmake&lt;/code&gt; about our build configuration, so we set it up like so:
&lt;img src=&quot;/assets/images/clion-cmake-coreclr.png&quot; alt=&quot;clion-cmake-coreclr&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;I’ve highlighted all the text boxes you’ll need to set. I’ll go over the less trivial stuff:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;The command line option we just set aside in (3) goes into the &lt;code class=&quot;highlighter-rouge&quot;&gt;CMake options&lt;/code&gt; field.&lt;br /&gt;
Unfortunately CLion doesn’t like single quotes (weird…), so I’ve had to change the &lt;code class=&quot;highlighter-rouge&quot;&gt;-G 'Unix Makefiles'&lt;/code&gt; into &lt;code class=&quot;highlighter-rouge&quot;&gt;-G &quot;Unix Makrfiles&quot;&lt;/code&gt; (notice the use of double quotes).&lt;/li&gt;
      &lt;li&gt;It would be a wise idea to share the same build folder as our initial command line build used, more over, we might end up going back and forth between CLion and the command line, so I override the “Generation Path” setting with the value &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/obj/Linux.x64.Checked&lt;/code&gt;. This is again extracted from the same command line we set-aside before. You’ll find it in my case towards the end, specified right after the &lt;code class=&quot;highlighter-rouge&quot;&gt;-B&lt;/code&gt; switch.&lt;/li&gt;
      &lt;li&gt;For the build options, I’ve specified &lt;code class=&quot;highlighter-rouge&quot;&gt;-j 8&lt;/code&gt;. This option controls how many parallel builds (compilers) are launched during the build process. A good default is to set it to 2x the number of physical cores your machine has, so in my case that means using &lt;code class=&quot;highlighter-rouge&quot;&gt;-j 8&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;That’s it, let CLion do it’s thing while grinding your machine to a halt, and once it’s done you can start navigating and building the CoreCLR project like a first class citizen of the civilized world :)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;debugging-coreclr-from-clion&quot;&gt;Debugging CoreCLR from CLion&lt;/h2&gt;

&lt;p&gt;Once we have CLion understanding the CoreCLR project structure we can take it up a notch and try to debug CoreCLR by launching “something” while setting a breakpoint.&lt;/p&gt;

&lt;p&gt;Let’s try to debug the JIT as an example for a useful scenario.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;First we need a console application:
    &lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tmp/
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dotnet new console &lt;span class=&quot;nt&quot;&gt;-n&lt;/span&gt; clion_dbg_sample
 The template &lt;span class=&quot;s2&quot;&gt;&quot;Console Application&quot;&lt;/span&gt; was created successfully.
 Processing post-creation actions...
 Running &lt;span class=&quot;s1&quot;&gt;'dotnet restore'&lt;/span&gt; on clion_dbg_sample/clion_dbg_sample.csproj...
 Restore completed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;54.39 ms &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; /tmp/clion_dbg_sample/clion_dbg_sample.csproj.

 Restore succeeded.

 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;clion_dbg_sample
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;dotnet publish &lt;span class=&quot;nt&quot;&gt;-c&lt;/span&gt; release &lt;span class=&quot;nt&quot;&gt;-o&lt;/span&gt; linux-x64 &lt;span class=&quot;nt&quot;&gt;-r&lt;/span&gt; linux-x64
 Microsoft &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;R&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Build Engine version 16.3.0+0f4c62fea &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; .NET Core
 Copyright &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;C&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; Microsoft Corporation. All rights reserved.

 Restore completed &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;66.26 ms &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; /tmp/clion_dbg_sample/clion_dbg_sample.csproj.
 clion_dbg_sample -&amp;gt; /tmp/clion_dbg_sample/bin/release/netcoreapp3.0/linux-x64/clion_dbg_sample.dll
 clion_dbg_sample -&amp;gt; /tmp/clion_dbg_sample/linux-x64/
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;Now we have a console application published in some folder, in my case it’s &lt;code class=&quot;highlighter-rouge&quot;&gt;/tmp/clion_dbg_sample/linux-x64&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Next we will setup a new configuration under CLion:&lt;br /&gt;
 &lt;img src=&quot;/assets/images/clion-edit-configurations-coreclr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Now we define a &lt;strong&gt;new&lt;/strong&gt; configuration:&lt;br /&gt;
 &lt;img src=&quot;/assets/images/clion-select-executable-coreclr.png&quot; alt=&quot;&quot; /&gt;
 We provide some name, I’ve decided to use the same name as my test program: &lt;code class=&quot;highlighter-rouge&quot;&gt;clion_dbg_sample&lt;/code&gt;, We select “All targets” as the Target, and under executable we need to choose “Select other…” to provide a custom path to &lt;code class=&quot;highlighter-rouge&quot;&gt;corerun&lt;/code&gt;. The reason behind this is that we need to run &lt;code class=&quot;highlighter-rouge&quot;&gt;corerun&lt;/code&gt; from a directory that actually contains the entire product: jit, gc and everything else.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The path we provide is to the &lt;code class=&quot;highlighter-rouge&quot;&gt;corerun&lt;/code&gt; executable that resides in the &lt;code class=&quot;highlighter-rouge&quot;&gt;bin/Product/Linux.x64.Checked&lt;/code&gt; folder:
 &lt;img src=&quot;/assets/images/clion-custom-executable-coreclr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Finally we provide our sample project from before to the &lt;code class=&quot;highlighter-rouge&quot;&gt;corerun&lt;/code&gt; executable. This is how my final configuration looks like:&lt;br /&gt;
 &lt;img src=&quot;/assets/images/clion-sample-configuration-final-coreclr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;It’s time to set a break-point and launch. As a generic sample I will navigate to &lt;code class=&quot;highlighter-rouge&quot;&gt;compiler.cpp&lt;/code&gt; and find the &lt;code class=&quot;highlighter-rouge&quot;&gt;jitNativeCode&lt;/code&gt; method. It’s pretty much one of the top-level functions in the JIT, and therefore a good candidate for us. If we set a breakpoint in that method and launch our newly created configuration, we should hit it in no time:
&lt;img src=&quot;/assets/images/clion-debug-jit-coreclr.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;We’re done! If you really want to figure out what to do next, it’s probably a good time to hit the &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/README.md&quot;&gt;BotR&lt;/a&gt;, namely the &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-overview.md&quot;&gt;RyuJit Overview&lt;/a&gt; and &lt;a href=&quot;https://github.com/dotnet/coreclr/blob/master/Documentation/botr/ryujit-tutorial.md&quot;&gt;RyuJit Tutorial&lt;/a&gt; pages that contain a more detailed overview of the JIT. Alternatively, if you’re a “get your hands dirty” sort of person, you can also do some warm-up exercises for your fingers and start hitting that step-into keyboard shortcut. You’re debugging the JIT as we speak!&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I hope this end up helping someone wanting to get started digging into the JIT not on Windows. I also personally have a strong preference for CLion as I really think it’s much more faster and powerful option than all the other stuff I’ve tried this far. At any rate, it’s the only viable option for Linux/macOs people.&lt;/p&gt;

&lt;p&gt;Have fun! Let me know on &lt;a href=&quot;https://twitter.com/damageboy&quot;&gt;twitter&lt;/a&gt; if you’re encountering any difficulties or you think I can make anything clearer…&lt;/p&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">What/Why?</summary></entry><entry><title type="html">.NET Core 3.0 Intrinsics in Real Life - (Part 3/3)</title><link href="https://bits.houmus.org/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3" rel="alternate" type="text/html" title=".NET Core 3.0 Intrinsics in Real Life - (Part 3/3)" /><published>2018-08-20T15:26:28+00:00</published><updated>2018-08-20T15:26:28+00:00</updated><id>https://bits.houmus.org/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3</id><content type="html" xml:base="https://bits.houmus.org/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3">&lt;p&gt;As I’ve described in &lt;a href=&quot;/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1&quot;&gt;part 1&lt;/a&gt; &amp;amp; &lt;a href=&quot;/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2&quot;&gt;part 2&lt;/a&gt; of this series, I’ve recently overhauled an internal data structure we use at Work&lt;sup&gt;®&lt;/sup&gt; to start using &lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md&quot;&gt;platform dependent intrinsics&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve not read the previous posts, I suggest you do so, as a lot of what is discussed here relies on the code and issues presented there…&lt;/p&gt;

&lt;p&gt;As a reminder, this series is made in 3 parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1&quot;&gt;The data-structure/operation that we’ll optimize and basic usage of intrinsics&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2&quot;&gt;Using intrinsics more effectively&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;The C++ version(s) of the corresponding C# code, and what I learned from them (this post).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of the code (C# &amp;amp; C++) is published under the &lt;a href=&quot;https://github.com/damageboy/bitgoo&quot;&gt;bitgoo github repo&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;c-vs-c&quot;&gt;C++ vs. C#&lt;/h2&gt;

&lt;p&gt;I think I’ve mentioned this somewhere before: I started working on better versions of my bitmap search function way before CoreCLR intrinsics were even imagined. This led me to start to tinkering with C++ code where I tried out most of my ideas. When CoreCLR 3.0 became real enough, I ported the C++ code back to C# (which surprisingly consisted of a couple of search and replace operations, no more…).&lt;/p&gt;

&lt;p&gt;As such, having two close implementations begs performing a head-to-head comparison.
After some additional work, I had basic &lt;a href=&quot;https://github.com/google/benchmark&quot;&gt;google benchmark&lt;/a&gt; and &lt;a href=&quot;https://github.com/google/googletest&quot;&gt;google test&lt;/a&gt; suites up and running&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;br /&gt;
I’ll cut right to the chase and present a relative comparison between C++ and C# for the last version we ran in our previous post, The C# method is &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNTAndBMI2Unrolled&lt;/code&gt; and the C++ one is &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNTAndBMI2Unrolled2&lt;/code&gt;:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th&gt;C# Mean (ns)&lt;/th&gt;
      &lt;th&gt;C++ Mean (ns)&lt;/th&gt;
      &lt;th&gt;C++/C# Ratio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;2.249&lt;/td&gt;
      &lt;td&gt;3.338&lt;/td&gt;
      &lt;td&gt;148.42%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td&gt;10.904&lt;/td&gt;
      &lt;td&gt;11.037&lt;/td&gt;
      &lt;td&gt;101.22%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td&gt;50.368&lt;/td&gt;
      &lt;td&gt;43.786&lt;/td&gt;
      &lt;td&gt;86.93%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td&gt;208.272&lt;/td&gt;
      &lt;td&gt;202.366&lt;/td&gt;
      &lt;td&gt;97.16%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td&gt;1,580.026&lt;/td&gt;
      &lt;td&gt;1,493.020&lt;/td&gt;
      &lt;td&gt;94.49%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td&gt;21,282.905&lt;/td&gt;
      &lt;td&gt;11,520.900&lt;/td&gt;
      &lt;td&gt;54.13%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td&gt;255,186.977&lt;/td&gt;
      &lt;td&gt;133,976.543&lt;/td&gt;
      &lt;td&gt;52.50%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td&gt;3,730,420.068&lt;/td&gt;
      &lt;td&gt;1,754,421.485&lt;/td&gt;
      &lt;td&gt;47.03%&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td&gt;56,939,817.593&lt;/td&gt;
      &lt;td&gt;26,613,731.568&lt;/td&gt;
      &lt;td&gt;46.74%&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;There are a few things that stand out from this comparison:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The percentage differences in the low bit counts (1,4) should be ignored, they are minuscule in absolute terms and within the margin of error.&lt;/li&gt;
  &lt;li&gt;C# is doing pretty well up to 256 bits when we &lt;strong&gt;don’t&lt;/strong&gt; execute the unrolled loop, it’s basically neck to neck with C++.&lt;/li&gt;
  &lt;li&gt;Sweet mercy, what is going on with 1024 bits an onwards, inside the unrolled loop? Why is there such a big difference for what is a relatively optimized (and equivalent) piece of code between the two languages?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I’ll cut to the chase and answer this last question directly, then, proceed to explain the underlying relevant basics (&lt;em&gt;tl;dr&lt;/em&gt;: it’s not so basic) of CPU pipelining and register renaming in order for the explanation to stick for people reading this that are not familiar with those terms/concepts.&lt;/p&gt;

&lt;p&gt;The bottom line is: there is a bug in the CPU! There is a well known (even if very cryptic) &lt;a href=&quot;https://www.intel.com/content/dam/www/public/us/en/documents/specification-updates/4th-gen-core-family-desktop-specification-update.pdf&quot;&gt;erratum&lt;/a&gt; about this bug, and compiler developers are more or less generally aware of this issue and have been &lt;em&gt;working around&lt;/em&gt; it for the better part of the last 5 years.&lt;/p&gt;

&lt;h3 id=&quot;false-dependencies&quot;&gt;False Dependencies&lt;/h3&gt;

&lt;p&gt;So what is this mysterious CPU bug all about? The JIT was producing what should be, according to the processor documentation, pretty good code:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nl&quot;&gt;BEGIN_POPCNT_UROLLED_LOOP:&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;jge&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;SHORT&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;BEGIN_POPCNT_UROLLED_LOOP&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;What we see above is an excerpt from &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNTAndBMI2Unrolled&lt;/code&gt; method’s assembly code, and more specifically the unrolled loop that does 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions in succession.&lt;/p&gt;

&lt;p&gt;Even if you are not an assembly guru, it’s pretty clear we have 4 pairs of &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; instructions, where:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction is &lt;strong&gt;reading&lt;/strong&gt; from successive memory addresses and &lt;strong&gt;writing&lt;/strong&gt; their result temporarily into a register &lt;em&gt;named&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This temporary value is then subtracted using &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; from another register which represents our good old C# variable &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; (the target-bit count).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;em&gt;high-level&lt;/em&gt; explanation of the bug goes like this:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;The CPU &lt;em&gt;should&lt;/em&gt; have &lt;strong&gt;detected&lt;/strong&gt; that each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; instruction &lt;em&gt;pair&lt;/em&gt; is effectively &lt;em&gt;independent&lt;/em&gt; of the previous pair (inside our unrolled loop and &lt;em&gt;between&lt;/em&gt; the loop’s iterations). In other words: although all 4 pairs are using the same destination register (&lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;), each such pair is really not dependent on the previous value of &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;This dependency analysis, performed by the CPU, &lt;em&gt;should&lt;/em&gt; have &lt;em&gt;enabled&lt;/em&gt; it to use an internal optimization called register-renaming (more on that later).&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;Had&lt;/em&gt; register renaming been triggered the CPU could have processed our &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions with a higher degree of parallelism: In other words, our CPU, would run a few &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions in &lt;strong&gt;parallel&lt;/strong&gt; at any given moment. This would lead to better perf or better IPC (Instruction-Per-Cycle ratio).&lt;/li&gt;
  &lt;li&gt;In reality, the bug is causing the CPU to delay the processing of each such pair of instructions for a few cycles, per pair, introducing a lot of “garbage time” inside the CPU, where it’s stalling, doing less work than it should, leading to the slowdown we are seeing.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Terminology wise, this sort of bug is called a &lt;em&gt;false-dependency&lt;/em&gt; bug: In our case, the CPU wrongfully introduces a dependency between the different &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions on their destination register, it &lt;em&gt;thinks&lt;/em&gt; each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction is &lt;strong&gt;not only writing&lt;/strong&gt; into &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; but &lt;strong&gt;also reading&lt;/strong&gt; from it! (it does no such thing)&lt;br /&gt;
Given that this false dependency now exists, it is preventing the CPU from using register-renaming to execute the code more efficiently.&lt;/p&gt;

&lt;p&gt;I will first focus on describing how compilers have been working around this, and afterward, I will describe in much more detail how the CPU employs register renaming to improve the throughput of the pipeline when the bug does not exist &lt;em&gt;or&lt;/em&gt; is worked around.&lt;/p&gt;

&lt;h3 id=&quot;working-around-false-dependencies&quot;&gt;Working Around False Dependencies&lt;/h3&gt;

&lt;p&gt;As I’ve mentioned, this bug has been around for quite some time: It was reported &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=62011&quot;&gt;somewhere in 2014&lt;/a&gt; and is unfortunately still persistent to this day on most Intel CPUs, at least when it comes to the &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;

&lt;p&gt;Luckily, compiler developers have been able to work around this issue with relative ease by generating &lt;em&gt;extra code&lt;/em&gt; that &lt;strong&gt;&lt;em&gt;breaks&lt;/em&gt;&lt;/strong&gt; the aforementioned false-dependency. As far as I can tell, the people who originally wrote the workarounds were Intel developers, so they had a very good understanding of the exact nature of this false-dependency. What they opted to do was make compilers introduce a single-byte instruction that clears the lower 32-bits of the &lt;em&gt;destination&lt;/em&gt; register. In our case, this comes in the form of a &lt;code class=&quot;highlighter-rouge&quot;&gt;xor esi, esi&lt;/code&gt; instruction. This is the shortest way (instruction length-wise) in x86 CPUs to zero out a register. This instruction is a well known special case in the CPU since it “knows” the future value of the destination register (0) even without executing it, or knowing what its original value ever was. It appears the Intel engineers &lt;em&gt;knew&lt;/em&gt; that the dependency is not the entire 64-bit register (&lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;) but only on the lower 32-bit part of that register (&lt;code class=&quot;highlighter-rouge&quot;&gt;esi&lt;/code&gt;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;) and took advantage of this understanding to introduce a single byte fix into the instruction stream, which is relatively very cheap.&lt;/p&gt;

&lt;p&gt;The correct x86 assembly, generated by a fixed JIT or compiler should look like this:&lt;/p&gt;

&lt;div class=&quot;language-nasm highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nl&quot;&gt;BEGIN_POPCNT_UROLLED_LOOP:&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;xor&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;; This breaks the dependency&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;xor&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;; This breaks the dependency&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;8&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;xor&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;; This breaks the dependency&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;xor&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;; This breaks the dependency&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;popcnt&lt;/span&gt;   &lt;span class=&quot;nb&quot;&gt;rsi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;qword&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;sub&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;esi&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;add&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rcx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;cmp&lt;/span&gt;      &lt;span class=&quot;nb&quot;&gt;rdx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;
&lt;span class=&quot;nf&quot;&gt;jge&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;SHORT&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;BEGIN_POPCNT_UROLLED_LOOP&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This short piece of code is the sort of code that gcc/clang would generate for &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; to work-around the bug. When read out of context, it looks silly… it appears like the compiler generated useless code, to begin with, and you’ll find people wondering about this publicly in stackoverflow and other forums from time to time, or worse yet: trying to “fix” it. But for most in-production x86 CPUs (e.g. all the ones that suffer from this false-dependency) this code will substantially outperform the original code we saw above…&lt;/p&gt;

&lt;h2 id=&quot;update-coreclr-does-the-right-thing&quot;&gt;Update: CoreCLR does the right thing&lt;/h2&gt;

&lt;p&gt;I originally started writing part 3 after I found this issue with the JIT, and submitting &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/19555&quot;&gt;an issue&lt;/a&gt;, thinking I would finish writing this post before anyone would fix the underlying issue. I was wrong on both counts: Writing this post became an ever-growing challenge as I attempted to explain pipelines and register-renaming for the uninitiated (below), while &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/19772&quot;&gt;Fei Peng fixed the issue&lt;/a&gt; in a matter of two weeks (Thanks!).&lt;/p&gt;

&lt;p&gt;What CoreCLR now does (since commit &lt;a href=&quot;https://github.com/dotnet/coreclr/pull/19772/commits/6957b4f44f0917209df89499b7c4071bb0bc1941&quot;&gt;6957b4f&lt;/a&gt;) is &lt;strong&gt;always&lt;/strong&gt; introduce the &lt;code class=&quot;highlighter-rouge&quot;&gt;xor dest, dest&lt;/code&gt; workaround/dependency breaker for the 3 affected instructions &lt;code class=&quot;highlighter-rouge&quot;&gt;LZCNT&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;TZCNT&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt;. This is &lt;em&gt;not the optimal&lt;/em&gt; solution since the JIT will introduce this both for CPUs afflicted with this bug (specific Intel CPUs) as well as CPUs that &lt;strong&gt;don’t&lt;/strong&gt; have this bug (All AMD CPUs and newer Intel CPUs).&lt;br /&gt;
From the discussion, it’s clear that this path was chosen for simplicity’s sake: it would require more infrastructure both to detect the correct CPU family inside the JIT, and introduce questions around what should the JIT do in case of AOT (Ahead Of Time) compilation, as well as require more testing infrastructure than what is currently in place on the one hand, while the one byte fix is very cheap even for CPUs that are not affected.&lt;/p&gt;

&lt;p&gt;Let’s see if this CoreCLR fix does anything to our unmodified piece of code…:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Mean (ns)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Scaled To “buggy” CoreCLR&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Scaled to C++&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.170&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.96&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.65&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11.910&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.09&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.08&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;55.016&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.09&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.26&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;225.156&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.08&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,637.336&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.04&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.10&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;11,698.421&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.55&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.02&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;149,247.146&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.58&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,904,945.748&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.51&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.09&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;27,712,720.427&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.49&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.04&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;It sure does! It appears now that the unrolled version is running roughly 85-101% faster for higher bit counts than it did with the previous, unfixed CoreCLR!. When compared to C++, performance is now pretty close and consistent for the important parts of the benchmark. If you consider, for a moment, that we got here by making the JIT spill out &lt;em&gt;an extra, supposedly useless&lt;/em&gt; instruction, this makes the achievement that much more impressive :), as before, &lt;a href=&quot;https://gist.github.com/damageboy/0266018efbbf0a8478aa4d50de1c894f&quot;&gt;here is the JITDump&lt;/a&gt; with the newly fixed JIT in place.&lt;/p&gt;

&lt;p&gt;Now, we can really see just how much of a profound effect this false-dependency had on performance. In theory, this might be the right time to finish this post, however, I couldn’t let it go without attempting to explain the underlying CPU internals of &lt;em&gt;how and why&lt;/em&gt; the false-dependency had such a deep effect on performance. For readers well aware of how CPU pipelines operate and how they interact with the register renaming functionality on a modern super-scalar out-of-order CPU this is a good time to stop reading.&lt;br /&gt;
What follows is me trying to explain how the CPU tries to handle loops of code effectively, and how register renaming plays an important role in that.&lt;/p&gt;

&lt;h2 id=&quot;the-lovehate-story-that-is-tight-loops-in-cpus&quot;&gt;The love/hate story that is tight loops in CPUs&lt;/h2&gt;

&lt;p&gt;It takes very little imagination to realize that CPUs spend a lot their processing time executing loops (or the same machine code multiple times, in this context). &lt;br /&gt;
We need to remember that CPUs achieve remarkable throughput (e.g. instructions per cycles, or IPC) even though the table, in some ways, is set &lt;strong&gt;against&lt;/strong&gt; them:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A modern CPU will often have a dozen or so stages in their pipeline (examples: 14 in Skylake, 19 in AMD Ryzen)
    &lt;ul&gt;
      &lt;li&gt;This means a single instruction will take about 14 cycles on my cpu from start to finish if we were only executing that instruction and waiting for it to complete!&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;The CPU attempts to handle multiple instructions in different stages of the pipeline, but it may become &lt;em&gt;stalled&lt;/em&gt; (i.e. do no work) when it needs to wait for a previous instruction to advance through the pipeline enough to have its result ready (this is generally referred to as instruction dependencies).&lt;/li&gt;
  &lt;li&gt;To improve the utilization of CPU caches (L1/2/3 caches) and memory bus utilization, most modern processors artificially limit the number of register &lt;strong&gt;names&lt;/strong&gt; they support for instructions (seems like in 2018 everyone has settled on 16 general purpose registers, except for PowerPC at 32)
    &lt;ul&gt;
      &lt;li&gt;That way instructions take up fewer bits and can be read more quickly over these highly subscribed resources (caches and memory bus).&lt;/li&gt;
      &lt;li&gt;The flip side of this design decision is that compilers do not have the ability to generate code that uses many different registers, which in turn leads them to generate more code fragments that are dependent of each other because of the limited register names available for them.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With that in mind, let’s take the same, short piece of assembly code, which was generated by the JIT for our last unrolled attempt at, and see how it theoretically executes on a Skylake CPU.&lt;/p&gt;

&lt;h2 id=&quot;visualizing-our-loop&quot;&gt;Visualizing our loop&lt;/h2&gt;

&lt;p&gt;Without any additional fanfare, lets introduce the following visualization:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/iaca-popcnt-retirement.svg&quot; alt=&quot;iaca-popcnt&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I created this diagram by prettifying a trace file generated by a little known tool made by Intel called  &lt;a href=&quot;https://software.intel.com/en-us/articles/intel-architecture-code-analyzer&quot;&gt;IACA&lt;/a&gt;, which stands for &lt;strong&gt;I&lt;/strong&gt;ntel &lt;strong&gt;A&lt;/strong&gt;rchitecture &lt;strong&gt;C&lt;/strong&gt;ode &lt;strong&gt;A&lt;/strong&gt;nalyzer. IACA takes a piece of machine code + target CPU family and produces a textual trace file that can help us see better what the CPU does, at every cycle of a relatively short loop.&lt;br /&gt;
If you dislike having to use commercial (non-OSS) tools, please note that there is a similar tool by the LLVM project called &lt;a href=&quot;https://llvm.org/docs/CommandGuide/llvm-mca.html&quot;&gt;llvm-mca&lt;/a&gt;, and you can even use it from the &lt;a href=&quot;https://godbolt.org/z/baOZWy&quot;&gt;infamous compiler-explorer&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Let’s try to break this diagram down:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The leftmost column contains the loop counter, I’ve limited the trace to 2 [0, 1] iterations of that loop, to keep everything compact.&lt;/li&gt;
  &lt;li&gt;Next, the instruction counter &lt;em&gt;within&lt;/em&gt; its respective loop. Clearly we have 11 instructions per loop.&lt;/li&gt;
  &lt;li&gt;Next, the disassembly, where we can see 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions and they are interleaved with 4 subtractions of each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; result from the register &lt;code class=&quot;highlighter-rouge&quot;&gt;rdx&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Next we see how the instructions are broken down to µops&lt;sup id=&quot;fnref:4&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:4&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;:&lt;br /&gt;
For now, we will simply make note that every &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; we have , having been encoded as an instruction that reads from memory AND calculates the population count, was broken down to two µops:
    &lt;ul&gt;
      &lt;li&gt;A load µop (&lt;code class=&quot;highlighter-rouge&quot;&gt;TYPE_LOAD&lt;/code&gt;) loading the data from its respective pointer.&lt;/li&gt;
      &lt;li&gt;An operation µop (&lt;code class=&quot;highlighter-rouge&quot;&gt;TYPE_OP&lt;/code&gt;) performing the actual &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt;ing into our destination register (&lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Then comes the real kicker: IACA &lt;strong&gt;simulates&lt;/strong&gt; what a Skylake CPU (specifically) &lt;em&gt;should&lt;/em&gt; be doing at every cycle of those two loop iterations and provides us with critical insight into the state that each instruction is at every cycle (relative to the beginning of the first loop). These states are described by the coded symbols in each box, which I will shortly describe in more detail.&lt;/li&gt;
&lt;/ul&gt;

&lt;p class=&quot;notice--warning&quot;&gt;It is important to note that IACA, while being Intel’s &lt;em&gt;own tool&lt;/em&gt; is &lt;strong&gt;not&lt;/strong&gt; aware of the Intel CPU bug I just described. It is simulating what that processor &lt;em&gt;should have&lt;/em&gt; done with NO false dependency…&lt;/p&gt;

&lt;p&gt;While all the various states of the instruction within the pipeline are interesting I will give some more meaning to specific states:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;mnemonic&lt;/th&gt;
      &lt;th&gt;Meaning&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;d&lt;/td&gt;
      &lt;td&gt;Dispatched to execution: The CPU has completed decoding and waiting for the instruction’s dependencies to be ready. Execution will begin in the next cycle&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;e&lt;/td&gt;
      &lt;td&gt;Executing: The instruction is being executed, often in multiple cycles within a specific execution port (unit) inside the CPU&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;w&lt;/td&gt;
      &lt;td&gt;Writeback: The instruction’s result is being written back to a register in the register-file (more on this below), where it will be available for other instructions that might have a dependency on that instruction&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;R&lt;/td&gt;
      &lt;td&gt;Retired: The temporary register used during the execution/writeback has to be written back to the “real” destination register, according to the original order of the program code, this is called retirement, after which the CPUs internal, temporary register is free again (more on this below)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I encourage you to try to follow this execution trace for a couple of instructions. I like to stare at these things for hours, trying to tell a story in my own head in the form of “what is the CPU thinking now” for each and every cycle. There is much we could say about this, but I will highlight a few remarkable things:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;I’ve highlighted the &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; symbol/stage with a &lt;span style=&quot;color:red&quot;&gt;&lt;strong&gt;red-ellipse&lt;/strong&gt;&lt;/span&gt;. For our purposes here, this represents the final stage of each instruction. To me, it’s very impressive to see how all of these instructions terminate execution either 0 or 1 cycles apart of each other.&lt;/li&gt;
  &lt;li&gt;By the time the first instruction (&lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt;) reaches the &lt;code class=&quot;highlighter-rouge&quot;&gt;R&lt;/code&gt; (retired) state at cycle 14, when it’s done, we are &lt;em&gt;already&lt;/em&gt; executing, in some pipeline stage or another, all instructions from the next 4 iterations of this unrolled loop (I’ve limited the visualization to only 2 iterations for brevity, but you get the hang of it).
    &lt;ul&gt;
      &lt;li&gt;The processor is already (speculatively) executing loads from memory to satisfy our &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions in loop iterations 1,2,3 before the first iteration has even completed running, and without even knowing for sure our loop would actually execute for that amount of iterations.&lt;/li&gt;
      &lt;li&gt;Quantitatively speaking: We have roughly 4 iterations of an 11 instruction loop (&amp;gt; 40 instructions) all running in parallel inside one core(!) of our processor. This is possible both because of the length of the pipeline (14 stages for this specific processor) and the fact that internally, the processor has multiple units or ports capable of running various instructions in parallel. This is often referred to as a super-scalar CPU.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In case you are interested in digging much more deeper than I can afford to go into this within this post, I suggest you read &lt;a href=&quot;http://www.lighterra.com/papers/modernmicroprocessors/&quot;&gt;Modern Microprocessors: A 90-Minute Guide!&lt;/a&gt; to get more detailed information about pipelines, super-scalar CPUs, everything I try to cover here, and more.&lt;/p&gt;

&lt;p&gt;For this post, I will focus on one key aspect that lies in the root of how the CPU manages to do so many things at the same time: register renaming.&lt;/p&gt;

&lt;h3 id=&quot;instruction-dependencies&quot;&gt;Instruction Dependencies&lt;/h3&gt;

&lt;p&gt;Let’s look at the code again, this time adding arrows between the various instructions, marking their interdependencies.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/popcnt-dependencies.svg&quot; alt=&quot;popcnt-deps&quot; /&gt;&lt;/p&gt;

&lt;p&gt;If we interpret this code naively (and wrongly), we see that &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; is being used in each and every instruction of this code fragment, this could lead us to assume that the heavy usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; is generating a long dependency chain:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; is writing into &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; is then used as a source for the subtraction from &lt;code class=&quot;highlighter-rouge&quot;&gt;rdx&lt;/code&gt;, so naturally, the &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt; instruction cannot proceed before &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; has the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;The next &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; is again writing to &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; but would seemingly be unable to write before the previous &lt;code class=&quot;highlighter-rouge&quot;&gt;sub&lt;/code&gt; has finished.&lt;/li&gt;
  &lt;li&gt;After four such operations, we loop (in turquoise) again and we are again taking a dependency on &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; at the beginning of the loop.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This naive dependency analysis pretty much contradicts the output we saw come out of IACA in the previous diagram without further explanation. It would seem impossible for the CPU to run so many things in parallel where every instruction here seems to have a dependency through the use of the &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; register.&lt;br /&gt;
Moreover, both our original C# and C++ code did not force the JIT/compiler to re-use the same register over and over. It could have allocated 4 different registers and used them to generate code where each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; pair would be independent of the previous one, so why didn’t it do so?&lt;br /&gt;
Well, it turns out there is no need to! The JIT/compiler is doing exactly what it needs to be doing, it is just us, that need to learn about a very important concept in modern processors called register renaming.&lt;/p&gt;

&lt;h3 id=&quot;register-renaming&quot;&gt;Register Renaming&lt;/h3&gt;

&lt;p&gt;To understand why anyone would need something like register renaming, we first need to understand that CPU designers are stuck between a rock and a hard place:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;On one hand they want to be able to read our program code as fast as possible, from memory 🡒 cache 🡒 instruction decoder (a.k.a CPU front end), this requirement leads down a path where they have to severely &lt;em&gt;limit&lt;/em&gt; the number of register &lt;em&gt;names&lt;/em&gt; available for machine code, since fewer register names leads to more compact instructions (fewer bits) in memory and more efficient utilization of memory buses and caches.&lt;/li&gt;
  &lt;li&gt;On the other hand, they would like to give compilers / JIT engines as much flexibility as possible in using as many registers as they want (possibly hundreds) without needing to move their contents into memory (or more realistically: CPU cache) just because they ran out of registers names.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These contradicting requirements led CPU designers to decouple the idea of register names and register storage: modern CPUs have many more (hundreds) or physical registers (storage) in their register-file than they have names for our software to use. This is where register renaming enters the scene.&lt;/p&gt;

&lt;p&gt;What CPU designers have been doing, for quite a long time now (&lt;a href=&quot;https://ieeexplore.ieee.org/document/5392015&quot;&gt;before 1967&lt;/a&gt;, believe it or not!) is really remarkable: they have been employing a really neat trick that effectively gets the best of both worlds (i.e. satisfy both requirements) at the cost of more complexity, more power usage, and more stages in the pipeline (hence also a little slowdown in the execution of a single instruction) to achieve better pipeline utilization at the global scale.&lt;/p&gt;

&lt;p&gt;This optimization, named “Register renaming”, accomplishes just that: by analyzing &lt;em&gt;when&lt;/em&gt; a register is being &lt;strong&gt;written&lt;/strong&gt; (write-only, not read-write) to, the CPU “understands” that the previous value of that register is &lt;em&gt;no longer required&lt;/em&gt; for the execution of instructions reading/writing to that same register from that moment onwards, even if previous instructions have not completed (or started) execution! What this really means, is that if we go back to the naive (now you see why) dependency analysis we did in the previous section, it’s clear that each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;SUB&lt;/code&gt; pair are actually completely &lt;strong&gt;independent&lt;/strong&gt; of each other because they begin with overwriting &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;! In other words, each &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; having written to &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; is considered to be breaking the dependency chain from that moment onwards. 
What the CPU does, therefore, is continuously re-map &lt;em&gt;named&lt;/em&gt; registers to different register &lt;em&gt;locations&lt;/em&gt; on the register-file, according to the real dependency chain, and use that newly &lt;strong&gt;allocated&lt;/strong&gt; location within the register file (hence the initial “Allocation” stage at the IACA diagram above) until the dependency chain is broken again (e.g. the same register is written to again).&lt;br /&gt;
I cannot emphasize how important of a tool this is for the CPU. Register renaming allows it to schedule multiple instructions to execute concurrently, either at different stages of the same pipeline or in parallel in different execution ports (pipelines) that exist in a super-scalar CPU. Moreover, this optimization achieves this while keeping the machine code small and easy to decode, since there are very few bits allocated for register names!&lt;/p&gt;

&lt;p class=&quot;notice--info&quot;&gt;How big of a deal is this? How good is the CPU in using this renaming trick? To best answer this from a practical standpoint, I think, we can take a look into the disparity between how many register &lt;em&gt;names&lt;/em&gt; exist, for example, in the x64 architecture, that number being 16, and how &lt;em&gt;many physical register&lt;/em&gt; storage space there is on the register-file, for example, on an Intel Skylake CPU: 180 (!).&lt;/p&gt;

&lt;p&gt;After the temporary (renamed) register has finished its job for a given instruction chain, we are still, unfortunately, not &lt;em&gt;entirely&lt;/em&gt; done with it. Understand, that the CPU cannot look too far into the incoming instruction stream (mostly a few dozen bytes), and it can not know, with certainty, if the last written value it just wrote to a renamed register will not be required by some future part of the code it hasn’t seen yet, hundreds of instructions in the future. This brings us to the last phase of register renaming, which is retirement: The CPU must still write the last value for our &lt;em&gt;symbolic&lt;/em&gt; register (&lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt;) back to the canonical location of that register (a.k.a the “real” register), in case future instructions that have not been loaded/decoded will attempt to read that value.&lt;br /&gt;
Moreover, this retirement phase must be performed exactly in program order for the program to continue operating as its original intention was.&lt;/p&gt;

&lt;h3 id=&quot;wrapping-up-clearing-the-register-for-the-rescue&quot;&gt;Wrapping up: clearing the register for the rescue&lt;/h3&gt;

&lt;p&gt;So going back to our false-dependency bug, we can now hopefully understand the underlying issue and the fix armed with our new knowledge:&lt;/p&gt;

&lt;p&gt;Our Intel CPU wrongly misunderstands our &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction, when it comes to its dependency analysis: It &lt;strong&gt;“thinks”&lt;/strong&gt; our usage of &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; is not only writing to it but also reading from it.&lt;br /&gt;
This is the false-dependency at the root of this issue. We cannot see this with IACA, but we can understand it conceptually: If the CPU (wrongfully) “thinks” that our second &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; has to READ the previous &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; value, then no register renaming can occur at that point, and the second &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction cannot execute in parallel to the first one, it needs to wait for the completion of the first &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; and basically stall for a few precious cycles, in order for the previous &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; to be written back somewhere. Naturally this is true for every unrolled &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; in our loop and &lt;em&gt;also&lt;/em&gt; between loop iterations.&lt;br /&gt;
This alone is enough to cause the perf drop we saw originally with the C# code before CoreCLR was patched. Once the &lt;code class=&quot;highlighter-rouge&quot;&gt;xor esi,esi&lt;/code&gt; dependency breaker is added to the instruction stream, we are basically “informing” the CPU that we really are not dependent on the previous value of &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; and we allow it to perform register renaming from that point onwards. It still wrongfully thinks that &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; reads from &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; but thanks to our otherwise seemingly superfluous &lt;code class=&quot;highlighter-rouge&quot;&gt;xor&lt;/code&gt;, this is an &lt;em&gt;already renamed&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;rsi&lt;/code&gt; and the pipeline stall is averted.&lt;/p&gt;

&lt;p&gt;I think it is pretty clear by now, although we barely scratched the surface of CPU internals, that CPUs are very complex, and that in the race to extract more performance out of code, today’s out-of-order, super-scalar CPUs go into extreme lengths to find ways to parallelize machine code execution.&lt;br /&gt;
It should be also clear that it’s important to be able to &lt;a href=&quot;https://mechanical-sympathy.blogspot.com/2011/07/why-mechanical-sympathy.html&quot;&gt;empathize with the machine&lt;/a&gt; and understand the true nature of its inner workings to really be able to deal the weirdness we experience as we try to make stuff go faster.&lt;/p&gt;

&lt;p&gt;It would be great if all we needed to do was keep compiler and hardware developers well fed and well paid so we could do our job without needing to know any of this, and to a great extent, this statement is true. But more often than not, extreme performance requires deeper understanding.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;As a side note, after not doing serious C++ work for years, coming back to it and discovering sanitizers, cmake, google test &amp;amp; benchmark was a very pleasant surprise. I distinctly remember the surprise of writing C++ and not having violent murderous thoughts at the same time. &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Apparently Intel has fixed the bug (according to reports) for the &lt;code class=&quot;highlighter-rouge&quot;&gt;LZCNT&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;TZCNT&lt;/code&gt; instructions on Skylake processors, but not so for the &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction for reasons unknown to practically anyone. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;yes, x86 registers are weird in that way, where &lt;em&gt;some&lt;/em&gt; 64 bit registers have additional symbolic names referring to their lower 32, 16, and both 8 bit parts of their lower 16 bits, don’t ask. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:4&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;µop or micro-op, is a low-level hardware operation. The CPU Front-End is responsible for reading the x86 machine code and decoding them into one or more µops. &lt;a href=&quot;#fnref:4&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">As I’ve described in part 1 &amp;amp; part 2 of this series, I’ve recently overhauled an internal data structure we use at Work® to start using platform dependent intrinsics.</summary></entry><entry><title type="html">.NET Core 3.0 Intrinsics in Real Life - (Part 2/3)</title><link href="https://bits.houmus.org/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2" rel="alternate" type="text/html" title=".NET Core 3.0 Intrinsics in Real Life - (Part 2/3)" /><published>2018-08-19T15:26:28+00:00</published><updated>2018-08-19T15:26:28+00:00</updated><id>https://bits.houmus.org/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2</id><content type="html" xml:base="https://bits.houmus.org/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2">&lt;p&gt;As I’ve described in &lt;a href=&quot;/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1&quot;&gt;part 1&lt;/a&gt; of this series, I’ve recently overhauled an internal data structure we use at Work&lt;sup&gt;®&lt;/sup&gt; to start using &lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md&quot;&gt;platform dependent intrinsics&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you’ve not read part 1 yet, I suggest you do so, since we continue right where we left off…&lt;/p&gt;

&lt;p&gt;As a reminder, this series is made in 3 parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1&quot;&gt;The data-structure/operation that we’ll optimize and basic usage of intrinsics&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;Using intrinsics more effectively (this post).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3&quot;&gt;The C++ version(s) of the corresponding C# code, and what I learned from them&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of the code (C# &amp;amp; C++) is published under the &lt;a href=&quot;https://github.com/damageboy/bitgoo&quot;&gt;bitgoo github repo&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;pdep---parallel-bit-deposit&quot;&gt;PDEP - Parallel Bit Deposit&lt;/h3&gt;

&lt;p&gt;We’re about to twist our heads with a bit of a challenge: For me, this was a lot of fun, since I got to play with something I knew &lt;em&gt;nothing&lt;/em&gt; about which turned out to be very useful, and not only for this specific task, but useful in general.&lt;/p&gt;

&lt;p&gt;We’re going to optimize a subset of this method’s performance “spectrum”: lower bit counts.&lt;br /&gt;
If you go back to the previous iteration of the code, we can clearly see that apart from the one 64 bit &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; loop up at the top, the ratio between instructions executed and bits processed for low values of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; doesn’t look too good. I summed up the instruction counts from the JIT Dump linked above:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The 64-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; loop takes 10 instructions, split into two fragments of the function, processing 64 bits each iteration.&lt;/li&gt;
  &lt;li&gt;The rest of the code (31 instructions not including the &lt;code class=&quot;highlighter-rouge&quot;&gt;ret&lt;/code&gt;!) is spent processing the last &amp;lt;= 64 bits, executing a single time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;While just counting instructions isn’t the best profiling metric in the world, it’s still very revealing…&lt;br /&gt;
Wouldn’t it be great if we could do something to improve that last, long code fragment?
Guess what…&lt;br /&gt;
Yes we can! using a weird little instruction called &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit_Manipulation_Instruction_Sets#Parallel_bit_deposit_and_extract&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt;&lt;/a&gt; whose description (copy-pasted from &lt;a href=&quot;https://www.intel.com/content/dam/www/public/us/en/documents/manuals/64-ia-32-architectures-software-developer-instruction-set-reference-manual-325383.pdf&quot;&gt;Intel’s bible of instructions&lt;/a&gt; in page 922) goes like this:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;PDEP uses a mask in the second source operand (the third operand) to transfer/scatter contiguous low order bits in the first source operand (the second operand) into the destination (the first operand). PDEP takes the low bits from the first source operand and deposit them in the destination operand at the corresponding bit locations that are set in the second source operand (mask). All other bits (bits not set in mask) in destination are set to zero.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Luckily, it comes with a diagram that makes is more digestible:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pdep.svg&quot; alt=&quot;PDEP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I know this might be a bit intimidating at first, but what &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt; can do for us, in my own words, is this: Process a single 64-bit value (&lt;code class=&quot;highlighter-rouge&quot;&gt;SRC1&lt;/code&gt;) according to a mask of bits (&lt;code class=&quot;highlighter-rouge&quot;&gt;SRC2&lt;/code&gt;) and copy (“deposit”) the least-significant bits from &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC1&lt;/code&gt; (or from right to left in the diagram) into a destination register according to the the position of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits in the mask (&lt;code class=&quot;highlighter-rouge&quot;&gt;SRC2&lt;/code&gt;).&lt;br /&gt;
It definitely takes time to wrap your head around how/what can be done with this, and there are many more applications than just this bit-searching. To be honest, right after I read a &lt;a href=&quot;http://palms.ee.princeton.edu/PALMSopen/hilewitz06FastBitCompression.pdf&quot;&gt;paper&lt;/a&gt; about &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt;, which from what I gathered, was the inspiration that led to having these primitives in our processors and an extremely good paper for those willing to dive deeper, I felt like a hammer in search of a nail, in wanting to apply this somewhere, until I remembered I had &lt;em&gt;this&lt;/em&gt; little thing I need (e.g. this function) and I tried using it, still in C++, about 2 years ago…&lt;br /&gt;
It took me a good day of goofing around (I actually started with its sister instruction &lt;code class=&quot;highlighter-rouge&quot;&gt;PEXT&lt;/code&gt; ) with this on a white-board until I finally saw &lt;em&gt;a&lt;/em&gt; solution…
&lt;u&gt;*Note*&lt;/u&gt;: There might be other solutions, better than what I came up with, and if anyone reading this finds one, I would love to hear about it!&lt;/p&gt;

&lt;p&gt;For those of you who don’t like spoilers, this might be a good time to grab a piece of paper and try to figure out how &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt; could help us in processing the last 64 bits, where we know our target bit is hiding…&lt;/p&gt;

&lt;p&gt;If you are ready for the solution, I’ll just show the one-liner C# expression that replaces the &lt;strong&gt;31&lt;/strong&gt; instructions we saw the JIT emit for us to handle those last &amp;lt; 64 bits in our bitmap all the way town to &lt;strong&gt;13&lt;/strong&gt; instructions and just as importantly: with &lt;strong&gt;0&lt;/strong&gt; branching:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;c1&quot;&gt;// Where:&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// n is the # of the target bit we are searching for&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// value is the 64 bits when we know for sure that n is &quot;hiding&quot; within&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;offsetOfNthBit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TrailingZeroCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                         &lt;span class=&quot;nf&quot;&gt;ParallelBitDeposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1U&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It’s not trivial to see how/why this works just from reading the code, so lets break this down, for an imaginary case of a 16-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt; and assorted registers, for simplicity:&lt;/p&gt;

&lt;p&gt;As an example, let’s pretend we are are looking for the offset (position) of the 8&lt;sup&gt;th&lt;/sup&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bit.&lt;br /&gt;
We pass two operands to &lt;code class=&quot;highlighter-rouge&quot;&gt;ParallelBitDeposit()&lt;/code&gt;:&lt;br /&gt;
The &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC1&lt;/code&gt; operand has the value of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; left shifted by the bit number we are searching for minus 1, so for our case of &lt;code class=&quot;highlighter-rouge&quot;&gt;n = 8&lt;/code&gt;, we shift a single &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bit 7 bits to the left, ending up with:&lt;/p&gt;

&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;0b_0000_0000_1000_0000&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our “fake” 16-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC1&lt;/code&gt; now has a single &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bit in the &lt;strong&gt;position&lt;/strong&gt; that equals our target-bit &lt;strong&gt;count&lt;/strong&gt; (This last emphasis is important!)
Remember that by this point in our search function, we have made sure our &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; is within the range &lt;code class=&quot;highlighter-rouge&quot;&gt;1..64&lt;/code&gt;, so &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; can only be &lt;code class=&quot;highlighter-rouge&quot;&gt;0..63&lt;/code&gt; we we can never shift negative number of bits, or above the size of the register (this can be seen more easily in the full code listing below).&lt;/p&gt;

&lt;p&gt;As for &lt;code class=&quot;highlighter-rouge&quot;&gt;SRC2&lt;/code&gt;,  We load it up with our remaining portion of the bitmap, whose n&lt;sup&gt;th&lt;/sup&gt; lit bit position we are searching for, so with careful mashing of the keyboard, I came up with these random bits:&lt;/p&gt;

&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;0b_0001_0111_0011_0110&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is what executing &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt; with these two operands does:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/pdep-bitsearch-example-animated.svg&quot; alt=&quot;PDEP&quot; /&gt;&lt;/p&gt;

&lt;p&gt;By now, we’ve managed to generate a temporary value where only our original target-bit remains lit, in its original position, so thanks for that, &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt;! In a way, we’ve managed to tweak &lt;code class=&quot;highlighter-rouge&quot;&gt;PDEP&lt;/code&gt; into a custom masking opcode, capable of masking out the first &lt;code class=&quot;highlighter-rouge&quot;&gt;n-1&lt;/code&gt; lit bits…&lt;br /&gt;
Finally, all that remains is to use the BMI1 &lt;code class=&quot;highlighter-rouge&quot;&gt;TZCNT&lt;/code&gt; instruction to count the number of &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; bits leading up to our deposited &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bit marker. That number ends up being the offset of the n&lt;sup&gt;th&lt;/sup&gt; lit bit in the original bitmap! Cool, eh?&lt;/p&gt;

&lt;p&gt;Let’s look at the final code for this function:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bmi1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bmi2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;POPCNTAndBMI2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;--;&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// Here, we know for sure that 1 .. prevN .. 64 (including)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TrailingZeroCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;ParallelBitDeposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1U&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With the code out of the way, time to see if the whole thing paid off?&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Mean (ns)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Scaled to “POPCNTAndBMI1”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.232&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;9.497&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.62&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;40.259&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.34&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;193.253&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,581.082&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.32&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;23,174.989&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.51&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;341,087.341&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.82&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4,979,229.288&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.95&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;76,144,935.381&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.98&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Oh boy did it! results are much better for the lower counts of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;As expected, the scaling improved with &lt;em&gt;peak improvement&lt;/em&gt; compared to the previous version at &lt;code class=&quot;highlighter-rouge&quot;&gt;N==64&lt;/code&gt;, with a 400% speedup compared to the previous version!&lt;/li&gt;
  &lt;li&gt;As N grows beyond 64, this version’s performance resembles the previous version’s more and more (duh!).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All in all, everything looks as we would have expected so far…&lt;br /&gt;
Again, for those interested, here’s a &lt;a href=&quot;https://gist.github.com/9b049a464dc66237500454ed367a79aa&quot;&gt;gist&lt;/a&gt; of the JITDump, for your pleasure.&lt;/p&gt;

&lt;h3 id=&quot;loop-unrolling&quot;&gt;Loop Unrolling&lt;/h3&gt;

&lt;p&gt;A common optimization technique we haven’t used up to this point, is &lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_unrolling&quot;&gt;loop unrolling/unwinding&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The goal of loop unwinding is to increase a program’s speed by reducing 
or eliminating instructions that control the loop, such as &lt;a href=&quot;https://en.wikipedia.org/wiki/Pointer_arithmetic&quot;&gt;pointer arithmetic&lt;/a&gt; and “end of loop” tests on each iteration;[&lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_unrolling#cite_note-1&quot;&gt;1]&lt;/a&gt; reducing branch penalties; as well as hiding latencies including the delay in reading data from memory.[&lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_unrolling#cite_note-2&quot;&gt;2]&lt;/a&gt; To eliminate this &lt;a href=&quot;https://en.wikipedia.org/wiki/Computational_overhead&quot;&gt;computational overhead&lt;/a&gt;, loops can be re-written as a repeated sequence of similar independent statements.[&lt;a href=&quot;https://en.wikipedia.org/wiki/Loop_unrolling#cite_note-3&quot;&gt;3]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By now, we’re left with only one loop, so clearly the target of loop unrolling is the &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; loop.&lt;br /&gt;
After all, we are potentially going over thousands of bits, and by shoving more &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions in between the looping instructions, we can theoretically drive the CPU harder.&lt;br /&gt;
Not only that, but modern (in this case x86/x64) CPUs are notorious for having internal parallelism that comes in many shapes and forms. For &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; specifically, we know from &lt;a href=&quot;https://www.agner.org/optimize/instruction_tables.pdf&quot;&gt;Agner Fog’s Instruction Tables&lt;/a&gt; that:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Intel Skylake can execute certain &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions on two different execution ports, with a single &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; latency of 3 cycles, and a reciprocal throughput of 1 cycle, so a latency of &lt;code class=&quot;highlighter-rouge&quot;&gt;x + 2&lt;/code&gt; cycles as a best case, where &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is the number of &lt;strong&gt;continuous independent&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions.&lt;/li&gt;
  &lt;li&gt;AMD Ryzen can execute up to 4 &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions in 1 cycle, with a latency of 1 cycle, for &lt;strong&gt;continuous independent&lt;/strong&gt;  &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instructions, which is even more impressive (I’ve not yet been able to verify this somewhat extravagant claim…).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These numbers were measured on real CPUs, with very specific benchmarks that measure single independent instructions. They should &lt;strong&gt;not&lt;/strong&gt; be taken as a target performance for &lt;strong&gt;our&lt;/strong&gt; code, since we are attempting to solve a real-life problem, which isn’t limited to a single instruction and has at least SOME dependency between the different instructions and branching logic on top of that.&lt;br /&gt;
But the numbers do give us at least one thing: motivation to unroll our &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; loop and try to get more work out of the CPU by issuing independent &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; on different parts of our bitmap.&lt;/p&gt;

&lt;p&gt;Here’s the code that does this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bmi1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bmi2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;POPCNTAndBMI2Unrolled&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt;
            &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;--;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TrailingZeroCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
                        &lt;span class=&quot;nf&quot;&gt;ParallelBitDeposit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1U&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We had to change the code flow to account for the unrolled loop, but all in all this is pretty straight forward, so let’s see how this performs:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Mean (ns)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Scaled to POPCNTAndBMI2&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.249&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.04&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;10.904&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.15&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;50.368&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.11&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;208.272&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.13&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,580.026&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.99&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;21,282.905&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.92&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;255,186.977&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.74&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;3,730,420.068&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.77&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI2Unrolled&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;56,939,817.593&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.76&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;There are a few interesting things going on here:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For low bit-counts (&lt;code class=&quot;highlighter-rouge&quot;&gt;N &amp;lt;= 64&lt;/code&gt;) we can see a drop in performance compared to the previous version. That is totally acceptable: We’ve made the code longer and more branch-y, and all of this was done in order to gain some serious change on the other side of this benchmark (Also, in reality, no one ever complains that your code used to take 193ns, but is now taking 208ns :).&lt;/li&gt;
  &lt;li&gt;In other words: The drop is not horrible, And we hope to make up enough for it on higher bit counts.&lt;/li&gt;
  &lt;li&gt;And we are making up for it, kind of… We can see a 33%-ish speedup for &lt;code class=&quot;highlighter-rouge&quot;&gt;N &amp;gt;= 4096&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For those interested, here’s the &lt;a href=&quot;https://gist.github.com/c73959ad3dfe31e5d65e6bf273f53211&quot;&gt;JITDump&lt;/a&gt; of this version.&lt;/p&gt;

&lt;p&gt;In theory, we should be happy, pack our bags, and call it a day! We’ve done it, we’ve squeezed every last bit we could hope to.&lt;br /&gt;
&lt;strong&gt;Except we really didn’t…&lt;/strong&gt;&lt;br /&gt;
While it might not be clear from these results alone, the loop unrolling hit an unexpected snag: the performance improvement is actually disappointing.&lt;br /&gt;
How can I tell? Well, that’s simple: &lt;strong&gt;I’m cheating!&lt;/strong&gt;&lt;br /&gt;
I’ve already written parallel C++ code as part of this whole effort (to be honest, I wrote the C++ code two years before C# intrinsics were a thing), and I’ve seen where unrolled &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; can go, and this is not it.&lt;br /&gt;
Not &lt;em&gt;yet&lt;/em&gt; at least.&lt;/p&gt;

&lt;p&gt;From my C++ attempts, I know we should have seen a ~100% speedup in high bit-counts with loop unrolling, but we are seeing much less than that.&lt;/p&gt;

&lt;p&gt;To understand why though, and what is really going on here, you’ll have to wait for the next post, where we cover some of the C++ code, and possibly learn more about processors than we cared to know…&lt;/p&gt;

&lt;h2 id=&quot;mid-journey-conclusions&quot;&gt;Mid-Journey Conclusions&lt;/h2&gt;

&lt;p&gt;We’ve taken our not so bad code at the end of the first post and improved upon quite a lot!&lt;br /&gt;
I hope you’ve seen how trying to think outside the box, and finding creative ways to compound various intrinsics provided by the CPU can really pay off in performance, and even simplicity.&lt;/p&gt;

&lt;p&gt;With the positive things, we must also not forget there are some negative sides to working with intrinsics, which by now, you might also begin sensing them:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You’ll need to map which CPUs your users are using, and which CPU intrinsics are supported on each model (even within a single architecture, such as Intel/AMD x64 you’ll see great variation throughout different models!).&lt;/li&gt;
  &lt;li&gt;You’ll sometimes need to cryptic implementation-selection code, that uses the provided &lt;code class=&quot;highlighter-rouge&quot;&gt;.IsHardwareAccelerated&lt;/code&gt; properties (for example detecting &lt;code class=&quot;highlighter-rouge&quot;&gt;BMI1&lt;/code&gt; only CPUs vs. &lt;code class=&quot;highlighter-rouge&quot;&gt;BMI1&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;BMI2&lt;/code&gt; ones) to steer the JIT into the “best” implementation, while praying to the powers that be that the JIT will be intelligent enough to elide the un-needed code at generation time, and still inline the resulting code.&lt;/li&gt;
  &lt;li&gt;Due to having multiple implementations, architecture specific &lt;em&gt;testing&lt;/em&gt; becomes a new requirement.
This might sound basic to a C++ developer, but less so for C#/CLR developers; this would mean that you need to have access to x86 (both 32 and 64 bit) ,arm32,arm64 test agents and run tests on &lt;strong&gt;all of them&lt;/strong&gt; to be able to sleep calmly at night.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of these are considerations to be taken seriously, especially if you work outside of Microsoft (where there are considerably more resources for testing, and greater impact for using intrinsics at the same time), while considering intrinsics.&lt;/p&gt;

&lt;p&gt;In the &lt;a href=&quot;/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3&quot;&gt;next and final post&lt;/a&gt;, we’ll explore the performance bug I uncovered, and how generally C# compares to C++ for this sort of code…&lt;/p&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">As I’ve described in part 1 of this series, I’ve recently overhauled an internal data structure we use at Work® to start using platform dependent intrinsics.</summary></entry><entry><title type="html">.NET Core 3.0 Intrinsics in Real Life - (Part 1/3)</title><link href="https://bits.houmus.org/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1" rel="alternate" type="text/html" title=".NET Core 3.0 Intrinsics in Real Life - (Part 1/3)" /><published>2018-08-18T15:26:28+00:00</published><updated>2018-08-18T15:26:28+00:00</updated><id>https://bits.houmus.org/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1</id><content type="html" xml:base="https://bits.houmus.org/2018-08-18/netcoreapp3.0-intrinsics-in-real-life-pt1">&lt;p&gt;I’ve recently overhauled an internal data structure we use at Work&lt;sup&gt;®&lt;/sup&gt; to start using &lt;a href=&quot;https://github.com/dotnet/designs/blob/master/accepted/platform-intrinsics.md&quot;&gt;platform dependent intrinsics&lt;/a&gt;- the anticipated feature (for speed junkies like me, that is) which was released in preview form as part of CoreCLR 2.1: 
What follows is sort of a travel log of what I did and how the new CoreCLR functionality fares compared to writing C++ code, when processor intrinsics are involved.&lt;/p&gt;

&lt;p&gt;This series  will contain 3 parts:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;The data-structure/operation that we’ll optimize and basic usage of intrinsics (this post).&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2&quot;&gt;Using intrinsics more effectively&lt;/a&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;/2018-08-20/netcoreapp3.0-intrinsics-in-real-life-pt3&quot;&gt;The C++ version(s) of the corresponding C# code, and what I learned from them&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;All of the code (C# &amp;amp; C++) is published under the &lt;a href=&quot;https://github.com/damageboy/bitgoo&quot;&gt;bitgoo github repo&lt;/a&gt;, with build/run scripts in case someone wants to play with it and/or use it as a starting point for humiliating me with better versions.&lt;/p&gt;

&lt;p&gt;In order to keep people motivated:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;By the end of this post, we’ll already start using intrinsics, and see considerable speedup in our execution time&lt;/li&gt;
  &lt;li&gt;By the end of the 2&lt;sup&gt;nd&lt;/sup&gt; post, we will already see a &lt;strong&gt;300%&lt;/strong&gt; speed-up compared to my current .NET Core 2.1 production code, and:&lt;/li&gt;
  &lt;li&gt;By the end of the 3&lt;sup&gt;rd&lt;/sup&gt; post I hope to show how with some fixing in the JIT, we can probably get another 100%-ish improvement on top of &lt;strong&gt;that&lt;/strong&gt;, bringing us practically to C++ territory&lt;sup id=&quot;fnref:1&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;the-whatwhy-of-intrinsics&quot;&gt;The What/Why of Intrinsics&lt;/h2&gt;

&lt;p&gt;Processor intrinsics are a way to directly embed specific CPU instructions via special, fake method calls that the JIT replaces at code-generation time. Many of these instructions are considered exotic, and normal language syntax cannot map them cleanly.&lt;br /&gt;
The general rule is that a single intrinsic “function” becomes a single CPU instruction.&lt;/p&gt;

&lt;p&gt;Intrinsics are not really new to the CLR, and staples of .NET rely on having them around. For example, practically all of the methods in the &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=netframework-4.7.2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Interlocked&lt;/code&gt;&lt;/a&gt; class in &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Threading&lt;/code&gt; are essentially intrinsics, even if not referred to as such in the documentation. The same holds true for a vast set of vectorized mathematical operations exposed through the types in &lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.numerics?view=netframework-4.7.2&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;System.Numerics&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The recent, new effort to introduce more intrinsics in CoreCLR tries to provide additional processor specific intrinsics that deal with a wide range of interesting operations from sped-up cryptographic functions, random number generation to fused mathematical operations and various CPU/cache synchronization primitives.&lt;/p&gt;

&lt;p&gt;Unlike the previous cases mentioned, the new intrinsic wrappers in .NET Core don’t shy away from providing &lt;em&gt;model and architecture specific&lt;/em&gt; intrinsics, even in cases were only a small portion of actual CPUs might support them. In addition, a &lt;code class=&quot;highlighter-rouge&quot;&gt;.IsHardwareAccelerated&lt;/code&gt; property was sprinkled all over the BCL classes providing intrinsics to allow runtime discovery of what the CPU supports.&lt;/p&gt;

&lt;p&gt;On the performance/latency side, which is the focus of this series, we often find that intrinsics can replace tens of CPU instructions with one or two while possibly also eliminating branches (sometimes, more important than using less instructions…). This is compounded by the fact that the simplified instruction stream makes it possible for a modern CPU to “see” the dependencies between instructions (or lack thereof!) more clearly, and safely attempt to run multiple instructions in parallel even inside a &lt;strong&gt;single CPU core&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;While there are some downsides as well to using intrinsics, I’ll discuss some of those at the end of the second post; by then, I hope my warnings will fall on more welcoming ears.&lt;br /&gt;
Personally, I’m more than ready to take that plunge, so with that long preamble out of the way, let’s describe our starting point:&lt;/p&gt;

&lt;h2 id=&quot;the-bitmap-getnthbitoffset&quot;&gt;The Bitmap, GetNthBitOffset()&lt;/h2&gt;

&lt;p&gt;To keep it short, I’m purposely going to completely ignore the context the code we are about to discuss is a key part of (If there is interest, I may write a separate post about it).
For now, let’s accept that we have a god-given assignment in the form of a function that we really want to optimize the hell out of, without stopping to ask “Why?”.&lt;/p&gt;

&lt;h3 id=&quot;the-bitmap&quot;&gt;The Bitmap&lt;/h3&gt;

&lt;p&gt;This is dead simple: we have a bitmap which is potentially thousands or tens of thousands of bits long, which we will store somewhere as an &lt;code class=&quot;highlighter-rouge&quot;&gt;ulong[]&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;THIS_MANY_BITS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;66666&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;THIS_MANY_BITS&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// enough room for everyone&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;bits&lt;/code&gt; array in the sample above is continuously being mutated, and as bits go, this is going to be in the form of bits being turned on and off in no particular order, so imagine:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DateTime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Ticks&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;MaxValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()));&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;the-search-method&quot;&gt;The Search Method&lt;/h3&gt;

&lt;p&gt;We’re about to describe one of the two methods that I optimized.
I chose this particular method since it was the more challenging one to optimize. But before describing it, a short disclaimer is in order:&lt;/p&gt;

&lt;p&gt;The method is implemented with &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;ulong *&lt;/code&gt; rather than the managed/safe variants (&lt;code class=&quot;highlighter-rouge&quot;&gt;ulong[]&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;Span&amp;lt;ulong&amp;gt;&lt;/code&gt;). The reasons I’m using &lt;code class=&quot;highlighter-rouge&quot;&gt;unsafe&lt;/code&gt; are that for this type of code, which makes up double digit % of our CPU time, adding bounds-checking can be very destructive for performance; Specifically, in the context of this series where I’m about to compare C# with C++, we get an apples-to-apples comparison, as C++ is compiled without bounds-checking normally.&lt;/p&gt;

&lt;p&gt;With that out of the way, lets inspect the method signature:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetNthBitOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This method runs over the entire bitmap until it finds the n&lt;sup&gt;th&lt;/sup&gt; bit with the value &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;, or as I will refer to it here-on, our &lt;em&gt;target-bit&lt;/em&gt;, and returns its bit offset within the bitmap as its return value.
For brevity we &lt;em&gt;assume&lt;/em&gt; that incoming values of &lt;code class=&quot;highlighter-rouge&quot;&gt;n&lt;/code&gt; are never below &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; or above the number of &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits in the bitmap.&lt;/p&gt;

&lt;p&gt;Here’s a super naive implementation that achieves this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Naive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;leftInULong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x1U&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x1U&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;leftInULong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;--;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;leftInULong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Still more bits left in this ulong?&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;continue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*(++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Load a new 64 bit value        &lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;leftInULong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;initial-performance&quot;&gt;Initial Performance&lt;/h3&gt;

&lt;p&gt;This implementation is obviously pretty bad, performance wise. &lt;em&gt;But wait&lt;/em&gt;: There are lots of ways you could improve upon this: bit-twiddling hacks, LUTs and what we’re here for, processor intrinsics.&lt;/p&gt;

&lt;p&gt;Our next step is to start measuring this, and we’ll move on to better and better versions of this method, until we exhaust &lt;em&gt;my&lt;/em&gt; abilities to make this go any faster.&lt;br /&gt;
Using everyone’s favorite CLR microbenchmarking tool, &lt;a href=&quot;https://benchmarkdotnet.org/&quot;&gt;BDN&lt;/a&gt;, I wrote a small harness that preallocates a huge array of  bits, fills it up with random values (roughly 50% &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;), then executes the benchmark(s) over this array looking for all the offsets of &lt;strong&gt;lit&lt;/strong&gt; bits &lt;strong&gt;up to&lt;/strong&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;  where &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; is parametrized to be: 1, 8, 64, 512, 2048, 4096, 16384, 65536.
The benchmark code looks roughly like this:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;KB&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1024&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Params&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;16&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;KB&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Benchmark&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Naive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GetNthBitOffset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Naive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;N&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sum&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For those in the know, I’m NOT using BDN’s &lt;code class=&quot;highlighter-rouge&quot;&gt;OperationsPerInvoke()&lt;/code&gt; to normalize for &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; since the benchmark is looping over the entire bitmap, and the performance varies wildly throughout the loop.&lt;/p&gt;

&lt;p&gt;Running this gives us the following results:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Mean (ns)&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1.185&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;35.308&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;605.021&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;6,368.355&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;99,448.636&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2,057,984.353&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;68,728,413.667&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,365,698,984.333&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Naive&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;22,669,217,647.333&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;A couple of comments about these results:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Small numbers of bits actually work out OK-ish given how bad the code is.&lt;/li&gt;
  &lt;li&gt;Yes, finding all the offsets of the first 64k lit bits (so 64K calls times average length of 64K bits processed per call&lt;sup id=&quot;fnref:2&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;) takes a whopping 22+ seconds…&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;prepping-the-machine--clr--environmental-information&quot;&gt;Prepping the Machine / CLR + Environmental information&lt;/h3&gt;

&lt;p&gt;Here is the BDN environmental data about my machine:&lt;/p&gt;

&lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;py&quot;&gt;BenchmarkDotNet&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;v0.11.0, OS=ubuntu 18.04&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;Intel&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;i7-7700HQ&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CPU&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;2.80GHz&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(Sky&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Lake),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CPU,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;logical&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;physical&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;cores&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;.NET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt; &lt;span class=&quot;py&quot;&gt;SDK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3.0.100-alpha1-20180720-2&lt;/span&gt;
  &lt;span class=&quot;nn&quot;&gt;[Host]&lt;/span&gt;   &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.NET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;3.0.0-preview1-26814-05&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(CoreCLR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;4.6.26814.06,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CoreFX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;4.6.26814.01),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;64bit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RyuJIT&lt;/span&gt;
  &lt;span class=&quot;err&quot;&gt;ShortRun&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;.NET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;?&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(CoreCLR&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;4.6.26814.06,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;CoreFX&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;4.6.26814.01),&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;64bit&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;RyuJIT&lt;/span&gt;

&lt;span class=&quot;py&quot;&gt;Job&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;ShortRun  Toolchain=3.0.100-alpha1-20180720-2  IterationCount=3  &lt;/span&gt;
&lt;span class=&quot;py&quot;&gt;LaunchCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;1  WarmupCount=3  &lt;/span&gt;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Keen eyes will notice I’m running this with .NET Core 3.0 pre-alpha / preview.
While this is completely uncalled for the code we’ve seen so far, the next variations will actually depend on having .NET Core 3.0 around, so I ran the whole benchmark set with 3.0.&lt;/p&gt;

&lt;p&gt;I’m using an excellent &lt;a href=&quot;https://github.com/damageboy/bitcrap/blob/master/prep.sh&quot;&gt;prep.sh&lt;/a&gt; originally prepared by &lt;a href=&quot;https://www.alexgallego.org/&quot;&gt;Alexander Gallego&lt;/a&gt; that basically kills the Turbo effect on modern CPUs, by setting up the min/max frequencies to the base clock of the machine (e.g. what you would get when running 100% CPU on all cores).&lt;/p&gt;

&lt;p&gt;My laptop has an &lt;a href=&quot;https://ark.intel.com/products/97185/Intel-Core-i7-7700HQ-Processor-6M-Cache-up-to-3_80-GHz&quot;&gt;Intel i7 Skylake processor model 7700HQ&lt;/a&gt; with a base frequency of 2.8Ghz, so I ran the following commands on my laptop as &lt;code class=&quot;highlighter-rouge&quot;&gt;root&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nb&quot;&gt;source &lt;/span&gt;prep.sh &lt;span class=&quot;c&quot;&gt;# to get the bash functions used below&lt;/span&gt;
cpu_enable_performance_cpupower_state
cpu_set_min_frequencies 2800000
cpu_set_max_frequencies 2800000
cpu_available_frequencies &lt;span class=&quot;c&quot;&gt;# should print 2800000 for all 4 cores, in my case&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;This is done so that the numbers presented here are applicable for multi-core machines running this code on all cores, and so that very short benchmarks don’t get skewed results compared to longer benchmarks due to CPU frequency scaling.&lt;/p&gt;

&lt;h2 id=&quot;popcount-without-popcnt&quot;&gt;PopCount() without POPCNT&lt;/h2&gt;

&lt;p&gt;Now that we have the initial code out of the way, we’re not going to look at it anymore. The next version will use bit-twiddling hacks in order to count larger groups of bits much faster.&lt;/p&gt;

&lt;p&gt;We’ll introduce two pure C# functions that implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_weight&quot;&gt;population counts&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The &lt;strong&gt;Hamming weight&lt;/strong&gt; of a &lt;a href=&quot;https://en.wikipedia.org/wiki/String_(computer_science)&quot;&gt;string&lt;/a&gt; is the number of symbols that are different from the zero-symbol of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Alphabet&quot;&gt;alphabet&lt;/a&gt; used. It is thus equivalent to the &lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_distance&quot;&gt;Hamming distance&lt;/a&gt; from the all-zero string of the same length. For the most typical case, a string of &lt;a href=&quot;https://en.wikipedia.org/wiki/Bit&quot;&gt;bits&lt;/a&gt;, this is the number of 1’s in the string, or the &lt;a href=&quot;https://en.wikipedia.org/wiki/Digit_sum&quot;&gt;digit sum&lt;/a&gt; of the &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_numeral_system&quot;&gt;binary representation&lt;/a&gt; of a given number and the &lt;a href=&quot;https://en.wikipedia.org/wiki/Taxicab_geometry&quot;&gt;&lt;em&gt;ℓ&lt;/em&gt;₁ norm&lt;/a&gt; of a bit vector. In this binary case, it is also called the &lt;strong&gt;population count&lt;/strong&gt;,[&lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_weight#cite_note-Warren_2013-1&quot;&gt;1]&lt;/a&gt; &lt;strong&gt;popcount&lt;/strong&gt;, &lt;strong&gt;sideways sum&lt;/strong&gt;,[&lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_weight#cite_note-Knuth_2009-2&quot;&gt;2]&lt;/a&gt; or &lt;strong&gt;bit summation&lt;/strong&gt;.[&lt;a href=&quot;https://en.wikipedia.org/wiki/Hamming_weight#cite_note-HP-16C_1982-3&quot;&gt;3]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ultimately, one of the key processor intrinsics we will use is… &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; which does exactly this, as a single instruction at the processor level, but for now, we will implement a &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; method without those intrinsics, for 64/32 bit inputs.&lt;br /&gt;
Apart from &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; we will also define a &lt;code class=&quot;highlighter-rouge&quot;&gt;TrailingZeroCount()&lt;/code&gt;&lt;sup id=&quot;fnref:3&quot; role=&quot;doc-noteref&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt; method, that counts trailing zero bits. I chose an implementation that uses &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; internally.&lt;br /&gt;
Here are the two &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;TrailingZeroCount()&lt;/code&gt;methods shamelessly stolen throughout the interwebs from &lt;a href=&quot;https://github.com/hcs0/Hackers-Delight/blob/master/pop.c.txt&quot;&gt;Hacker’s delight&lt;/a&gt;:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;HackersDelight&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x5555555555555555&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x3333333333333333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x3333333333333333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x0f0f0f0f0f0f0f0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x0101010101010101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;56&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x55555555&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x33333333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x33333333&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x0f0f0f0f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unchecked&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0x01010101&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;24&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TrailingZeroCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;These methods can quickly and &lt;strong&gt;without&lt;/strong&gt; a single branch instruction, count the lit bits in 64/32 bit words, with just 12 arithmetic operations, most of them simple bit operations and only one (!) multiplication.&lt;/p&gt;

&lt;p&gt;With our bit-twiddling optimized functions implemented and out of the way, let’s put them to good use in a new implementation, and make a few changes in the flow of the code:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BitGoo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HackersDelight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;unsafe&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;NoIntrisics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ulong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numBits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// (1)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;do&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// (2)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p64&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;PopCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;++;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// (3)&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prevValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p32&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;*)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;TrailingZeroCount&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prevValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;--;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;prevValue&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;&amp;gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Our new approach to solving this goes like this (comments correspond to blocks of the code above):&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;As long as we &lt;strong&gt;still&lt;/strong&gt; need to look for &lt;em&gt;any&lt;/em&gt;  &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits, we loop, calling &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; until we finally consume more bits than what we were tasked with… At that stage our &lt;code class=&quot;highlighter-rouge&quot;&gt;p64&lt;/code&gt; pointer is pointing 1 &lt;code class=&quot;highlighter-rouge&quot;&gt;ulong&lt;/code&gt; beyond the &lt;code class=&quot;highlighter-rouge&quot;&gt;ulong&lt;/code&gt; containing our target-bit, and &lt;code class=&quot;highlighter-rouge&quot;&gt;prevN&lt;/code&gt; contains the number of consumed &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; bits that was still correct one &lt;code class=&quot;highlighter-rouge&quot;&gt;ulong&lt;/code&gt; before.&lt;/li&gt;
  &lt;li&gt;Once we’re out of the loop, we know that out target-bit is hiding somewhere &lt;em&gt;within&lt;/em&gt; that last 64-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;ulong&lt;/code&gt;. So we will use a single 32-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; to figure out if its within the first/second 32-bit words making up &lt;em&gt;that&lt;/em&gt; 64-bit word and update the bit-counts / &lt;code class=&quot;highlighter-rouge&quot;&gt;p32&lt;/code&gt; pointer accordingly.&lt;/li&gt;
  &lt;li&gt;Now, we know that &lt;code class=&quot;highlighter-rouge&quot;&gt;p32&lt;/code&gt; is pointing to the 32-bit word containing our target-bit &lt;code class=&quot;highlighter-rouge&quot;&gt;p32&lt;/code&gt;, so we find the target-bit, by using &lt;code class=&quot;highlighter-rouge&quot;&gt;TrailingZeroCount()&lt;/code&gt; and right shifting in a loop until we find the target bit’s position within the word, finally returning the offset when we’re done.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Let’s take a look at how this version fairs:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Mean (ns)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Scaled to “Naive”&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5.247&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;4.19&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;43.919&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.79&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;429.974&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.58&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2,986.498&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;16,492.408&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.16&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;112,049.075&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.06&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;1,058,565.813&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.02&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;13,714,191.734&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.010&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;NoIntrisics&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;206,236,218.000&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.009&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Quite an improvement already! To be fair, our starting point being so low helped a lot, but still an improvement.
As a side note, this is, essentially, the code I’m running on our own bitmaps in production right now, since I don’t have intrinsics right now.&lt;/p&gt;

&lt;p&gt;If there’s really one column where our focus should gravitate towards it’s the “Scaled” column on the right of the table. Each result here is scaled to its corresponding &lt;code class=&quot;highlighter-rouge&quot;&gt;Naive&lt;/code&gt; version:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;For any bit length &amp;lt; 16, the old version runs faster, but marginally so, in absolute terms.&lt;/li&gt;
  &lt;li&gt;Once we hit &lt;code class=&quot;highlighter-rouge&quot;&gt;N == 16&lt;/code&gt; and upwards, the landscape changes dramatically and our bit-twiddling &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; starts paying off big-time: the speedup for 64 is already &amp;gt; 100% all the way up to 11100% speedup @ 64K.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;coreclr--architecture-dependent-intrinsics&quot;&gt;CoreCLR &amp;amp; Architecture Dependent Intrinsics&lt;/h2&gt;

&lt;p&gt;Let us remind ourselves where things stand at the time of writing this post, when it comes to using intrinsics in CoreCLR:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;.NET Core 2.1 was released on May 30&lt;sup&gt;th&lt;/sup&gt; 2018, with Intrinsics released as a “preview” feature:
    &lt;ul&gt;
      &lt;li&gt;The 2.1 JIT kind of knows how to handle &lt;em&gt;some&lt;/em&gt; intrinsics.&lt;/li&gt;
      &lt;li&gt;To actually use them, we need to use the dotnet-core myget feed and install an experimental nuget package that provides the API surface for the intrinsics.&lt;/li&gt;
      &lt;li&gt;No commitments were made that things would be stable/working.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;.NET Core 3.0 is the official (so far?) target release for intrinsics support in .NET Core:
    &lt;ul&gt;
      &lt;li&gt;Considerably more intrinsics are supported than what was available with 2.1.&lt;/li&gt;
      &lt;li&gt;No extra nuget package is required (intrinsics are part of the SDK).&lt;/li&gt;
      &lt;li&gt;Work is still being very actively done to add more intrinsics and improve the quality of what is already there.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As we require intrinsics that were not available with 2.1, The code in &lt;a href=&quot;https://github.com/damageboy/bitgoo&quot;&gt;repo&lt;/a&gt; is targeting a pre-alpha1 version of .NET Core 3.0 (i.e. &lt;code class=&quot;highlighter-rouge&quot;&gt;netcoreapp3.0&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;For people wanting to run this code, it’s relatively easy to do so, and non-destructive to your current setup:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Go to the &lt;a href=&quot;https://github.com/dotnet/core-sdk#installers-and-binaries&quot;&gt;Installers and Binaries&lt;/a&gt; section of the core-sdk project.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;The left most column contains .NET Core Master branch builds (3.0.x Runtime).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Download the appropriate installer in &lt;code class=&quot;highlighter-rouge&quot;&gt;.zip&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar.gz&lt;/code&gt; form: I used the &lt;a href=&quot;https://dotnetcli.blob.core.windows.net/dotnet/Sdk/master/dotnet-sdk-latest-linux-x64.tar.gz&quot;&gt;linux&lt;/a&gt; one, but the &lt;a href=&quot;https://dotnetcli.blob.core.windows.net/dotnet/Sdk/master/dotnet-sdk-latest-win-x64.zip&quot;&gt;windows&lt;/a&gt; / &lt;a href=&quot;https://dotnetcli.blob.core.windows.net/dotnet/Sdk/master/dotnet-sdk-latest-osx-x64.tar.gz&quot;&gt;osx&lt;/a&gt; ones should be just as good.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;unzip/untar the installer somewhere (*Nix users beware: Microsoft does this entirely inhumane thing of packaging the contents of their distribution as the top level of &lt;code class=&quot;highlighter-rouge&quot;&gt;.tar.gz&lt;/code&gt;, so be sure to &lt;code class=&quot;highlighter-rouge&quot;&gt;mkdir dotnet; tar -C dotnet xf /path/to/where/you/downloaded/the/tar.gz&lt;/code&gt; to avoid heart-ache).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Adjust your &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; env. to find the &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet&lt;/code&gt; executable in the new folder you just unzipped to, before anywhere else. (I did this locally in my terminal session).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;You should now be able to &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet restore|build|run|test&lt;/code&gt; the BitGoo project(s).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Just to be on the safe side, here is what &lt;code class=&quot;highlighter-rouge&quot;&gt;dotnet --info&lt;/code&gt; prints for me:&lt;/p&gt;

    &lt;div class=&quot;language-ini highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;err&quot;&gt;.NET&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Core&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;SDK&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;(reflecting&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;any&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;global.json):&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;Version:&lt;/span&gt;   &lt;span class=&quot;err&quot;&gt;3.0.100-alpha1-20180720-2&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;Commit:&lt;/span&gt;    &lt;span class=&quot;err&quot;&gt;82bd85d0a9&lt;/span&gt;
   
&lt;span class=&quot;err&quot;&gt;Runtime&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Environment:&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;OS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Name:&lt;/span&gt;     &lt;span class=&quot;err&quot;&gt;ubuntu&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;OS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Version:&lt;/span&gt;  &lt;span class=&quot;err&quot;&gt;18.04&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;OS&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Platform:&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;Linux&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;RID:&lt;/span&gt;         &lt;span class=&quot;err&quot;&gt;ubuntu.18.04-x64&lt;/span&gt;
 &lt;span class=&quot;err&quot;&gt;...&lt;/span&gt; &lt;span class=&quot;c&quot;&gt;# No one really cares that much
&lt;/span&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;using-popcnt--tzcnt&quot;&gt;Using POPCNT &amp;amp; TZCNT&lt;/h2&gt;

&lt;p&gt;The next step will be to replace our bit-twiddling &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; code with the &lt;code class=&quot;highlighter-rouge&quot;&gt;PopCount()&lt;/code&gt; intrinsic provided by &lt;code class=&quot;highlighter-rouge&quot;&gt;System.Runtime.Intrinsics.X86.Popcnt&lt;/code&gt; class in the 3.0 BCL, which should be replaced by a single CPU &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; instruction by the JIT at runtime.
In addition, we will also use the &lt;code class=&quot;highlighter-rouge&quot;&gt;BMI1&lt;/code&gt; (&lt;strong&gt;B&lt;/strong&gt;it &lt;strong&gt;M&lt;/strong&gt;anipulation &lt;strong&gt;I&lt;/strong&gt;ntrinsics &lt;strong&gt;1&lt;/strong&gt;) &lt;code class=&quot;highlighter-rouge&quot;&gt;TrailingZeroCount()&lt;/code&gt; intrinsic which maps to the &lt;code class=&quot;highlighter-rouge&quot;&gt;TZCNT&lt;/code&gt; instruction.&lt;/p&gt;

&lt;p&gt;These instructions do exactly what our previous hand written implementation did, except it’s done with dedicated circuitry in our CPUs, takes up less instructions in the instruction stream, runs faster and can be parallelized  internally inside the processor.
I was very careful in the last post / code-sample, to use the exact same function name(s) as the intrinsics provided by the 3.0 BCL, so really, the code change comes down to mostly adjusting the two top &lt;code class=&quot;highlighter-rouge&quot;&gt;using static&lt;/code&gt; statements:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Popcnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Runtime&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Intrinsics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X86&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Bmi1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Rest of the code is the same...&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;That’s it!  We’re using intrinsics, all done!&lt;br /&gt;
If you are having a hard time trusting me, here’s a &lt;a href=&quot;https://github.com/damageboy/bitgoo/blob/master/csharp/BitGoo/GetNthBitOffset.POPCNTAndBMI1.cs&quot;&gt;link to the complete code&lt;/a&gt;.
Here are the results, this time scaled to the &lt;code class=&quot;highlighter-rouge&quot;&gt;NoIntrinsics()&lt;/code&gt; version:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th&gt;N&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Mean (ns)&lt;/th&gt;
      &lt;th style=&quot;text-align: right&quot;&gt;Scaled to “NoIntrinsics”`&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;2.358&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.44&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;15.318&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.35&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;16&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;128.712&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.31&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;64&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;916.033&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.27&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;256&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5,005.190&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.30&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;1024&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;44,606.327&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.39&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;4096&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;408,871.712&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.39&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;16384&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;5,205,533.285&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.39&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;POPCNTAndBMI1&lt;/td&gt;
      &lt;td&gt;65536&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;76,186,499.286&lt;/td&gt;
      &lt;td style=&quot;text-align: right&quot;&gt;0.37&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;OK, now we’re talking…&lt;br /&gt;
There can be no doubt that we have SOMETHING working: we can see a very substantial improvement across the board for every value of &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt;!. &lt;br /&gt;
There are some weird things still happening here that I cannot fully explain yet at this stage, namely: how the scaling becomes relatively worse as &lt;code class=&quot;highlighter-rouge&quot;&gt;N&lt;/code&gt; increases, but there is little to generally complain about.&lt;/p&gt;

&lt;p&gt;For those with a need to see assembly code to feel convinced, I’ve uploaded JITDumps to a &lt;a href=&quot;https://gist.github.com/b4500d6b7157051551346107786ae4fa&quot;&gt;gist&lt;/a&gt;, where you can clearly see the various &lt;code class=&quot;highlighter-rouge&quot;&gt;POPCNT&lt;/code&gt; / &lt;code class=&quot;highlighter-rouge&quot;&gt;LZCNT&lt;/code&gt; instructions throughout the ASM code (scroll to the end of the dump…).&lt;/p&gt;

&lt;h3 id=&quot;whats-next&quot;&gt;What’s Next?&lt;/h3&gt;

&lt;p&gt;We’ve reached pretty far, and I hope it was interesting even if a bit introductory.&lt;br /&gt;
In the next post, we’ll continue iterating on this task, introducing new intrinsics in the process, and encounter some “interesting” quirks.&lt;/p&gt;

&lt;p&gt;If you feel like you’re up for it, the next post is &lt;a href=&quot;/2018-08-19/netcoreapp3.0-intrinsics-in-real-life-pt2&quot;&gt;here&lt;/a&gt;…&lt;/p&gt;

&lt;hr /&gt;
&lt;div class=&quot;footnotes&quot; role=&quot;doc-endnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Worry not, I reported and &lt;a href=&quot;https://github.com/dotnet/coreclr/issues/19555&quot;&gt;opened an issue on CoreCLR^1&lt;/a&gt; before even starting to write this post and plan to do a deep-dive into this on the 3rd post &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;Since our bitmap is filled with roughly 50% &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt;/&lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt; values, searching for 64K lit bits means going over roughly 128K bits, as an example. &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot; role=&quot;doc-endnote&quot;&gt;
      &lt;p&gt;The TrailingZeroCount() method I’ve used here is the fastest, from independent testing, for C#. There are others but they either depend on having a compiler that can use CMOV instructions (which CoreCLR doesn’t yet), or on using LUTs (Look Up Tables) which I dislike since they tend to win benchmarks while losing in bigger scope of where the code is used, so I have a semi-religious bias against them. &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot; role=&quot;doc-backlink&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>damageboy</name><email>dans@houmus.org</email><uri>https://bits.houmus.org</uri></author><summary type="html">I’ve recently overhauled an internal data structure we use at Work® to start using platform dependent intrinsics- the anticipated feature (for speed junkies like me, that is) which was released in preview form as part of CoreCLR 2.1: What follows is sort of a travel log of what I did and how the new CoreCLR functionality fares compared to writing C++ code, when processor intrinsics are involved.</summary></entry></feed>